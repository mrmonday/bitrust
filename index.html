<!DOCTYPE html><html><head>
<title>BitRust - Breaking Changes in rust-lang/rust</title>
</head><body><pre>
commit 94c06a1be0ccfcf1a8e105fc98d126de372dbd40
Merge: de8bc44 1aedc45
Author:     bors &lt;bors@rust-lang.org&gt;
AuthorDate: Tue Feb 10 11:15:52 2015 +0000
Commit:     bors &lt;bors@rust-lang.org&gt;
CommitDate: Tue Feb 10 11:15:52 2015 +0000

    Auto merge of #22026 - kmcallister:plugin, r=sfackler
    
    ```rust
    #[plugin] #[no_link] extern crate bleh;
    ```
    
    becomes a crate attribute
    
    ```rust
    #![plugin(bleh)]
    ```
    
    The feature gate is still required.
    
    It's almost never correct to link a plugin into the resulting library / executable, because it will bring all of libsyntax and librustc with it. However if you really want this behavior, you can get it with a separate `extern crate` item in addition to the `plugin` attribute.
    
    Fixes #21043.
    Fixes #20769.
    
    [breaking-change]

commit 605225a366b62f29f5fd4b03cc298fff03bc3bdf
Author:     Alex Crichton &lt;alex@alexcrichton.com&gt;
AuthorDate: Fri Feb 6 14:47:55 2015 -0800
Commit:     Alex Crichton &lt;alex@alexcrichton.com&gt;
CommitDate: Mon Feb 9 15:58:13 2015 -0800

    std: Rename IntoIterator::Iter to IntoIter
    
    This is in preparation for stabilization of the `IntoIterator` trait. All
    implementations and references to `Iter` need to be renamed to `IntoIter`.
    
    [breaking-change]

commit 64a4decec779ee0a30585a12352d20a54b722506
Author:     Alex Crichton &lt;alex@alexcrichton.com&gt;
AuthorDate: Fri Feb 6 14:47:09 2015 -0800
Commit:     Alex Crichton &lt;alex@alexcrichton.com&gt;
CommitDate: Mon Feb 9 15:58:13 2015 -0800

    std: Remove typarms from IteratorExt::cloned
    
    With associated types an where clauses none of the type parameters are
    necessary.
    
    [breaking-change]

commit 93b642d9743edea728ef08b2d6fd17229caaad43
Author:     Keegan McAllister &lt;kmcallister@mozilla.com&gt;
AuthorDate: Fri Feb 6 13:56:38 2015 -0800
Commit:     Keegan McAllister &lt;kmcallister@mozilla.com&gt;
CommitDate: Mon Feb 9 13:27:27 2015 -0800

    Use a crate attribute to load plugins
    
        #[plugin] #[no_link] extern crate bleh;
    
    becomes a crate attribute
    
        #![plugin(bleh)]
    
    The feature gate is still required.
    
    It's almost never correct to link a plugin into the resulting library /
    executable, because it will bring all of libsyntax and librustc with it.
    However if you really want this behavior, you can get it with a separate
    `extern crate` item in addition to the `plugin` attribute.
    
    Fixes #21043.
    Fixes #20769.
    
    [breaking-change]

commit 74b8740719c1b427f79b67d6bc51e9d448dd9c49
Merge: bfaa1a8 312f8bd
Author:     bors &lt;bors@rust-lang.org&gt;
AuthorDate: Sun Feb 8 00:24:03 2015 +0000
Commit:     bors &lt;bors@rust-lang.org&gt;
CommitDate: Sun Feb 8 00:24:03 2015 +0000

    Auto merge of #21988 - kmcallister:no-std, r=sfackler
    
    Fixes #21833.
    
    [breaking-change]
    
    r? @alexcrichton
    
    The tests in #21912 will also need `#[feature(no_std)]`. If you're okay with both PRs, I can merge and test them.

commit d788588dce5525b2bf5674b0c90c791a70582330
Author:     Keegan McAllister &lt;kmcallister@mozilla.com&gt;
AuthorDate: Thu Feb 5 16:14:42 2015 -0800
Commit:     Keegan McAllister &lt;kmcallister@mozilla.com&gt;
CommitDate: Sat Feb 7 10:49:58 2015 -0800

    Feature-gate #![no_std]
    
    Fixes #21833.
    
    [breaking-change]

commit 61626b306314768b273892e3a547b896ef7a4dfd
Merge: ce5aad2 b445bf2
Author:     bors &lt;bors@rust-lang.org&gt;
AuthorDate: Sat Feb 7 18:20:55 2015 +0000
Commit:     bors &lt;bors@rust-lang.org&gt;
CommitDate: Sat Feb 7 18:20:55 2015 +0000

    Auto merge of #21984 - pnkfelix:make-for-loops-a-terminating-scope, r=nikomatsakis
    
    make `for PAT in ITER_EXPR { ... }` a terminating-scope for ITER_EXPR.
    
    In effect, temporary anonymous values created during the evaluation of ITER_EXPR no longer not live for the entirety of the block surrounding the for-loop; instead they only live for the extent of the for-loop itself, and no longer.
    
    ----
    
    There is one case I know of that this breaks, demonstrated to me by @nikomatsakis  (but it is also a corner-case that is useless in practice).  Here is that case:
    
    ```
    fn main() {
        let mut foo: Vec&lt;&amp;i8&gt; = Vec::new();
        for i in &amp;[1, 2, 3] { foo.push(i) }
    }
    ```
    
    Note that if you add any code following the for-loop above, or even a semicolon to the end of it, then the code will stop compiling (i.e., it gathers a vector of references but the gathered vector cannot actually be used.)
    
    (The above code, despite being useless, did occur in one run-pass test by accident; that test is updated here to accommodate the new striction.)
    
    ----
    
    So, technically this is a:
    
    [breaking-change]

commit 8661b3dc0fbb9e21b94266ba62e23cebb8f0603f
Merge: 80627cd 4583272
Author:     bors &lt;bors@rust-lang.org&gt;
AuthorDate: Sat Feb 7 14:08:38 2015 +0000
Commit:     bors &lt;bors@rust-lang.org&gt;
CommitDate: Sat Feb 7 14:08:38 2015 +0000

    Auto merge of #21971 - pnkfelix:fsk-restrict-fixdsz-array-moves, r=nikomatsakis
    
    Revised version of PR #21930.
    
    Restrictions on moves into and out-from fixed-length arrays.
    
    (There was only one use of this "feature" in the compiler source.)
    
    Note 1: the change to the error message in tests/compile-fail/borrowck-use-in-index-lvalue.rs, where we now report that *w is uninitialized (rather than w), was unintended fallout from the implementation strategy used here. The change appears harmless to me, but I welcome advice on how to bring back the old message, which was slightly cleaner (i.e. less unintelligible) since that the syntactic form *w does not actually appear in the source text.
    
    Note 2: the move out-from restriction to only apply to expr[i], and not destructuring bind (e.g. f([a, b, c]: Array) { ... }) since the latter is compatible with nonzeroing drop, AFAICT.
    
    [breaking-change]

commit cc8f35f874c81be1a5950d2527902b7dd5a94513
Author:     Felix S. Klock II &lt;pnkfelix@pnkfx.org&gt;
AuthorDate: Tue Feb 3 01:25:45 2015 +0100
Commit:     Felix S. Klock II &lt;pnkfelix@pnkfx.org&gt;
CommitDate: Sat Feb 7 13:44:00 2015 +0100

    Restrictions on moves out-from and into fixed-length arrays.
    
    No longer legal: `fn foo(a: [D; 5]) { drop(a); a[2] = D::new(); }`;
    one must first initialize the entirety of `a` before assigning to its
    individual elements.
    
    No longer legal: `fn foo(arr: [D; 5]) -&gt; D { arr[2] }`, unless `D`
    implements `Copy`. This "move out-from" restriction only affects
    `expr[i]`, and not destructuring (e.g. `f([a, b, c]: Array) { ... }`).
    
    uses mem_categorization to distinguish destructuring-bind from array
    indexing.
    
    See discussion on RFC PR 533.
    
    [breaking-change]

commit 0b6dbbc9cfb747df1db646bba16561c022704056
Merge: 7ebf9bc 724bf7b
Author:     bors &lt;bors@rust-lang.org&gt;
AuthorDate: Sat Feb 7 04:14:22 2015 +0000
Commit:     bors &lt;bors@rust-lang.org&gt;
CommitDate: Sat Feb 7 04:14:22 2015 +0000

    Auto merge of #21949 - japaric:index, r=nikomatsakis
    
    closes #21630
    
    Overloaded indexing (`&amp;[mut] foo[bar]`) only works when `&lt;Self as Index&gt;::Output` is the same as `&lt;Self as IndexMut&gt;::Output` (see issue above). To restrict implementations of `IndexMut` that doesn't work, this PR makes `IndexMut` a supertrait over `Index`, i.e. `trait IndexMut&lt;I&gt;: Index&lt;I&gt;`, just like in the `trait DerefMut: Deref` case.
    
    This breaks all downstream implementations of `IndexMut`, in most cases this simply means removing the `type Output = ..` bit, which is now redundant, from `IndexMut` implementations:
    
    ``` diff
     impl Index&lt;Foo&gt; for Bar {
         type Output = Baz;
         ..
     }
    
     impl IndexMut&lt;Foo&gt; for Bar {
    -    type Output = Baz;
         ..
     }
    ```
    
    [breaking-change]
    
    ---
    
    r? @nikomatsakis

commit df7db970dcdb7b7fb1080b9d66baf2e45b689914
Merge: fc1e045 67ee26d
Author:     Manish Goregaokar &lt;manishsmail@gmail.com&gt;
AuthorDate: Sat Feb 7 00:44:31 2015 +0530
Commit:     Manish Goregaokar &lt;manishsmail@gmail.com&gt;
CommitDate: Sat Feb 7 00:44:31 2015 +0530

    Rollup merge of #22009 - japaric:no-mov, r=alexcrichton
    
     If you were still using `MaybeOwnedVector`, update your code to use `CowVec`.
    
    [breaking-change]
    
    ---
    
    We already removed `MaybeOwned` (the string equivalent) long time ago and with a much shorter deprecation period. It's time to let go.

commit d1a1d339ef3fb89599f74c0cbae2183c7cf2ee25
Merge: 08a2bef 5cbbc12
Author:     Manish Goregaokar &lt;manishsmail@gmail.com&gt;
AuthorDate: Fri Feb 6 05:37:32 2015 +0530
Commit:     Manish Goregaokar &lt;manishsmail@gmail.com&gt;
CommitDate: Fri Feb 6 16:21:07 2015 +0530

    Rollup merge of #21951 - Gankro:entry, r=aturon
    
     This also removes two erroneous re-exports of the Entry variants, and so is incidentally a [breaking-change], though presumably no one should have been using those.
    
    r? @aturon

commit b445bf2bd1139236fd815bf93610ddaf17726111
Author:     Felix S. Klock II &lt;pnkfelix@pnkfx.org&gt;
AuthorDate: Wed Feb 4 13:24:44 2015 +0100
Commit:     Felix S. Klock II &lt;pnkfelix@pnkfx.org&gt;
CommitDate: Fri Feb 6 00:07:37 2015 +0100

    make `for PAT in ITER_EXPR { ... }` a terminating-scope for ITER_EXPR.
    
    In effect, temporary anonymous values created during the evaluation of
    ITER_EXPR no longer not live for the entirety of the block surrounding
    the for-loop; instead they only live for the extent of the for-loop
    itself, and no longer.
    
    ----
    
    There is one case I know of that this breaks, demonstrated to me by
    niko (but it is also a corner-case that is useless in practice).  Here
    is that case:
    
    ```
    fn main() {
        let mut foo: Vec&lt;&amp;i8&gt; = Vec::new();
        for i in &amp;[1, 2, 3] { foo.push(i) }
    }
    ```
    
    Note that if you add any code following the for-loop above, or even a
    semicolon to the end of it, then the code will stop compiling (i.e.,
    it gathers a vector of references but the gathered vector cannot
    actually be used.)
    
    (The above code, despite being useless, did occur in one run-pass test
    by accident; that test is updated here to accommodate the new
    striction.)
    
    ----
    
    So, technically this is a:
    
    [breaking-change]

commit c3e1f77291803d26b2897c0953dce5cf7e70ab65
Merge: d6c15d9 df1ac7a
Author:     bors &lt;bors@rust-lang.org&gt;
AuthorDate: Wed Feb 4 08:47:27 2015 +0000
Commit:     bors &lt;bors@rust-lang.org&gt;
CommitDate: Wed Feb 4 08:47:27 2015 +0000

    Auto merge of #21892 - huonw:deprecate-rand, r=alexcrichton
    
    Use [`rand`](https://crates.io/crates/rand) and [`derive_rand`](https://crates.io/crates/derive_rand) from crates.io.
    
    [breaking-change]

commit 8550bf74c1149eb54fc568bb53b78fd2b6caec98
Merge: 3b2ed14 45ddf50
Author:     Alex Crichton &lt;alex@alexcrichton.com&gt;
AuthorDate: Tue Feb 3 15:35:53 2015 -0800
Commit:     Alex Crichton &lt;alex@alexcrichton.com&gt;
CommitDate: Tue Feb 3 15:35:53 2015 -0800

    rollup merge of #21759: aturon/new-path
    
    This PR implements [path reform](https://github.com/rust-lang/rfcs/pull/474), and motivation and details for the change can be found there.
    
    For convenience, the old path API is being kept as `old_path` for the time being. Updating after this PR is just a matter of changing imports to `old_path` (which is likely not needed, since the prelude entries still export the old path API).
    
    This initial PR does not include additional normalization or platform-specific path extensions. These will be done in follow up commits or PRs.
    
    [breaking-change]
    
    Closes #20034
    Closes #12056
    Closes #11594
    Closes #14028
    Closes #14049
    Closes #10035

commit df1ac7aa63ea89a067c57663eab035f7b83f6933
Author:     Huon Wilson &lt;dbau.pp+github@gmail.com&gt;
AuthorDate: Tue Feb 3 20:11:38 2015 +1100
Commit:     Huon Wilson &lt;dbau.pp+github@gmail.com&gt;
CommitDate: Wed Feb 4 09:39:40 2015 +1100

    Deprecate in-tree `rand`, `std::rand` and `#[derive(Rand)]`.
    
    Use the crates.io crate `rand` (version 0.1 should be a drop in
    replacement for `std::rand`) and `rand_macros` (`#[derive_Rand]` should
    be a drop-in replacement).
    
    [breaking-change]

commit 3e39f0bc0e96f76610104918edaa5912f4f352df
Author:     Aaron Turon &lt;aturon@mozilla.com&gt;
AuthorDate: Thu Jan 29 14:03:36 2015 -0800
Commit:     Aaron Turon &lt;aturon@mozilla.com&gt;
CommitDate: Tue Feb 3 14:34:42 2015 -0800

    Rename std::path to std::old_path
    
    As part of [RFC 474](https://github.com/rust-lang/rfcs/pull/474), this
    commit renames `std::path` to `std::old_path`, leaving the existing path
    API in place to ease migration to the new one. Updating should be as
    simple as adjusting imports, and the prelude still maps to the old path
    APIs for now.
    
    [breaking-change]

commit d30f225b492163b14005d5069b7924f3fecf868c
Author:     Alex Crichton &lt;alex@alexcrichton.com&gt;
AuthorDate: Tue Feb 3 12:32:56 2015 -0800
Commit:     Alex Crichton &lt;alex@alexcrichton.com&gt;
CommitDate: Tue Feb 3 12:41:23 2015 -0800

    std: Remove `iter::ByRef` and generalize impls
    
    This removes the `ByRef` iterator adaptor to stay in line with the changes to
    `std::io`. The `by_ref` method instead just returns `&amp;mut Self`.
    
    This also removes the implementation of `Iterator for &amp;mut Iterator` and instead
    generalizes it to `Iterator for &amp;mut I` where `I: Iterator + ?Sized`. The
    `Box&lt;I&gt;` implementations were also updated.
    
    This is a breaking change due to the removal of the `std::iter::ByRef` type. All
    mentions of `ByRef&lt;'a, T&gt;` should be replaced with `&amp;mut T` to migrate forward.
    
    [breaking-change]

commit 99b2bd4bfa332c5a723114d09e8bb74d5a0c7376
Merge: 747e6b5 0e44484
Author:     Alex Crichton &lt;alex@alexcrichton.com&gt;
AuthorDate: Mon Feb 2 11:01:16 2015 -0800
Commit:     Alex Crichton &lt;alex@alexcrichton.com&gt;
CommitDate: Mon Feb 2 11:01:16 2015 -0800

    rollup merge of #21842: alexcrichton/issue-21839
    
    Now that associated types are fully implemented the iterator adaptors only need
    type parameters which are associated with actual storage. All other type
    parameters can either be derived from these (e.g. they are an associated type)
    or can be bare on the `impl` block itself.
    
    This is a breaking change due to the removal of type parameters on these
    iterator adaptors, but code can fairly easily migrate by just deleting the
    relevant type parameters for each adaptor. Other behavior should not be
    affected.
    
    Closes #21839
    [breaking-change]

commit 0e4448409ef61c703b98e4c5b2fd99447308942d
Author:     Alex Crichton &lt;alex@alexcrichton.com&gt;
AuthorDate: Sun Feb 1 12:15:36 2015 -0800
Commit:     Alex Crichton &lt;alex@alexcrichton.com&gt;
CommitDate: Sun Feb 1 13:05:23 2015 -0800

    std: Remove extra type params on iter adaptors
    
    Now that associated types are fully implemented the iterator adaptors only need
    type parameters which are associated with actual storage. All other type
    parameters can either be derived from these (e.g. they are an associated type)
    or can be bare on the `impl` block itself.
    
    This is a breaking change due to the removal of type parameters on these
    iterator adaptors, but code can fairly easily migrate by just deleting the
    relevant type parameters for each adaptor. Other behavior should not be
    affected.
    
    Closes #21839
    [breaking-change]

commit 70ed3a48dfa301c5bb56de3e0a7c25214539b83c
Author:     Alex Crichton &lt;alex@alexcrichton.com&gt;
AuthorDate: Tue Jan 27 12:20:58 2015 -0800
Commit:     Alex Crichton &lt;alex@alexcrichton.com&gt;
CommitDate: Sun Feb 1 11:08:15 2015 -0800

    std: Add a new `env` module
    
    This is an implementation of [RFC 578][rfc] which adds a new `std::env` module
    to replace most of the functionality in the current `std::os` module. More
    details can be found in the RFC itself, but as a summary the following methods
    have all been deprecated:
    
    [rfc]: https://github.com/rust-lang/rfcs/pull/578
    
    * `os::args_as_bytes`   =&gt; `env::args`
    * `os::args`            =&gt; `env::args`
    * `os::consts`          =&gt; `env::consts`
    * `os::dll_filename`    =&gt; no replacement, use `env::consts` directly
    * `os::page_size`       =&gt; `env::page_size`
    * `os::make_absolute`   =&gt; use `env::current_dir` + `join` instead
    * `os::getcwd`          =&gt; `env::current_dir`
    * `os::change_dir`      =&gt; `env::set_current_dir`
    * `os::homedir`         =&gt; `env::home_dir`
    * `os::tmpdir`          =&gt; `env::temp_dir`
    * `os::join_paths`      =&gt; `env::join_paths`
    * `os::split_paths`     =&gt; `env::split_paths`
    * `os::self_exe_name`   =&gt; `env::current_exe`
    * `os::self_exe_path`   =&gt; use `env::current_exe` + `pop`
    * `os::set_exit_status` =&gt; `env::set_exit_status`
    * `os::get_exit_status` =&gt; `env::get_exit_status`
    * `os::env`             =&gt; `env::vars`
    * `os::env_as_bytes`    =&gt; `env::vars`
    * `os::getenv`          =&gt; `env::var` or `env::var_string`
    * `os::getenv_as_bytes` =&gt; `env::var`
    * `os::setenv`          =&gt; `env::set_var`
    * `os::unsetenv`        =&gt; `env::remove_var`
    
    Many function signatures have also been tweaked for various purposes, but the
    main changes were:
    
    * `Vec`-returning APIs now all return iterators instead
    * All APIs are now centered around `OsString` instead of `Vec&lt;u8&gt;` or `String`.
      There is currently on convenience API, `env::var_string`, which can be used to
      get the value of an environment variable as a unicode `String`.
    
    All old APIs are `#[deprecated]` in-place and will remain for some time to allow
    for migrations. The semantics of the APIs have been tweaked slightly with regard
    to dealing with invalid unicode (panic instead of replacement).
    
    The new `std::env` module is all contained within the `env` feature, so crates
    must add the following to access the new APIs:
    
        #![feature(env)]
    
    [breaking-change]

commit f1f9cb705df95171fce4e575374c959509e58dea
Merge: fe4340a c3841b9
Author:     bors &lt;bors@rust-lang.org&gt;
AuthorDate: Sun Feb 1 10:14:51 2015 +0000
Commit:     bors &lt;bors@rust-lang.org&gt;
CommitDate: Sun Feb 1 10:14:51 2015 +0000

    Auto merge of #21809 - japaric:no-copy, r=alexcrichton
    
    Removes `Copy` from `ops::Range` (`a..b`) and `ops::RangeFrom` (`a..`)
    
    [breaking-change]
    
    ---
    
    I forgot about these two in #20790, this PR also adds `Clone` to the `Peekable` adapter which used to be `Copy`able.
    
    r? @nikomatsakis or anyone

commit 341e858bd882061b823dac236fd718d473f8ab2e
Merge: 1a51eb9 b9a9030
Author:     Alex Crichton &lt;alex@alexcrichton.com&gt;
AuthorDate: Fri Jan 30 12:02:44 2015 -0800
Commit:     Alex Crichton &lt;alex@alexcrichton.com&gt;
CommitDate: Fri Jan 30 12:02:44 2015 -0800

    rollup merge of #20790: japaric/for-loops
    
    As per [RFC #235][rfc], you can now do:
    
    [rfc]: https://github.com/rust-lang/rfcs/blob/master/text/0235-collections-conventions.md#intoiterator-and-iterable
    
    ``` rust
    let mut v = vec![1];
    
    // iterate over immutable references
    for x in &amp;v {
        assert_eq!(x, &amp;1);
    }
    
    // iterate over mutable references
    for x in &amp;mut v {
        assert_eq!(x, &amp;mut 1);
    }
    
    // iterate over values, this consumes `v`
    for x in v {
        assert_eq!(x, 1);
    }
    ```
    
    [breaking-change]s
    
    For loops now "consume" (move) the iterator, this breaks iterating over mutable references to iterators, and also breaks multiple iterations over the same iterator:
    
    ``` rust
    fn foo(mut it: &amp;mut Iter) {  // `Iter` implements `Iterator`
        for x in it { .. }  //~ error: `&amp;mut Iter` doesn't implement Iterator
    }
    
    fn bar() {
        for x in it { .. }  //~ note: `it` moved here
        for x in it { .. }  //~ error: `it` has been moved
    }
    ```
    
    Both cases can be fixed using the `by_ref()` adapter to create an iterator from the mutable reference:
    
    ``` rust
    fn foo(mut it: &amp;mut Iter) {
        for x in it.by_ref() { .. }
    }
    
    fn bar() {
        for x in it.by_ref() { .. }
        for x in it { .. }
    }
    ```
    
    This PR also makes iterator non-implicitly copyable, as this was source of subtle bugs in the libraries. You can still use `clone()` to explictly copy the iterator.
    
    Finally, since the for loops are implemented in the frontend and use global paths to `IntoIterator`, `Iterator` and `Option` variants, users of the `core` crate will have to use add an `std` module to the root of their crate to be able to use for loops:
    
    ``` rust
    #![no_std]
    
    extern crate core;
    
    fn main() {
        for x in 0..10 {}
    }
    
    #[doc(hidden)]
    mod std {
        // these imports are needed to use for-loops
        pub use core::iter;
        pub use core::option;
    }
    ```
    
    ---
    
    r? @nikomatsakis @aturon
    cc #18424
    closes #18045

commit 62273575139a80c2b208a3a27e0c2392b1425be6
Author:     Alex Crichton &lt;alex@alexcrichton.com&gt;
AuthorDate: Tue Jan 13 15:42:53 2015 -0800
Commit:     Alex Crichton &lt;alex@alexcrichton.com&gt;
CommitDate: Fri Jan 30 09:21:56 2015 -0800

    std: Stabilize the std::fmt module
    
    This commit performs a final stabilization pass over the std::fmt module,
    marking all necessary APIs as stable. One of the more interesting aspects of
    this module is that it exposes a good deal of its runtime representation to the
    outside world in order for `format_args!` to be able to construct the format
    strings. Instead of hacking the compiler to assume that these items are stable,
    this commit instead lays out a story for the stabilization and evolution of
    these APIs.
    
    There are three primary details used by the `format_args!` macro:
    
    1. `Arguments` - an opaque package of a "compiled format string". This structure
       is passed around and the `write` function is the source of truth for
       transforming a compiled format string into a string at runtime. This must be
       able to be constructed in stable code.
    
    2. `Argument` - an opaque structure representing an argument to a format string.
       This is *almost* a trait object as it's just a pointer/function pair, but due
       to the function originating from one of many traits, it's not actually a
       trait object. Like `Arguments`, this must be constructed from stable code.
    
    3. `fmt::rt` - this module contains the runtime type definitions primarily for
       the `rt::Argument` structure. Whenever an argument is formatted with
       nonstandard flags, a corresponding `rt::Argument` is generated describing how
       the argument is being formatted. This can be used to construct an
       `Arguments`.
    
    The primary interface to `std::fmt` is the `Arguments` structure, and as such
    this type name is stabilize as-is today. It is expected for libraries to pass
    around an `Arguments` structure to represent a pending formatted computation.
    
    The remaining portions are largely "cruft" which would rather not be stabilized,
    but due to the stability checks they must be. As a result, almost all pieces
    have been renamed to represent that they are "version 1" of the formatting
    representation. The theory is that at a later date if we change the
    representation of these types we can add new definitions called "version 2" and
    corresponding constructors for `Arguments`.
    
    One of the other remaining large questions about the fmt module were how the
    pending I/O reform would affect the signatures of methods in the module. Due to
    [RFC 526][rfc], however, the writers of fmt are now incompatible with the
    writers of io, so this question has largely been solved. As a result the
    interfaces are largely stabilized as-is today.
    
    [rfc]: https://github.com/rust-lang/rfcs/blob/master/text/0526-fmt-text-writer.md
    
    Specifically, the following changes were made:
    
    * The contents of `fmt::rt` were all moved under `fmt::rt::v1`
    * `fmt::rt` is stable
    * `fmt::rt::v1` is stable
    * `Error` is stable
    * `Writer` is stable
    * `Writer::write_str` is stable
    * `Writer::write_fmt` is stable
    * `Formatter` is stable
    * `Argument` has been renamed to `ArgumentV1` and is stable
    * `ArgumentV1::new` is stable
    * `ArgumentV1::from_uint` is stable
    * `Arguments::new_v1` is stable (renamed from `new`)
    * `Arguments::new_v1_formatted` is stable (renamed from `with_placeholders`)
    * All formatting traits are now stable, as well as the `fmt` method.
    * `fmt::write` is stable
    * `fmt::format` is stable
    * `Formatter::pad_integral` is stable
    * `Formatter::pad` is stable
    * `Formatter::write_str` is stable
    * `Formatter::write_fmt` is stable
    * Some assorted top level items which were only used by `format_args!` were
      removed in favor of static functions on `ArgumentV1` as well.
    * The formatting-flag-accessing methods remain unstable
    
    Within the contents of the `fmt::rt::v1` module, the following actions were
    taken:
    
    * Reexports of all enum variants were removed
    * All prefixes on enum variants were removed
    * A few miscellaneous enum variants were renamed
    * Otherwise all structs, fields, and variants were marked stable.
    
    In addition to these actions in the `std::fmt` module, many implementations of
    `Show` and `String` were stabilized as well.
    
    In some other modules:
    
    * `ToString` is now stable
    * `ToString::to_string` is now stable
    * `Vec` no longer implements `fmt::Writer` (this has moved to `String`)
    
    This is a breaking change due to all of the changes to the `fmt::rt` module, but
    this likely will not have much impact on existing programs.
    
    Closes #20661
    [breaking-change]

commit a9d465fec902588b71937de96e66d160d2adebf5
Author:     Nick Cameron &lt;ncameron@mozilla.com&gt;
AuthorDate: Wed Jan 28 14:27:28 2015 +1300
Commit:     Nick Cameron &lt;ncameron@mozilla.com&gt;
CommitDate: Fri Jan 30 12:00:20 2015 +1300

    Use absolute path to FullRange, rather than assuming it is in the prelude
    
    Closes #21263
    
    [breaking-change]
    
    If you are using `core::ops::FullRange` you should change to using `core::ops::RangeFull`

commit d77f6d5366b330f9c2061cad0d3ff638c9cc05b7
Merge: e365e4c d6bf04a
Author:     bors &lt;bors@rust-lang.org&gt;
AuthorDate: Tue Jan 27 11:07:26 2015 +0000
Commit:     bors &lt;bors@rust-lang.org&gt;
CommitDate: Tue Jan 27 11:07:26 2015 +0000

    Auto merge of #21657 - pnkfelix:block-remainder-extents, r=nikomatsakis
    
     Add `CodeExtent::Remainder` variant; pre-req for new scoping/drop rules.
    
    This new enum variant introduces finer-grain code extents, i.e. we now track that a binding lives only for a suffix of a block, and (importantly) will be dropped when it goes out of scope *before* the bindings that occurred earlier in the block.
    
    Both of these notions are neatly captured by marking the block (and each suffix) as an enclosing scope of the next suffix beneath it.
    
    This is work that is part of the foundation for issue #8861.
    
    (It actually has been seen in earlier posted pull requests, in particular #21022; I have just factored it out into its own PR to ease my own near-future rebasing, and also get people used to the new rules.)
    
    ----
    
    These finer grained scopes do mean that some code is newly rejected by `rustc`; for example:
    
    ```rust
    let mut map : HashMap&lt;u8, &amp;u8&gt; = HashMap::new();
    let tmp = Box::new(2);
    map.insert(43, &amp;*tmp);
    ```
    
    This will now fail to compile with a message that `*tmp` does not live long enough, because the scope of `tmp` is now strictly smaller than
    that of `map`, and the use of `&amp;u8` in map's type requires that the borrowed references are all to data that live at least as long as the map.
    
    The usual fix for a case like this is to move the binding for `tmp` up above that of `map`; note that you can still leave the initialization in the original spot, like so:
    
    ```rust
    let tmp;
    let mut map : HashMap&lt;u8, &amp;u8&gt; = HashMap::new();
    tmp = box 2;
    map.insert(43, &amp;*tmp);
    ```
    
    Similarly, one can encounter an analogous situation with `Vec`: one would need to rewrite:
    
    ```rust
    let mut vec = Vec::new();
    let tmp = 'c';
    vec.push(&amp;tmp);
    ```
    
    as:
    
    ```rust
    let tmp;
    let mut vec = Vec::new();
    tmp = 'c';
    vec.push(&amp;tmp);
    ```
    
    ----
    
    In some corner cases, it does not suffice to reorder the bindings; in particular, when the types for both bindings need to reflect exactly the *same* code extent, and a parent/child relationship between them does not work.
    
    In pnkfelix's experience this has arisen most often when mixing uses of cyclic data structures while also allowing a lifetime parameter `'a` to flow into a type parameter context where the type is *invariant* with respect to the type parameter. An important instance of this is `arena::TypedArena&lt;T&gt;`, which is invariant with respect to `T`.
    
    (The reason that variance is relevant is this: *if* `TypedArena` were covariant with respect to its type parameter, then we could assign it
    the longer lifetime when it is initialized, and then convert it to a subtype (via covariance) with a shorter lifetime when necessary.  But `TypedArena` is invariant with respect to its type parameter, and thus if `S` is a subtype of `T` (in particular, if `S` has a lifetime parameter that is shorter than that of `T`), then a `TypedArena&lt;S&gt;` is unrelated to `TypedArena&lt;T&gt;`.)
    
    Concretely, consider code like this:
    
    ```rust
    struct Node&lt;'a&gt; { sibling: Option&lt;&amp;'a Node&lt;'a&gt;&gt; }
    struct Context&lt;'a&gt; {
        // because of this field, `Context&lt;'a&gt;` is invariant with respect to `'a`.
        arena: &amp;'a TypedArena&lt;Node&lt;'a&gt;&gt;,
        ...
    }
    fn new_ctxt&lt;'a&gt;(arena: &amp;'a TypedArena&lt;Node&lt;'a&gt;&gt;) -&gt; Context&lt;'a&gt; { ... }
    fn use_ctxt&lt;'a&gt;(fcx: &amp;'a Context&lt;'a&gt;) { ... }
    
    let arena = TypedArena::new();
    let ctxt = new_ctxt(&amp;arena);
    
    use_ctxt(&amp;ctxt);
    ```
    
    In these situations, if you try to introduce two bindings via two distinct `let` statements, each is (with this commit) assigned a distinct extent, and the region inference system cannot find a single region to assign to the lifetime `'a` that works for both of the bindings. So you get an error that `ctxt` does not live long enough; but moving its binding up above that of `arena` just shifts the error so now the compiler complains that `arena` does not live long enough.
    
     * SO: What to do? The easiest fix in this case is to ensure that the two bindings *do* get assigned the same static extent, by stuffing both
    bindings into the same let statement, like so:
    
    ```rust
    let (arena, ctxt): (TypedArena, Context);
    arena = TypedArena::new();
    ctxt = new_ctxt(&amp;arena);
    
    use_ctxt(&amp;ctxt);
    ```
    
    ----
    
    Due to the new code restrictions outlined above, this is a ...
    
    [breaking-change]

commit d6bf04a22e78afbe62e9d81e3578418f420123bc
Author:     Felix S. Klock II &lt;pnkfelix@pnkfx.org&gt;
AuthorDate: Mon Jan 26 12:48:19 2015 +0100
Commit:     Felix S. Klock II &lt;pnkfelix@pnkfx.org&gt;
CommitDate: Tue Jan 27 10:26:52 2015 +0100

    Add `CodeExtent::Remainder` variant; pre-req for new scoping/drop rules.
    
    This new variant introduces finer-grain code extents, i.e. we now
    track that a binding lives only for a suffix of a block, and
    (importantly) will be dropped when it goes out of scope *before* the
    bindings that occurred earlier in the block.
    
    Both of these notions are neatly captured by marking the block (and
    each suffix) as an enclosing scope of the next suffix beneath it.
    
    This is work that is part of the foundation for issue #8861.
    
    (It actually has been seen in earlier posted pull requests; I have
    just factored it out into its own PR to ease my own rebasing.)
    
    ----
    
    These finer grained scopes do mean that some code is newly rejected by
    `rustc`; for example:
    
    ```rust
    let mut map : HashMap&lt;u8, &amp;u8&gt; = HashMap::new();
    let tmp = Box::new(2);
    map.insert(43, &amp;*tmp);
    ```
    
    This will now fail to compile with a message that `*tmp` does not live
    long enough, because the scope of `tmp` is now strictly smaller than
    that of `map`, and the use of `&amp;u8` in map's type requires that the
    borrowed references are all to data that live at least as long as the
    map.
    
    The usual fix for a case like this is to move the binding for `tmp`
    up above that of `map`; note that you can still leave the initialization
    in the original spot, like so:
    
    ```rust
    let tmp;
    let mut map : HashMap&lt;u8, &amp;u8&gt; = HashMap::new();
    tmp = box 2;
    map.insert(43, &amp;*tmp);
    ```
    
    Similarly, one can encounter an analogous situation with `Vec`: one
    would need to rewrite:
    
    ```rust
    let mut vec = Vec::new();
    let tmp = 'c';
    vec.push(&amp;tmp);
    ```
    
    as:
    
    ```
    let tmp;
    let mut vec = Vec::new();
    tmp = 'c';
    vec.push(&amp;tmp);
    ```
    
    ----
    
    In some corner cases, it does not suffice to reorder the bindings; in
    particular, when the types for both bindings need to reflect exactly
    the *same* code extent, and a parent/child relationship between them
    does not work.
    
    In pnkfelix's experience this has arisen most often when mixing uses
    of cyclic data structures while also allowing a lifetime parameter
    `'a` to flow into a type parameter context where the type is
    *invariant* with respect to the type parameter. An important instance
    of this is `arena::TypedArena&lt;T&gt;`, which is invariant with respect
    to `T`.
    
    (The reason that variance is relevant is this: *if* `TypedArena` were
    covariant with respect to its type parameter, then we could assign it
    the longer lifetime when it is initialized, and then convert it to a
    subtype (via covariance) with a shorter lifetime when necessary.  But
    `TypedArena` is invariant with respect to its type parameter, and thus
    if `S` is a subtype of `T` (in particular, if `S` has a lifetime
    parameter that is shorter than that of `T`), then a `TypedArena&lt;S&gt;` is
    unrelated to `TypedArena&lt;T&gt;`.)
    
    Concretely, consider code like this:
    
    ```rust
    struct Node&lt;'a&gt; { sibling: Option&lt;&amp;'a Node&lt;'a&gt;&gt; }
    struct Context&lt;'a&gt; {
        // because of this field, `Context&lt;'a&gt;` is invariant with respect to `'a`.
        arena: &amp;'a TypedArena&lt;Node&lt;'a&gt;&gt;,
        ...
    }
    fn new_ctxt&lt;'a&gt;(arena: &amp;'a TypedArena&lt;Node&lt;'a&gt;&gt;) -&gt; Context&lt;'a&gt; { ... }
    fn use_ctxt&lt;'a&gt;(fcx: &amp;'a Context&lt;'a&gt;) { ... }
    
    let arena = TypedArena::new();
    let ctxt = new_ctxt(&amp;arena);
    
    use_ctxt(&amp;ctxt);
    ```
    
    In these situations, if you try to introduce two bindings via two
    distinct `let` statements, each is (with this commit) assigned a
    distinct extent, and the region inference system cannot find a single
    region to assign to the lifetime `'a` that works for both of the
    bindings. So you get an error that `ctxt` does not live long enough;
    but moving its binding up above that of `arena` just shifts the error
    so now the compiler complains that `arena` does not live long enough.
    
    SO: What to do? The easiest fix in this case is to ensure that the two
    bindings *do* get assigned the same static extent, by stuffing both
    bindings into the same let statement, like so:
    
    ```rust
    let (arena, ctxt): (TypedArena, Context);
    arena = TypedArena::new();
    ctxt = new_ctxt(&amp;arena);
    
    use_ctxt(&amp;ctxt);
    ```
    
    Due to the new code rejections outlined above, this is a ...
    
    [breaking-change]

commit a6a6fadbb97268d2b3e47649d91053fbb4827266
Merge: a637365 5d836cd
Author:     bors &lt;bors@rust-lang.org&gt;
AuthorDate: Tue Jan 27 02:46:09 2015 +0000
Commit:     bors &lt;bors@rust-lang.org&gt;
CommitDate: Tue Jan 27 02:46:09 2015 +0000

    Auto merge of #21543 - alexcrichton:old-io, r=aturon
    
    In preparation for the I/O rejuvination of the standard library, this commit
    renames the current `io` module to `old_io` in order to make room for the new
    I/O modules. It is expected that the I/O RFCs will land incrementally over time
    instead of all at once, and this provides a fresh clean path for new modules to
    enter into as well as guaranteeing that all old infrastructure will remain in
    place for some time.
    
    As each `old_io` module is replaced it will be deprecated in-place for new
    structures in `std::{io, fs, net}` (as appropriate).
    
    This commit does *not* leave a reexport of `old_io as io` as the deprecation
    lint does not currently warn on this form of use. This is quite a large breaking
    change for all imports in existing code, but all functionality is retained
    precisely as-is and path statements simply need to be renamed from `io` to
    `old_io`.
    
    [breaking-change]

commit 5d836cdf8666ce0af6911a0c89dffea4da74b374
Author:     Alex Crichton &lt;alex@alexcrichton.com&gt;
AuthorDate: Fri Jan 23 10:46:14 2015 -0800
Commit:     Alex Crichton &lt;alex@alexcrichton.com&gt;
CommitDate: Mon Jan 26 16:01:58 2015 -0800

    std: Rename Writer::write to Writer::write_all
    
    In preparation for upcoming changes to the `Writer` trait (soon to be called
    `Write`) this commit renames the current `write` method to `write_all` to match
    the semantics of the upcoming `write_all` method. The `write` method will be
    repurposed to return a `usize` indicating how much data was written which
    differs from the current `write` semantics. In order to head off as much
    unintended breakage as possible, the method is being deprecated now in favor of
    a new name.
    
    [breaking-change]

commit f72b1645103e12b581f7022b893c37b5fe41aef7
Author:     Alex Crichton &lt;alex@alexcrichton.com&gt;
AuthorDate: Thu Jan 22 16:27:48 2015 -0800
Commit:     Alex Crichton &lt;alex@alexcrichton.com&gt;
CommitDate: Mon Jan 26 16:01:16 2015 -0800

    std: Rename io to old_io
    
    In preparation for the I/O rejuvination of the standard library, this commit
    renames the current `io` module to `old_io` in order to make room for the new
    I/O modules. It is expected that the I/O RFCs will land incrementally over time
    instead of all at once, and this provides a fresh clean path for new modules to
    enter into as well as guaranteeing that all old infrastructure will remain in
    place for some time.
    
    As each `old_io` module is replaced it will be deprecated in-place for new
    structures in `std::{io, fs, net}` (as appropriate).
    
    This commit does *not* leave a reexport of `old_io as io` as the deprecation
    lint does not currently warn on this form of use. This is quite a large breaking
    change for all imports in existing code, but all functionality is retained
    precisely as-is and path statements simply need to be renamed from `io` to
    `old_io`.
    
    [breaking-change]

commit 43046becce78147fa43808626bbb48569086b6a5
Merge: 70b13a7 0824652
Author:     bors &lt;bors@rust-lang.org&gt;
AuthorDate: Sun Jan 25 05:50:30 2015 +0000
Commit:     bors &lt;bors@rust-lang.org&gt;
CommitDate: Sun Jan 25 05:50:30 2015 +0000

    Auto merge of #21558 - alexcrichton:result-debug, r=aturon
    
    This commit relaxes the bound on `Result::unwrap` and `Result::unwrap_err` from
    the `Display` trait to the `Debug` trait for generating an error message about
    the unwrapping operation.
    
    This commit is a breaking change and any breakage should be mitigated by
    ensuring that `Debug` is implemented on the relevant type.
    
    [breaking-change]

commit e5c1f166a8282072089de2ad62a5b2427bd2bebf
Merge: 4be79d6 6c29708
Author:     bors &lt;bors@rust-lang.org&gt;
AuthorDate: Sat Jan 24 05:12:15 2015 +0000
Commit:     bors &lt;bors@rust-lang.org&gt;
CommitDate: Sat Jan 24 05:12:15 2015 +0000

    Auto merge of #21458 - alexcrichton:remove-some-code, r=brson
    
    The base64 support can be trivially removed (there are no in-tree users) and the regex support is a whopping 4k lines of code to maintain for a few non-critical uses in-tree. This commit migrates all current users in-tree away from regexes to custom matching code.
    
    The most critical application affected by this migration is that the testing framework no longer considers filter arguments as regexes, but rather just a substring matching. It is expected that more featureful testing frameworks can evolve outside of the in-tree libtest version over time which can properly depend on libregex from crates.io.
    
    [breaking-change]

commit 08246520c0fef902b169233e26e15cf58ef1cd8b
Author:     Alex Crichton &lt;alex@alexcrichton.com&gt;
AuthorDate: Fri Jan 23 10:38:50 2015 -0800
Commit:     Alex Crichton &lt;alex@alexcrichton.com&gt;
CommitDate: Fri Jan 23 14:11:34 2015 -0800

    std: Relax Result::unwrap() to Debug
    
    This commit relaxes the bound on `Result::unwrap` and `Result::unwrap_err` from
    the `Display` trait to the `Debug` trait for generating an error message about
    the unwrapping operation.
    
    This commit is a breaking change and any breakage should be mitigated by
    ensuring that `Debug` is implemented on the relevant type.
    
    [breaking-change]

commit 092ba6a8563b5c95f5aa53a705eaba6cc94e2da7
Author:     Aaron Turon &lt;aturon@mozilla.com&gt;
AuthorDate: Sat Jan 17 16:15:47 2015 -0800
Commit:     Aaron Turon &lt;aturon@mozilla.com&gt;
CommitDate: Wed Jan 21 07:45:45 2015 -0800

    Deprecate slicing methods in favor of notation
    
    This commit deprecates `slice`, `slice_from`, `slice_to` and their
    mutable variants in favor of slice notation.
    
    The `as_slice` methods are left intact, for now.
    
    [breaking-change]

commit fba0bf63a90379e8825012a817167774e14a627f
Author:     Aaron Turon &lt;aturon@mozilla.com&gt;
AuthorDate: Thu Jan 15 20:00:09 2015 -0800
Commit:     Aaron Turon &lt;aturon@mozilla.com&gt;
CommitDate: Wed Jan 21 07:45:45 2015 -0800

    Stabilize Index traits and most range notation
    
    This commit marks as `#[stable]`:
    
    * The `Index` and `IndexMut` traits. These are stabilized as taking the
      index itself *by reference*; after extensive discussion it was
      determined that this is a better match with our choices
      elsewhere (e.g. making comparison operators auto-reference), and that
      the use cases for by-value indices are better handled through
      `IndexSet`.
    
    * The `Range`, `RangeFrom` and `RangeTo` structs, introduced for range
      notation.
    
    * Various impls of `Index` and `IndexMut`.
    
    The `FullRange` struct is left unstable as we may wish to rename it to
    `RangeFull` in the future.
    
    This commit also *removes* the `Step` trait in favor of direct
    implementation of iterator traits on ranges for integers. The `Step`
    trait was not a terribly useful factoring internally, and it is likely
    that external integer types are best off implementing range iterators
    directly. It was removed to simplify the API surface. We can always
    reintroduce `Step` later if it turns out to be useful.
    
    Due to this removal, this is a:
    
    [breaking-change]

commit 3cb9fa26ef9905c00a29ea577fb55a12a91c8e7b
Author:     Alex Crichton &lt;alex@alexcrichton.com&gt;
AuthorDate: Tue Jan 20 15:45:07 2015 -0800
Commit:     Alex Crichton &lt;alex@alexcrichton.com&gt;
CommitDate: Tue Jan 20 22:36:13 2015 -0800

    std: Rename Show/String to Debug/Display
    
    This commit is an implementation of [RFC 565][rfc] which is a stabilization of
    the `std::fmt` module and the implementations of various formatting traits.
    Specifically, the following changes were performed:
    
    [rfc]: https://github.com/rust-lang/rfcs/blob/master/text/0565-show-string-guidelines.md
    
    * The `Show` trait is now deprecated, it was renamed to `Debug`
    * The `String` trait is now deprecated, it was renamed to `Display`
    * Many `Debug` and `Display` implementations were audited in accordance with the
      RFC and audited implementations now have the `#[stable]` attribute
      * Integers and floats no longer print a suffix
      * Smart pointers no longer print details that they are a smart pointer
      * Paths with `Debug` are now quoted and escape characters
    * The `unwrap` methods on `Result` now require `Display` instead of `Debug`
    * The `Error` trait no longer has a `detail` method and now requires that
      `Display` must be implemented. With the loss of `String`, this has moved into
      libcore.
    * `impl&lt;E: Error&gt; FromError&lt;E&gt; for Box&lt;Error&gt;` now exists
    * `derive(Show)` has been renamed to `derive(Debug)`. This is not currently
      warned about due to warnings being emitted on stage1+
    
    While backwards compatibility is attempted to be maintained with a blanket
    implementation of `Display` for the old `String` trait (and the same for
    `Show`/`Debug`) this is still a breaking change due to primitives no longer
    implementing `String` as well as modifications such as `unwrap` and the `Error`
    trait. Most code is fairly straightforward to update with a rename or tweaks of
    method calls.
    
    [breaking-change]
    Closes #21436

commit 8d05f6c74c34c1d72fd91be3057fe7d4581aca3a
Merge: 3d6568f b4090aa
Author:     Barosl LEE &lt;github@barosl.com&gt;
AuthorDate: Wed Jan 21 02:16:51 2015 +0900
Commit:     Barosl LEE &lt;github@barosl.com&gt;
CommitDate: Wed Jan 21 02:16:51 2015 +0900

    Rollup merge of #21388 - aochagavia:collections, r=Gankro
    
    **Breaking change**: `VecMap::into_iter` now consumes the `VecMap`. To fix it you should pass the VecMap by value instead of by reference.
    
    [breaking-change]
    
    r? @Gankro

commit e63443d536a0e6157dce0cfb39dfcd2d614fb357
Merge: 409c997 97a2b26
Author:     Barosl LEE &lt;github@barosl.com&gt;
AuthorDate: Wed Jan 21 02:16:47 2015 +0900
Commit:     Barosl LEE &lt;github@barosl.com&gt;
CommitDate: Wed Jan 21 02:16:47 2015 +0900

    Rollup merge of #21312 - michaelsproul:remove-error-send-bound, r=aturon
    
    As discussed with @aturon, this PR removes the `Send` bound from `std::error::Error`, allowing us to implement `Error` for error types containing non-`Send` types. Current examples include `PoisonError` and `TryLockError` from `std::sync` which contain a Guard that we don't want sent between tasks.
    
    [breaking-change]

commit cda3490f8fb099a1ddd1f253a75c29110042dc01
Merge: 43f2c19 3121c04
Author:     bors &lt;bors@rust-lang.org&gt;
AuthorDate: Mon Jan 19 15:44:41 2015 +0000
Commit:     bors &lt;bors@rust-lang.org&gt;
CommitDate: Mon Jan 19 15:44:41 2015 +0000

    Auto merge of #21269 - alexcrichton:issue-6936, r=pnkfelix
    
    This commit modifies resolve to prevent conflicts with typedef names in the same
    method that conflits are prevented with enum names. This is a breaking change
    due to the differing semantics in resolve, and any errors generated on behalf of
    this change require that a conflicting typedef, module, or structure to be
    renamed so they do not conflict.
    
    [breaking-change]
    Closes #6936

commit 7b87900d72cf53037119e3bac1506a9786ca508a
Merge: 135cac8 d053ccb
Author:     bors &lt;bors@rust-lang.org&gt;
AuthorDate: Mon Jan 19 10:19:23 2015 +0000
Commit:     bors &lt;bors@rust-lang.org&gt;
CommitDate: Mon Jan 19 10:19:23 2015 +0000

    Auto merge of #20874 - klutzy:windows-dynamic-lib, r=alexcrichton
    
    This is a [breaking-change] since `std::dynamic_lib::dl` is now
    private.
    
    When `LoadLibraryW()` fails, original code called `errno()` to get error
    code.  However, there was local allocation of `Vec` before
    `LoadLibraryW()`, and it drops before `errno()`, and the drop
    (deallocation) changed `errno`! Therefore `dynamic_lib::open()` thought
    it always succeeded.
    This commit fixes the issue.
    
    This commit also sets Windows error mode during `LoadLibrary()` to
    prevent "dll load failed" dialog.

commit 2366dee8e9cb41d963900c8d5128f810a87fc6bb
Author:     Adolfo Ochagavía &lt;aochagavia92@gmail.com&gt;
AuthorDate: Mon Jan 19 10:48:01 2015 +0100
Commit:     Adolfo Ochagavía &lt;aochagavia92@gmail.com&gt;
CommitDate: Mon Jan 19 10:48:01 2015 +0100

    Make VecMap::into_iter consume the VecMap
    
    This is a breaking change. To fix it you should pass the VecMap by value
    instead of by reference.
    
    [breaking-change]

commit 2549cbec9dfe02cdc93a3cf3bfe9638e5a4c2948
Author:     Alex Crichton &lt;alex@alexcrichton.com&gt;
AuthorDate: Fri Jan 16 14:25:45 2015 -0800
Commit:     Alex Crichton &lt;alex@alexcrichton.com&gt;
CommitDate: Sun Jan 18 18:25:55 2015 -0800

    rustc_resolve: Do not allow mods to shadow types
    
    This commit modifies resolve to prevent conflicts with typedef names in the same
    method that conflits are prevented with enum names. This is a breaking change
    due to the differing semantics in resolve, and any errors generated on behalf of
    this change require that a conflicting typedef, module, or structure to be
    renamed so they do not conflict.
    
    [breaking-change]
    Closes #6936

commit d053ccb45fafc12a52629f209122c1ce9bbfabed
Author:     klutzy &lt;klutzytheklutzy@gmail.com&gt;
AuthorDate: Sat Jan 10 22:53:22 2015 +0900
Commit:     klutzy &lt;klutzytheklutzy@gmail.com&gt;
CommitDate: Mon Jan 19 00:12:45 2015 +0900

    std::dynamic_lib: Fix Windows error handling
    
    This is a [breaking-change] since `std::dynamic_lib::dl` is now
    private.
    
    When `LoadLibraryW()` fails, original code called `errno()` to get error
    code.  However, there was local allocation of `Vec` before
    `LoadLibraryW()`, and it drops before `errno()`, and the drop
    (deallocation) changed `errno`! Therefore `dynamic_lib::open()` thought
    it always succeeded.
    This commit fixes the issue.
    
    This commit also sets Windows error mode during `LoadLibrary()` to
    prevent "dll load failed" dialog.

commit 34fa70fba5425cbbb96bce783e9fd5c23dd9b471
Author:     Alex Crichton &lt;alex@alexcrichton.com&gt;
AuthorDate: Fri Jan 16 12:20:03 2015 -0800
Commit:     Steve Klabnik &lt;steve@steveklabnik.com&gt;
CommitDate: Sat Jan 17 10:51:07 2015 -0500

    std: Move the bitflags! macro to a gated crate
    
    In accordance with [collections reform part 2][rfc] this macro has been moved to
    an external [bitflags crate][crate] which is [available though
    crates.io][cratesio]. Inside the standard distribution the macro has been moved
    to a crate called `rustc_bitflags` for current users to continue using.
    
    [rfc]: https://github.com/rust-lang/rfcs/blob/master/text/0509-collections-reform-part-2.md
    [crate]: https://github.com/rust-lang/bitflags
    [cratesio]: http://crates.io/crates/bitflags
    
    The major user of `bitflags!` in terms of a public-facing possibly-stable API
    today is the `FilePermissions` structure inside of `std::io`. This user,
    however, will likely no longer use `bitflags!` after I/O reform has landed. To
    prevent breaking APIs today, this structure remains as-is.
    
    Current users of the `bitflags!` macro should add this to their `Cargo.toml`:
    
        bitflags = "0.1"
    
    and this to their crate root:
    
        #[macro_use] extern crate bitflags;
    
    Due to the removal of a public macro, this is a:
    
    [breaking-change]

commit 873ae555e9a42fd12b0a92134112ec000d749ab2
Author:     Simonas Kazlauskas &lt;git@kazlauskas.me&gt;
AuthorDate: Thu Jan 15 22:56:53 2015 +0200
Commit:     Steve Klabnik &lt;steve@steveklabnik.com&gt;
CommitDate: Sat Jan 17 10:49:49 2015 -0500

    Revert stability for Bitv and BitvSet
    
    The collections were promoted to stable by mistake and do not match RFC 509.
    This reverts the stability back to unstable.
    
    [breaking-change] since previously stable API became unstable.
    
    Fixes #21193

commit cbeb77ec7a42b988703fa0b0c857f26d464fdc2f
Author:     Alex Crichton &lt;alex@alexcrichton.com&gt;
AuthorDate: Tue Jan 6 08:46:07 2015 -0800
Commit:     Alex Crichton &lt;alex@alexcrichton.com&gt;
CommitDate: Fri Jan 16 08:48:16 2015 -0800

    rustc: Fix a leak in dependency= paths
    
    With the addition of separate search paths to the compiler, it was intended that
    applications such as Cargo could require a `--extern` flag per `extern crate`
    directive in the source. The system can currently be subverted, however, due to
    the `existing_match()` logic in the crate loader.
    
    When loading crates we first attempt to match an `extern crate` directive
    against all previously loaded crates to avoid reading metadata twice. This "hit
    the cache if possible" step was erroneously leaking crates across the search
    path boundaries, however. For example:
    
        extern crate b;
        extern crate a;
    
    If `b` depends on `a`, then it will load crate `a` when the `extern crate b`
    directive is being processed. When the compiler reaches `extern crate a` it will
    use the previously loaded version no matter what. If the compiler was not
    invoked with `-L crate=path/to/a`, it will still succeed.
    
    This behavior is allowing `extern crate` declarations in Cargo without a
    corresponding declaration in the manifest of a dependency, which is considered
    a bug.
    
    This commit fixes this problem by keeping track of the origin search path for a
    crate. Crates loaded from the dependency search path are not candidates for
    crates which are loaded from the crate search path.
    
    As a result of this fix, this is a likely a breaking change for a number of
    Cargo packages. If the compiler starts informing that a crate can no longer be
    found, it likely means that the dependency was forgotten in your Cargo.toml.
    
    [breaking-change]

commit ee2bfae011e368e224d6d4f4c9fad13606ee99da
Merge: f3d71be cb85223
Author:     bors &lt;bors@rust-lang.org&gt;
AuthorDate: Fri Jan 16 13:10:59 2015 +0000
Commit:     bors &lt;bors@rust-lang.org&gt;
CommitDate: Fri Jan 16 13:10:59 2015 +0000

    auto merge of #20972 : FlaPer87/rust/oibit-send-and-friends, r=nikomatsakis
    
    This PR adds rules for negative implementations. It follows pretty much what the [RFC](https://github.com/rust-lang/rfcs/blob/master/text/0019-opt-in-builtin-traits.md) says with 1 main difference:
    
    Instead of positive implementations override negative implementations, this have been implemented in a way that a negative implementation of `Trait` for `T` will overlap with a positive implementation, causing a coherence error.
    
    @nikomatsakis r?
    
    cc #13231
    
    [breaking-change]

commit 0419b4ab1225595b022d8ed4e425526b4d850995
Merge: 7be39b0 de7b3cf
Author:     Alex Crichton &lt;alex@alexcrichton.com&gt;
AuthorDate: Thu Jan 15 14:12:00 2015 -0800
Commit:     Alex Crichton &lt;alex@alexcrichton.com&gt;
CommitDate: Thu Jan 15 14:12:00 2015 -0800

    rollup merge of #21167: FlaPer87/coherence-impls
    
    Fixes #21080
    
    r? @nikomatsakis
    
    [breaking-change]

commit 3d0d9bb6fbdf6ead9396f0874cf38f3ef7c9be5c
Merge: 3a44a19 8b6cda3
Author:     bors &lt;bors@rust-lang.org&gt;
AuthorDate: Mon Jan 12 22:56:20 2015 +0000
Commit:     bors &lt;bors@rust-lang.org&gt;
CommitDate: Mon Jan 12 22:56:20 2015 +0000

    auto merge of #20896 : sfackler/rust/atomic-rename, r=alexcrichton
    
    Change any use of AtomicInt to AtomicIsize and AtomicUint to AtomicUsize
    
    Closes #20893
    
    [breaking-change]

commit 8b6cda3ce681d4d95c3097d12ed754975b4a07f6
Author:     Steven Fackler &lt;sfackler@gmail.com&gt;
AuthorDate: Sat Jan 10 13:42:48 2015 -0800
Commit:     Steven Fackler &lt;sfackler@gmail.com&gt;
CommitDate: Sun Jan 11 11:47:44 2015 -0800

    Rename AtomicInt and AtomicUint
    
    Change any use of AtomicInt to AtomicIsize and AtomicUint to AtomicUsize
    
    Closes #20893
    
    [breaking-change]

commit 2e4cef4e78253beb4c08ed35416fad076d978344
Merge: 2127e0d b4fae2f
Author:     bors &lt;bors@rust-lang.org&gt;
AuthorDate: Sun Jan 11 16:45:48 2015 +0000
Commit:     bors &lt;bors@rust-lang.org&gt;
CommitDate: Sun Jan 11 16:45:48 2015 +0000

    auto merge of #20910 : sfackler/rust/show-impls, r=alexcrichton
    
    A derived implementation would not be appropriate for the Buffered types
    since the buffer is both huge (64k by default) and full of uninitialized
    memory. Instead of printing the whole thing, we display how full it is.
    
    I also altered `MultiWriter` to make it generic over Writers instead of
    taking `Box&lt;Writer&gt;` trait objects. `Box&lt;Writer&gt;` implements `Writer` so
    existing use cases should continue to work, and this enables a more
    useful Show implementation in applicable cases.
    
    The change to `MultiWriter` may break code that uses it, but any fixes
    should be easy.
    
    [breaking-change]
    
    r? @alexcrichton

commit b4fae2fba99e713a6d6a8a59caaf1cfba847b50e
Author:     Steven Fackler &lt;sfackler@gmail.com&gt;
AuthorDate: Sat Jan 10 17:32:54 2015 -0800
Commit:     Steven Fackler &lt;sfackler@gmail.com&gt;
CommitDate: Sat Jan 10 17:32:54 2015 -0800

    Implement Show for types in std::io::{buffered,util}
    
    A derived implementation would not be appropriate for the Buffered types
    since the buffer is both huge (64k by default) and full of uninitialized
    memory. Instead of printing the whole thing, we display how full it is.
    
    I also altered MultiWriter to make it generic over Writers instead of
    taking Box&lt;Writer&gt; trait objects. Box&lt;Writer&gt; implements Writer so
    existing use cases should continue to work, and this enables a more
    useful Show implementation in applicable cases.
    
    The change to MultiWriter may break code that uses it, but any fixes
    should be easy.
    
    [breaking-change]

commit daee409b60cdb17040122343e0a184049c62180b
Merge: e40f62d 0d0869a
Author:     Alex Crichton &lt;alex@alexcrichton.com&gt;
AuthorDate: Thu Jan 8 09:22:06 2015 -0800
Commit:     Alex Crichton &lt;alex@alexcrichton.com&gt;
CommitDate: Thu Jan 8 09:22:06 2015 -0800

    rollup merge of #20740: FlaPer87/remove-opt-out-copy
    
    [breaking-change] code using this feature will break.

commit 92cd8ea96ad2a1da51863b7f089baec41ed10ce9
Author:     Huon Wilson &lt;dbau.pp+github@gmail.com&gt;
AuthorDate: Thu Jan 8 11:39:45 2015 +1100
Commit:     Huon Wilson &lt;dbau.pp+github@gmail.com&gt;
CommitDate: Thu Jan 8 12:27:28 2015 +1100

    Prohibit type parameter shadowing with a clunky hammer.
    
    This is a [breaking-change].
    
    Change
    
        impl&lt;T&gt; Foo&lt;T&gt; {
            fn bar&lt;T&gt;(...
    
    to (for example)
    
        impl&lt;T&gt; Foo&lt;T&gt; {
            fn bar&lt;U&gt;(...
    
    Per RFC 459.
    
    Closes #19390.

commit 6301c7878ebcaa45e77315db2a9afd8b5d1425c8
Merge: f3b67af dd3e89a
Author:     Alex Crichton &lt;alex@alexcrichton.com&gt;
AuthorDate: Wed Jan 7 17:17:23 2015 -0800
Commit:     Alex Crichton &lt;alex@alexcrichton.com&gt;
CommitDate: Wed Jan 7 17:17:23 2015 -0800

    rollup merge of #20680: nick29581/target-word
    
    Closes #20421
    
    [breaking-change]
    
    r? @brson

commit 8bf3ee7c5c44fa5aa0a1003e8fe61a0af1527927
Merge: b1c23f6 511f0b8
Author:     Alex Crichton &lt;alex@alexcrichton.com&gt;
AuthorDate: Wed Jan 7 17:17:19 2015 -0800
Commit:     Alex Crichton &lt;alex@alexcrichton.com&gt;
CommitDate: Wed Jan 7 17:17:19 2015 -0800

    rollup merge of #20654: alexcrichton/stabilize-hash
    
    This commit aims to prepare the `std::hash` module for alpha by formalizing its
    current interface whileholding off on adding `#[stable]` to the new APIs.  The
    current usage with the `HashMap` and `HashSet` types is also reconciled by
    separating out composable parts of the design. The primary goal of this slight
    redesign is to separate the concepts of a hasher's state from a hashing
    algorithm itself.
    
    The primary change of this commit is to separate the `Hasher` trait into a
    `Hasher` and a `HashState` trait. Conceptually the old `Hasher` trait was
    actually just a factory for various states, but hashing had very little control
    over how these states were used. Additionally the old `Hasher` trait was
    actually fairly unrelated to hashing.
    
    This commit redesigns the existing `Hasher` trait to match what the notion of a
    `Hasher` normally implies with the following definition:
    
        trait Hasher {
            type Output;
            fn reset(&amp;mut self);
            fn finish(&amp;self) -&gt; Output;
        }
    
    This `Hasher` trait emphasizes that hashing algorithms may produce outputs other
    than a `u64`, so the output type is made generic. Other than that, however, very
    little is assumed about a particular hasher. It is left up to implementors to
    provide specific methods or trait implementations to feed data into a hasher.
    
    The corresponding `Hash` trait becomes:
    
        trait Hash&lt;H: Hasher&gt; {
            fn hash(&amp;self, &amp;mut H);
        }
    
    The old default of `SipState` was removed from this trait as it's not something
    that we're willing to stabilize until the end of time, but the type parameter is
    always required to implement `Hasher`. Note that the type parameter `H` remains
    on the trait to enable multidispatch for specialization of hashing for
    particular hashers.
    
    Note that `Writer` is not mentioned in either of `Hash` or `Hasher`, it is
    simply used as part `derive` and the implementations for all primitive types.
    
    With these definitions, the old `Hasher` trait is realized as a new `HashState`
    trait in the `collections::hash_state` module as an unstable addition for
    now. The current definition looks like:
    
        trait HashState {
            type Hasher: Hasher;
            fn hasher(&amp;self) -&gt; Hasher;
        }
    
    The purpose of this trait is to emphasize that the one piece of functionality
    for implementors is that new instances of `Hasher` can be created.  This
    conceptually represents the two keys from which more instances of a
    `SipHasher` can be created, and a `HashState` is what's stored in a
    `HashMap`, not a `Hasher`.
    
    Implementors of custom hash algorithms should implement the `Hasher` trait, and
    only hash algorithms intended for use in hash maps need to implement or worry
    about the `HashState` trait.
    
    The entire module and `HashState` infrastructure remains `#[unstable]` due to it
    being recently redesigned, but some other stability decision made for the
    `std::hash` module are:
    
    * The `Writer` trait remains `#[experimental]` as it's intended to be replaced
      with an `io::Writer` (more details soon).
    * The top-level `hash` function is `#[unstable]` as it is intended to be generic
      over the hashing algorithm instead of hardwired to `SipHasher`
    * The inner `sip` module is now private as its one export, `SipHasher` is
      reexported in the `hash` module.
    
    And finally, a few changes were made to the default parameters on `HashMap`.
    
    * The `RandomSipHasher` default type parameter was renamed to `RandomState`.
      This renaming emphasizes that it is not a hasher, but rather just state to
      generate hashers. It also moves away from the name "sip" as it may not always
      be implemented as `SipHasher`. This type lives in the
      `std::collections::hash_map` module as `#[unstable]`
    
    * The associated `Hasher` type of `RandomState` is creatively called...
      `Hasher`! This concrete structure lives next to `RandomState` as an
      implemenation of the "default hashing algorithm" used for a `HashMap`. Under
      the hood this is currently implemented as `SipHasher`, but it draws an
      explicit interface for now and allows us to modify the implementation over
      time if necessary.
    
    There are many breaking changes outlined above, and as a result this commit is
    a:
    
    [breaking-change]

commit 4a31aaddb364f5ab8280242a1016bdd3d10dcaed
Author:     Felix S. Klock II &lt;pnkfelix@pnkfx.org&gt;
AuthorDate: Wed Jan 7 15:15:34 2015 +0100
Commit:     Felix S. Klock II &lt;pnkfelix@pnkfx.org&gt;
CommitDate: Thu Jan 8 00:41:43 2015 +0100

    Added `box_syntax` feature gate; added to std and rustc crates for bootstrap.
    
    To avoid using the feauture, change uses of `box &lt;expr&gt;` to
    `Box::new(&lt;expr&gt;)` alternative, as noted by the feature gate message.
    
    (Note that box patterns have no analogous trivial replacement, at
    least not in general; you need to revise the code to do a partial
    match, deref, and then the rest of the match.)
    
    [breaking-change]

commit 63a9bd5e0adc03652e10506055564077aa00eeaa
Author:     Nick Cameron &lt;ncameron@mozilla.com&gt;
AuthorDate: Thu Jan 8 08:30:33 2015 +1300
Commit:     Nick Cameron &lt;ncameron@mozilla.com&gt;
CommitDate: Thu Jan 8 11:25:00 2015 +1300

    Fix precedence for ranges.
    
    Technically this is a
    
    [breaking-change]
    
    but it probably shouldn't affect your code.
    
    Closes #20256

commit 209c701bf9e95542aec69455bc12c7ca295109c4
Author:     Alex Crichton &lt;alex@alexcrichton.com&gt;
AuthorDate: Tue Jan 6 11:07:09 2015 -0800
Commit:     Alex Crichton &lt;alex@alexcrichton.com&gt;
CommitDate: Wed Jan 7 12:56:16 2015 -0800

    std: Stablize the macros module
    
    This commit performs a pass over the `std::macros` module, applying stability
    attributes where necessary. In particular, this audits macros for patterns such
    as:
    
    * Standard use of forward-to-format-args via `$($arg:tt)*` (or `+`)
    * Prevent macro-defined identifiers from leaking into expression arguments as
      hygiene is not perfectly implemented.
    * Wherever possible, `$crate` is used now.
    
    Specifically, the following actions were taken:
    
    * The `std::macros` module itself is no longer public.
    * The `panic!` macro is stable
    * The `assert!` macro is stable
    * The `assert_eq!` macro is stable
    * The `debug_assert!` macro is stable
    * The `debug_assert_eq!` macro is stable
    * The `unreachable!` macro is stable after removing the extra forms to bring the
      definition in line with the `unimplemented!` macro.
    * The `try!` macro is stable
    * The `vec!` macro is stable
    
    [breaking-change]

commit 511f0b8a3de5a166fc96aba5170782c9abf92101
Author:     Alex Crichton &lt;alex@alexcrichton.com&gt;
AuthorDate: Tue Dec 9 12:37:23 2014 -0800
Commit:     Alex Crichton &lt;alex@alexcrichton.com&gt;
CommitDate: Wed Jan 7 12:18:08 2015 -0800

    std: Stabilize the std::hash module
    
    This commit aims to prepare the `std::hash` module for alpha by formalizing its
    current interface whileholding off on adding `#[stable]` to the new APIs.  The
    current usage with the `HashMap` and `HashSet` types is also reconciled by
    separating out composable parts of the design. The primary goal of this slight
    redesign is to separate the concepts of a hasher's state from a hashing
    algorithm itself.
    
    The primary change of this commit is to separate the `Hasher` trait into a
    `Hasher` and a `HashState` trait. Conceptually the old `Hasher` trait was
    actually just a factory for various states, but hashing had very little control
    over how these states were used. Additionally the old `Hasher` trait was
    actually fairly unrelated to hashing.
    
    This commit redesigns the existing `Hasher` trait to match what the notion of a
    `Hasher` normally implies with the following definition:
    
        trait Hasher {
            type Output;
            fn reset(&amp;mut self);
            fn finish(&amp;self) -&gt; Output;
        }
    
    This `Hasher` trait emphasizes that hashing algorithms may produce outputs other
    than a `u64`, so the output type is made generic. Other than that, however, very
    little is assumed about a particular hasher. It is left up to implementors to
    provide specific methods or trait implementations to feed data into a hasher.
    
    The corresponding `Hash` trait becomes:
    
        trait Hash&lt;H: Hasher&gt; {
            fn hash(&amp;self, &amp;mut H);
        }
    
    The old default of `SipState` was removed from this trait as it's not something
    that we're willing to stabilize until the end of time, but the type parameter is
    always required to implement `Hasher`. Note that the type parameter `H` remains
    on the trait to enable multidispatch for specialization of hashing for
    particular hashers.
    
    Note that `Writer` is not mentioned in either of `Hash` or `Hasher`, it is
    simply used as part `derive` and the implementations for all primitive types.
    
    With these definitions, the old `Hasher` trait is realized as a new `HashState`
    trait in the `collections::hash_state` module as an unstable addition for
    now. The current definition looks like:
    
        trait HashState {
            type Hasher: Hasher;
            fn hasher(&amp;self) -&gt; Hasher;
        }
    
    The purpose of this trait is to emphasize that the one piece of functionality
    for implementors is that new instances of `Hasher` can be created.  This
    conceptually represents the two keys from which more instances of a
    `SipHasher` can be created, and a `HashState` is what's stored in a
    `HashMap`, not a `Hasher`.
    
    Implementors of custom hash algorithms should implement the `Hasher` trait, and
    only hash algorithms intended for use in hash maps need to implement or worry
    about the `HashState` trait.
    
    The entire module and `HashState` infrastructure remains `#[unstable]` due to it
    being recently redesigned, but some other stability decision made for the
    `std::hash` module are:
    
    * The `Writer` trait remains `#[experimental]` as it's intended to be replaced
      with an `io::Writer` (more details soon).
    * The top-level `hash` function is `#[unstable]` as it is intended to be generic
      over the hashing algorithm instead of hardwired to `SipHasher`
    * The inner `sip` module is now private as its one export, `SipHasher` is
      reexported in the `hash` module.
    
    And finally, a few changes were made to the default parameters on `HashMap`.
    
    * The `RandomSipHasher` default type parameter was renamed to `RandomState`.
      This renaming emphasizes that it is not a hasher, but rather just state to
      generate hashers. It also moves away from the name "sip" as it may not always
      be implemented as `SipHasher`. This type lives in the
      `std::collections::hash_map` module as `#[unstable]`
    
    * The associated `Hasher` type of `RandomState` is creatively called...
      `Hasher`! This concrete structure lives next to `RandomState` as an
      implemenation of the "default hashing algorithm" used for a `HashMap`. Under
      the hood this is currently implemented as `SipHasher`, but it draws an
      explicit interface for now and allows us to modify the implementation over
      time if necessary.
    
    There are many breaking changes outlined above, and as a result this commit is
    a:
    
    [breaking-change]

commit dd3e89aaf25c667fa8207f8800c4b60d70d76c1b
Author:     Nick Cameron &lt;ncameron@mozilla.com&gt;
AuthorDate: Wed Jan 7 17:26:55 2015 +1300
Commit:     Nick Cameron &lt;ncameron@mozilla.com&gt;
CommitDate: Thu Jan 8 09:07:55 2015 +1300

    Rename `target_word_size` to `target_pointer_width`
    
    Closes #20421
    
    [breaking-change]

commit 7deb9abd1b45f3e56ca6b13432866ae89886f21f
Author:     Aaron Turon &lt;aturon@mozilla.com&gt;
AuthorDate: Wed Jan 7 10:39:37 2015 -0800
Commit:     Aaron Turon &lt;aturon@mozilla.com&gt;
CommitDate: Wed Jan 7 11:40:11 2015 -0800

    Add isize, usize modules, deprecate int, uint modules
    
    This PR introduces `isize` and `usize` modules to `core` and `std`, and
    deprecates the existing `int` and `uint` modules. The rustdoc primitive
    type links now point to these new modules.
    
    Due to deprecation this is a:
    
    [breaking-change]

commit 36f5d122b80682de473aeda2e20f14b6ceb86d74
Merge: 0631b46 caca9b2
Author:     Alex Crichton &lt;alex@alexcrichton.com&gt;
AuthorDate: Tue Jan 6 15:38:38 2015 -0800
Commit:     Alex Crichton &lt;alex@alexcrichton.com&gt;
CommitDate: Tue Jan 6 15:38:38 2015 -0800

    rollup merge of #20615: aturon/stab-2-thread
    
    This commit takes a first pass at stabilizing `std::thread`:
    
    * It removes the `detach` method in favor of two constructors -- `spawn`
      for detached threads, `scoped` for "scoped" (i.e., must-join)
      threads. This addresses some of the surprise/frustrating debug
      sessions with the previous API, in which `spawn` produced a guard that
      on destruction joined the thread (unless `detach` was called).
    
      The reason to have the division in part is that `Send` will soon not
      imply `'static`, which means that `scoped` thread creation can take a
      closure over *shared stack data* of the parent thread. On the other
      hand, this means that the parent must not pop the relevant stack
      frames while the child thread is running. The `JoinGuard` is used to
      prevent this from happening by joining on drop (if you have not
      already explicitly `join`ed.) The APIs around `scoped` are
      future-proofed for the `Send` changes by taking an additional lifetime
      parameter. With the current definition of `Send`, this is forced to be
      `'static`, but when `Send` changes these APIs will gain their full
      flexibility immediately.
    
      Threads that are `spawn`ed, on the other hand, are detached from the
      start and do not yield an RAII guard.
    
      The hope is that, by making `scoped` an explicit opt-in with a very
      suggestive name, it will be drastically less likely to be caught by a
      surprising deadlock due to an implicit join at the end of a scope.
    
    * The module itself is marked stable.
    
    * Existing methods other than `spawn` and `scoped` are marked stable.
    
    The migration path is:
    
    ```rust
    Thread::spawn(f).detached()
    ```
    
    becomes
    
    ```rust
    Thread::spawn(f)
    ```
    
    while
    
    ```rust
    let res = Thread::spawn(f);
    res.join()
    ```
    
    becomes
    
    ```rust
    let res = Thread::scoped(f);
    res.join()
    ```
    
    [breaking-change]

commit 44440e5c18a1dbcc9685866ffffe00c508929079
Author:     Sean McArthur &lt;sean.monstar@gmail.com&gt;
AuthorDate: Sat Dec 20 00:09:35 2014 -0800
Commit:     Sean McArthur &lt;sean.monstar@gmail.com&gt;
CommitDate: Tue Jan 6 14:49:42 2015 -0800

    core: split into fmt::Show and fmt::String
    
    fmt::Show is for debugging, and can and should be implemented for
    all public types. This trait is used with `{:?}` syntax. There still
    exists #[derive(Show)].
    
    fmt::String is for types that faithfully be represented as a String.
    Because of this, there is no way to derive fmt::String, all
    implementations must be purposeful. It is used by the default format
    syntax, `{}`.
    
    This will break most instances of `{}`, since that now requires the type
    to impl fmt::String. In most cases, replacing `{}` with `{:?}` is the
    correct fix. Types that were being printed specifically for users should
    receive a fmt::String implementation to fix this.
    
    Part of #20013
    
    [breaking-change]

commit 2375a79152b8a6554c3e97a3f127fedd75f7495f
Author:     Niko Matsakis &lt;niko@alum.mit.edu&gt;
AuthorDate: Mon Jan 5 06:17:42 2015 -0500
Commit:     Niko Matsakis &lt;niko@alum.mit.edu&gt;
CommitDate: Tue Jan 6 17:17:48 2015 -0500

    Implement impl reachability rules. This is a [breaking-change]. Type
    parameters on impls must now also appear in the trait ref, self type,
    or some associated type declared on the impl. This ensures that they
    are constrianed in some way and that the semantics of the trait system
    are well-defined (always a good thing).
    
    There are three major ways to fix this error:
    
    1. Convert the trait to use associated types; most often the type
       parameters are not constrained because they are in fact outputs of
       the impl.
    
    2. Move the type parameters to methods.
    
    3. Add an additional type parameter to the self type or trait so that
       the unused parameter can appear there.
    
    In some cases, it is not possible to fix the impl because the trait
    definition needs to be changed first (and that may be out of your
    control). In that case, for the time being, you can opt out of these
    rules by using `#[old_impl_check]` on the impl and adding a
    `#![feature(old_impl_check)]` to your crate declaration.

commit 503709708c72401dbe091ed5c7e0494efabe0669
Author:     Nick Cameron &lt;ncameron@mozilla.com&gt;
AuthorDate: Tue Jan 6 14:03:46 2015 +1300
Commit:     Nick Cameron &lt;ncameron@mozilla.com&gt;
CommitDate: Wed Jan 7 09:45:28 2015 +1300

    Change `std::kinds` to `std::markers`; flatten `std::kinds::marker`
    
    [breaking-change]

commit f67b81e8d4dc198ad10ad50a7624e43cc1e25802
Author:     Aaron Turon &lt;aturon@mozilla.com&gt;
AuthorDate: Mon Jan 5 15:45:18 2015 -0800
Commit:     Aaron Turon &lt;aturon@mozilla.com&gt;
CommitDate: Tue Jan 6 09:04:48 2015 -0800

    Stabilize std::thread
    
    This commit takes a first pass at stabilizing `std::thread`:
    
    * It removes the `detach` method in favor of two constructors -- `spawn`
      for detached threads, `scoped` for "scoped" (i.e., must-join)
      threads. This addresses some of the surprise/frustrating debug
      sessions with the previous API, in which `spawn` produced a guard that
      on destruction joined the thread (unless `detach` was called).
    
      The reason to have the division in part is that `Send` will soon not
      imply `'static`, which means that `scoped` thread creation can take a
      closure over *shared stack data* of the parent thread. On the other
      hand, this means that the parent must not pop the relevant stack
      frames while the child thread is running. The `JoinGuard` is used to
      prevent this from happening by joining on drop (if you have not
      already explicitly `join`ed.) The APIs around `scoped` are
      future-proofed for the `Send` changes by taking an additional lifetime
      parameter. With the current definition of `Send`, this is forced to be
      `'static`, but when `Send` changes these APIs will gain their full
      flexibility immediately.
    
      Threads that are `spawn`ed, on the other hand, are detached from the
      start and do not yield an RAII guard.
    
      The hope is that, by making `scoped` an explicit opt-in with a very
      suggestive name, it will be drastically less likely to be caught by a
      surprising deadlock due to an implicit join at the end of a scope.
    
    * The module itself is marked stable.
    
    * Existing methods other than `spawn` and `scoped` are marked stable.
    
    The migration path is:
    
    ```rust
    Thread::spawn(f).detached()
    ```
    
    becomes
    
    ```rust
    Thread::spawn(f)
    ```
    
    while
    
    ```rust
    let res = Thread::spawn(f);
    res.join()
    ```
    
    becomes
    
    ```rust
    let res = Thread::scoped(f);
    res.join()
    ```
    
    [breaking-change]

commit 6680c9c5c797101fc5e0608cb2c3657517333148
Author:     Corey Richardson &lt;corey@octayn.net&gt;
AuthorDate: Fri Jan 2 16:41:24 2015 -0500
Commit:     Corey Richardson &lt;corey@octayn.net&gt;
CommitDate: Tue Jan 6 12:03:12 2015 -0500

    syntax: implement 'macro input future proofing'
    
    See RFC 550 (https://github.com/rust-lang/rfcs/pull/550) for the motivation
    and details.
    
    If this breaks your code, add one of the listed tokens after the relevant
    non-terminal in your matcher.
    
    [breaking-change]

commit ae4762761c995494726e8c9f41b05e99e6c7c81b
Author:     Huon Wilson &lt;dbau.pp+github@gmail.com&gt;
AuthorDate: Mon Jan 5 21:14:50 2015 +1100
Commit:     Huon Wilson &lt;dbau.pp+github@gmail.com&gt;
CommitDate: Tue Jan 6 23:21:27 2015 +1100

    Merge core::num::Float and std::num::FloatMath.
    
    `FloatMath` no longer exists and all functionality from both traits is
    available under `Float`. Change from
    
        use std::num::{Float, FloatMath};
    
    to
    
        use std::num::Float;
    
    [breaking-change]

commit cd4ed38404384bdb13500f1d2e782d32ece2b239
Author:     Huon Wilson &lt;dbau.pp+github@gmail.com&gt;
AuthorDate: Mon Jan 5 18:30:55 2015 +1100
Commit:     Huon Wilson &lt;dbau.pp+github@gmail.com&gt;
CommitDate: Tue Jan 6 23:21:01 2015 +1100

    Deprecate the constant-returning functions in Float.
    
    These are replaced by the equivalent constants in `std::f32` and
    `std::f64` respectively.
    
    [breaking-change]

commit 25d5a3a19423fee01787de87a56d185dd4e0a4e7
Merge: 743d926 ec7a50d
Author:     Alex Crichton &lt;alex@alexcrichton.com&gt;
AuthorDate: Mon Jan 5 18:37:22 2015 -0800
Commit:     Alex Crichton &lt;alex@alexcrichton.com&gt;
CommitDate: Mon Jan 5 18:37:22 2015 -0800

    rollup merge of #20507: alexcrichton/issue-20444
    
    This commit is an implementation of [RFC 494][rfc] which removes the entire
    `std::c_vec` module and redesigns the `std::c_str` module as `std::ffi`.
    
    [rfc]: https://github.com/rust-lang/rfcs/blob/master/text/0494-c_str-and-c_vec-stability.md
    
    The interface of the new `CString` is outlined in the linked RFC, the primary
    changes being:
    
    * The `ToCStr` trait is gone, meaning the `with_c_str` and `to_c_str` methods
      are now gone. These two methods are replaced with a `CString::from_slice`
      method.
    * The `CString` type is now just a wrapper around `Vec&lt;u8&gt;` with a static
      guarantee that there is a trailing nul byte with no internal nul bytes. This
      means that `CString` now implements `Deref&lt;Target = [c_char]&gt;`, which is where
      it gains most of its methods from. A few helper methods are added to acquire a
      slice of `u8` instead of `c_char`, as well as including a slice with the
      trailing nul byte if necessary.
    * All usage of non-owned `CString` values is now done via two functions inside
      of `std::ffi`, called `c_str_to_bytes` and `c_str_to_bytes_with_nul`. These
      functions are now the one method used to convert a `*const c_char` to a Rust
      slice of `u8`.
    
    Many more details, including newly deprecated methods, can be found linked in
    the RFC. This is a:
    
    [breaking-change]
    Closes #20444

commit 88b4c8e0d347921673e61bf1770ba0acd4c7d824
Merge: 059566b 5caf847
Author:     Alex Crichton &lt;alex@alexcrichton.com&gt;
AuthorDate: Mon Jan 5 18:36:34 2015 -0800
Commit:     Alex Crichton &lt;alex@alexcrichton.com&gt;
CommitDate: Mon Jan 5 18:36:34 2015 -0800

    rollup merge of #20465: nikomatsakis/assoc-types-regions-20303
    
    Treat associated types the same as type parameters when it comes to region bounding. Fixes #20303.
    
    Strictly speaking, this is a [breaking-change] (if you are using
    associated types). You are no longer free to wantonly violate the type
    system rules by closing associated types into objects without any form
    of region bound. Instead you should add region bounds like `T::X :
    'a`, just as you would with a normal type parameter.
    
    r? @aturon

commit 48f50e1e98691d74427e23e82694f528b3fb4d56
Author:     Nick Cameron &lt;ncameron@mozilla.com&gt;
AuthorDate: Tue Jan 6 09:44:33 2015 +1300
Commit:     Nick Cameron &lt;ncameron@mozilla.com&gt;
CommitDate: Tue Jan 6 14:20:47 2015 +1300

    Obsolete `Sized? T`
    
    [breaking-change]
    
    Use `T: ?Sized`

commit c7dd3c4d69aee1c4ad8cc220c194b176bba2ab62
Merge: f11f3e7 eb2506c
Author:     bors &lt;bors@rust-lang.org&gt;
AuthorDate: Mon Jan 5 23:51:00 2015 +0000
Commit:     bors &lt;bors@rust-lang.org&gt;
CommitDate: Mon Jan 5 23:51:00 2015 +0000

    auto merge of #20578 : japaric/rust/no-more-bc, r=nmatsakis
    
    This PR removes boxed closures from the language, the closure type syntax (`let f: |int| -&gt; bool = /* ... */`) has been obsoleted. Move all your uses of closures to the new unboxed closure system (i.e. `Fn*` traits).
    
    [breaking-change] patterns
    
    - `lef f = || {}`
    
    This binding used to type check to a boxed closure. Now that boxed closures are gone, you need to annotate the "kind" of the unboxed closure, i.e. you need pick one of these: `|&amp;:| {}`, `|&amp;mut:| {}` or `|:| {}`.
    
    In the (near) future we'll have closure "kind" inference, so the compiler will infer which `Fn*` trait to use based on how the closure is used. Once this inference machinery is in place, we'll be able to remove the kind annotation from most closures.
    
    - `type Alias&lt;'a&gt; = |int|:'a -&gt; bool`
    
    Use a trait object: `type Alias&lt;'a&gt; = Box&lt;FnMut(int) -&gt; bool + 'a&gt;`. Use the `Fn*` trait that makes sense for your use case.
    
    - `fn foo(&amp;self, f: |uint| -&gt; bool)`
    
    In this case you can use either a trait object or an unboxed closure:
    
    ``` rust
    fn foo(&amp;self, f: F) where F: FnMut(uint) -&gt; bool;
    // or
    fn foo(&amp;self, f: Box&lt;FnMut(uint) -&gt; bool&gt;);
    ```
    
    - `struct Struct&lt;'a&gt; { f: |uint|:'a -&gt; bool }`
    
    Again, you can use either a trait object or an unboxed closure:
    
    ``` rust
    struct Struct&lt;F&gt; where F: FnMut(uint) -&gt; bool { f: F }
    // or
    struct Struct&lt;'a&gt; { f: Box&lt;FnMut(uint) -&gt; bool + 'a&gt; }
    ```
    
    - Using `|x, y| f(x, y)` for closure "borrows"
    
    This comes up in recursive functions, consider the following (contrived) example:
    
    ``` rust
    fn foo(x: uint, f: |uint| -&gt; bool) -&gt; bool {
        //foo(x / 2, f) &amp;&amp; f(x)  // can't use this because `f` gets moved away in the `foo` call
        foo(x / 2, |x| f(x)) &amp;&amp; f(x)  // instead "borrow" `f` in the `foo` call
    }
    ```
    
    If you attempt to do the same with unboxed closures you'll hit ""error: reached the recursion limit during monomorphization" (see #19596):
    
    ``` rust
    fn foo&lt;F&gt;(x: uint, mut f: F) -&gt; bool where F: FnMut(uint) -&gt; bool {
        foo(x / 2, |x| f(x)) &amp;&amp; f(x)
        //~^ error: reached the recursion limit during monomorphization
    }
    ```
    
    Instead you *should* be able to write this:
    
    ``` rust
    fn foo&lt;F&gt;(x: uint, mut f: F) -&gt; bool where F: FnMut(uint) -&gt; bool {
        foo(x / 2, &amp;mut f) &amp;&amp; f(x)
        //~^ error: the trait `FnMut` is not implemented for the type `&amp;mut F`
    }
    ```
    
    But as you see above `&amp;mut F` doesn't implement the `FnMut` trait. `&amp;mut F` *should* implement the `FnMut` and the above code *should* work, but due to a bug (see #18835) it doesn't (for now).
    
    You can work around the issue by rewriting the function to take `&amp;mut F` instead of `F`:
    
    ``` rust
    fn foo&lt;F&gt;(x: uint, f: &amp;mut F) -&gt; bool where F: FnMut(uint) -&gt; bool {
        foo(x / 2, f) &amp;&amp; (*f)(x)
    }
    ```
    
    This finally works! However writing `foo(0, &amp;mut |x| x == 0)` is unergonomic. So you can use a private helper function to avoid this:
    
    ``` rust
    // public API function
    pub fn foo&lt;F&gt;(x: uint, mut f: F) -&gt; bool where F: FnMut(uint) -&gt; bool {
        foo_(x, &amp;mut f)
    }
    
    // private helper function
    fn foo_&lt;F&gt;(x: uint, f: &amp;mut F) -&gt; bool where F: FnMut(uint) -&gt; bool {
        foo_(x / 2, f) &amp;&amp; (*f)(x)
    }
    ```
    
    Closes #14798
    
    ---
    
    There is more cleanup to do: like renaming functions/types from `unboxed_closure` to just `closure`, removing more dead code, simplify functions which now have unused arguments, update the documentation, etc. But that can be done in another PR.
    
    r? @nikomatsakis @aturon (You probably want to focus on the deleted/modified tests.)
    cc @eddyb

commit 6e68fd09edc7ed37fd76f703247b5410cd338bfe
Author:     Niko Matsakis &lt;niko@alum.mit.edu&gt;
AuthorDate: Sun Jan 4 20:35:06 2015 -0500
Commit:     Niko Matsakis &lt;niko@alum.mit.edu&gt;
CommitDate: Mon Jan 5 17:17:26 2015 -0500

    Implement new orphan rule that requires that impls of remote traits meet the following two criteria:
    
    - the self type includes some local type; and,
    - type parameters in the self type must be constrained by a local type.
    
    A type parameter is called *constrained* if it appears in some type-parameter of a local type.
    
    Here are some examples that are accepted. In all of these examples, I
    assume that `Foo` is a trait defined in another crate. If `Foo` were
    defined in the local crate, then all the examples would be legal.
    
    - `impl Foo for LocalType`
    - `impl&lt;T&gt; Foo&lt;T&gt; for LocalType` -- T does not appear in Self, so it is OK
    - `impl&lt;T&gt; Foo&lt;T&gt; for LocalType&lt;T&gt;` -- T here is constrained by LocalType
    - `impl&lt;T&gt; Foo&lt;T&gt; for (LocalType&lt;T&gt;, T)` -- T here is constrained by LocalType
    
    Here are some illegal examples (again, these examples assume that
    `Foo` is not local to the current crate):
    
    - `impl Foo for int` -- the Self type is not local
    - `impl&lt;T&gt; Foo for T` -- T appears in Self unconstrained by a local type
    - `impl&lt;T&gt; Foo for (LocalType, T)` -- T appears in Self unconstrained by a local type
    
    This is a [breaking-change]. For the time being, you can opt out of
    the new rules by placing `#[old_orphan_check]` on the trait (and
    enabling the feature gate where the trait is defined). Longer term,
    you should restructure your traits to avoid the problem. Usually this
    means changing the order of parameters so that the "central" type
    parameter is in the `Self` position.
    
    As an example of that refactoring, consider the `BorrowFrom` trait:
    
    ```rust
    pub trait BorrowFrom&lt;Sized? Owned&gt; for Sized? {
        fn borrow_from(owned: &amp;Owned) -&gt; &amp;Self;
    }
    ```
    
    As defined, this trait is commonly implemented for custom pointer
    types, such as `Arc`. Those impls follow the pattern:
    
    ```rust
    impl&lt;T&gt; BorrowFrom&lt;Arc&lt;T&gt;&gt; for T {...}
    ```
    
    Unfortunately, this impl is illegal because the self type `T` is not
    local to the current crate. Therefore, we are going to change the order of the parameters,
    so that `BorrowFrom` becomes `Borrow`:
    
    ```rust
    pub trait Borrow&lt;Sized? Borrowed&gt; for Sized? {
        fn borrow_from(owned: &amp;Self) -&gt; &amp;Borrowed;
    }
    ```
    
    Now the `Arc` impl is written:
    
    ```rust
    impl&lt;T&gt; Borrow&lt;T&gt; for Arc&lt;T&gt; { ... }
    ```
    
    This impl is legal because the self type (`Arc&lt;T&gt;`) is local.

commit 64ec47c9d2a75c8150d153450e7e7b7db60208dc
Author:     Aaron Turon &lt;aturon@mozilla.com&gt;
AuthorDate: Sun Jan 4 08:43:27 2015 -0800
Commit:     Aaron Turon &lt;aturon@mozilla.com&gt;
CommitDate: Mon Jan 5 14:01:05 2015 -0800

    Final alpha stabilization of core::iter
    
    This commit wraps up the adjustments to the iterator for recent language
    changes.
    
    * Moves `rposition` from `ExactSizeIterator` to `IteratorExt` using a
      `where` clause, thereby removing the `ExactSizeIterator:
      DoubleEndedIterator` constraint.
    
    * Merges `MutableDoubleEndedIterator` into `IteratorExt`, renaming
      `reverse_` to `reverse_in_place`.
    
    * Merges `IteratorOrdExt`, `IteratorCloneExt` and `CloneIteratorExt`
      into `IteratorExt` using `where` clauses.
    
    Marks as `#[stable]`:
    
    * the `iter` module itself
    * `FromIterator`, `Extend`
    * `Iterator`, `IteratorExt`
    * `map`
    * `filter`
    * `filter_map`
    * `skip_while`
    * `take_while`
    * `scan`
    * `flat_map`
    * `inspect`
    * `collect`
    * `fold`
    * `all`
    * `any`
    * `find`
    * `rposition`
    * `max`, `min`
    * Various adapter types related to the above methods
    
    Because of the trait merging, this is a:
    
    [breaking-change]

commit ec7a50d20dff416d9fec837a6492dfe244f5f3ab
Author:     Alex Crichton &lt;alex@alexcrichton.com&gt;
AuthorDate: Tue Nov 25 13:28:35 2014 -0800
Commit:     Alex Crichton &lt;alex@alexcrichton.com&gt;
CommitDate: Mon Jan 5 08:00:13 2015 -0800

    std: Redesign c_str and c_vec
    
    This commit is an implementation of [RFC 494][rfc] which removes the entire
    `std::c_vec` module and redesigns the `std::c_str` module as `std::ffi`.
    
    [rfc]: https://github.com/rust-lang/rfcs/blob/master/text/0494-c_str-and-c_vec-stability.md
    
    The interface of the new `CString` is outlined in the linked RFC, the primary
    changes being:
    
    * The `ToCStr` trait is gone, meaning the `with_c_str` and `to_c_str` methods
      are now gone. These two methods are replaced with a `CString::from_slice`
      method.
    * The `CString` type is now just a wrapper around `Vec&lt;u8&gt;` with a static
      guarantee that there is a trailing nul byte with no internal nul bytes. This
      means that `CString` now implements `Deref&lt;Target = [c_char]&gt;`, which is where
      it gains most of its methods from. A few helper methods are added to acquire a
      slice of `u8` instead of `c_char`, as well as including a slice with the
      trailing nul byte if necessary.
    * All usage of non-owned `CString` values is now done via two functions inside
      of `std::ffi`, called `c_str_to_bytes` and `c_str_to_bytes_with_nul`. These
      functions are now the one method used to convert a `*const c_char` to a Rust
      slice of `u8`.
    
    Many more details, including newly deprecated methods, can be found linked in
    the RFC. This is a:
    
    [breaking-change]
    Closes #20444

commit c8868942e845254abfd3623a709847d65e015a2f
Author:     Niko Matsakis &lt;niko@alum.mit.edu&gt;
AuthorDate: Sat Jan 3 04:40:33 2015 -0500
Commit:     Niko Matsakis &lt;niko@alum.mit.edu&gt;
CommitDate: Mon Jan 5 10:14:35 2015 -0500

    Treat associated types the same as type parameters when it comes to region bounding. Fixes #20303.
    
    Strictly speaking, this is a [breaking-change] (if you are using
    associated types). You are no longer free to wantonly violate the type
    system rules by closing associated types into objects without any form
    of region bound. Instead you should add region bounds like `T::X :
    'a`, just as you would with a normal type parameter.

commit 03268bbf35d3ff2350d987fe7b60375839abdf2e
Merge: 8e83af6 0cb7a40
Author:     bors &lt;bors@rust-lang.org&gt;
AuthorDate: Mon Jan 5 14:51:03 2015 +0000
Commit:     bors &lt;bors@rust-lang.org&gt;
CommitDate: Mon Jan 5 14:51:03 2015 +0000

    auto merge of #20514 : alexcrichton/rust/serialize-associated-type, r=aturon
    
    This commit moves the libserialize crate (and will force the hand of the
    rustc-serialize crate) to not require the `old_orphan_check` feature gate as
    well as using associated types wherever possible. Concretely, the following
    changes were made:
    
    * The error type of `Encoder` and `Decoder` is now an associated type, meaning
      that these traits have no type parameters.
    
    * The `Encoder` and `Decoder` type parameters on the `Encodable` and `Decodable`
      traits have moved to the corresponding method of the trait. This movement
      alleviates the dependency on `old_orphan_check` but implies that
      implementations can no longer be specialized for the type of encoder/decoder
      being implemented.
    
    Due to the trait definitions changing, this is a:
    
    [breaking-change]

commit 0cb7a4062a3c69bb0c54f0c9136889a1006e4f62
Author:     Alex Crichton &lt;alex@alexcrichton.com&gt;
AuthorDate: Sat Jan 3 22:24:50 2015 -0800
Commit:     Alex Crichton &lt;alex@alexcrichton.com&gt;
CommitDate: Sun Jan 4 22:59:26 2015 -0800

    serialize: Use assoc types + less old_orphan_check
    
    This commit moves the libserialize crate (and will force the hand of the
    rustc-serialize crate) to not require the `old_orphan_check` feature gate as
    well as using associated types wherever possible. Concretely, the following
    changes were made:
    
    * The error type of `Encoder` and `Decoder` is now an associated type, meaning
      that these traits have no type parameters.
    
    * The `Encoder` and `Decoder` type parameters on the `Encodable` and `Decodable`
      traits have moved to the corresponding method of the trait. This movement
      alleviates the dependency on `old_orphan_check` but implies that
      implementations can no longer be specialized for the type of encoder/decoder
      being implemented.
    
    Due to the trait definitions changing, this is a:
    
    [breaking-change]

commit bf6c007760169e9c382d3700fd1cdd20037e4343
Author:     Huon Wilson &lt;dbau.pp+github@gmail.com&gt;
AuthorDate: Fri Dec 5 15:56:25 2014 -0800
Commit:     Huon Wilson &lt;dbau.pp+github@gmail.com&gt;
CommitDate: Mon Jan 5 16:14:17 2015 +1100

    Change `&amp;` pat to only work with &amp;T, and `&amp;mut` with &amp;mut T.
    
    This implements RFC 179 by making the pattern `&amp;&lt;pat&gt;` require matching
    against a variable of type `&amp;T`, and introducing the pattern `&amp;mut
    &lt;pat&gt;` which only works with variables of type `&amp;mut T`.
    
    The pattern `&amp;mut x` currently parses as `&amp;(mut x)` i.e. a pattern match
    through a `&amp;T` or a `&amp;mut T` that binds the variable `x` to have type
    `T` and to be mutable. This should be rewritten as follows, for example,
    
        for &amp;mut x in slice.iter() {
    
    becomes
    
        for &amp;x in slice.iter() {
            let mut x = x;
    
    Due to this, this is a
    
    [breaking-change]
    
    Closes #20496.

commit 0302d379776fca82d3eb693046239dc66998f691
Author:     Huon Wilson &lt;dbau.pp+github@gmail.com&gt;
AuthorDate: Tue Dec 30 13:58:31 2014 +1100
Commit:     Huon Wilson &lt;dbau.pp+github@gmail.com&gt;
CommitDate: Mon Jan 5 12:30:51 2015 +1100

    Merge `UnicodeChar` and `CharExt`.
    
    This "reexports" all the functionality of `core::char::CharExt` as
    methods on `unicode::u_char::UnicodeChar` (renamed to `CharExt`).
    
    Imports may need to be updated (one now just imports
    `unicode::CharExt`, or `std::char::CharExt` rather than two traits from
    either), so this is a
    
    [breaking-change]

commit 19120209d8e532514203d16a2cff0ad3b44de3bb
Author:     Huon Wilson &lt;dbau.pp+github@gmail.com&gt;
AuthorDate: Tue Dec 30 13:53:20 2014 +1100
Commit:     Huon Wilson &lt;dbau.pp+github@gmail.com&gt;
CommitDate: Mon Jan 5 12:30:30 2015 +1100

    Rename `core::char::Char` to `CharExt` to match prelude guidelines.
    
    Imports may need to be updated so this is a
    
    [breaking-change]

commit c6c786671d692d7b13c2e5c68a53001327b4b125
Merge: 496dc4e ce8f748
Author:     bors &lt;bors@rust-lang.org&gt;
AuthorDate: Sun Jan 4 00:50:59 2015 +0000
Commit:     bors &lt;bors@rust-lang.org&gt;
CommitDate: Sun Jan 4 00:50:59 2015 +0000

    auto merge of #20490 : japaric/rust/assoc-types, r=aturon
    
    closes #20486
    closes #20474
    closes #20441
    
    [breaking-change]
    
    The `Index[Mut]` traits now have one less input parameter, as the return type of the indexing operation is an associated type. This breaks all existing implementations.
    
    ---
    
    binop traits (`Add`, `Sub`, etc) now have an associated type for their return type. Also, the RHS input parameter now defaults to `Self` (except for the `Shl` and `Shr` traits). For example, the `Add` trait now looks like this:
    
    ``` rust
    trait Add&lt;Rhs=Self&gt; {
        type Output;
    
        fn add(self, Rhs) -&gt; Self::Output;
    }
    ```
    
    The `Neg` and `Not` traits now also have an associated type for their return type.
    
    This breaks all existing implementations of these traits.
    
    ---
    Affected traits:
    
    - `Iterator { type Item }`
    - `IteratorExt` no input/output types, uses `&lt;Self as Iterator&gt;::Item` in its methods
    - `DoubleEndedIterator` no input/output types, uses `&lt;Self as Iterator&gt;::Item` in its methods
    - `DoubleEndedIteratorExt` no input/output types, uses `&lt;Self as Iterator&gt;::Item` in its methods
    - `RandomAccessIterator` no input/output types
    - `ExactSizeIterator` no input/output types, uses `&lt;Self as Iterator&gt;::Item` in its methods
    
    This breaks all the implementations of these traits.

commit f031285c3a76b86525695bbb5b46daa9e77df200
Author:     Corey Farwell &lt;coreyf@rwell.org&gt;
AuthorDate: Fri Jan 2 19:31:50 2015 -0800
Commit:     Corey Farwell &lt;coreyf@rwell.org&gt;
CommitDate: Fri Jan 2 19:35:56 2015 -0800

    Remove graphviz::LabelText::* public reexport
    
    Part of #19253
    
    [breaking-change]

commit 9c3e6082e71618c088afd93f7a4a9a7708c9dcbd
Merge: a6b1097 d9769ec
Author:     bors &lt;bors@rust-lang.org&gt;
AuthorDate: Sat Jan 3 03:25:21 2015 +0000
Commit:     bors &lt;bors@rust-lang.org&gt;
CommitDate: Sat Jan 3 03:25:21 2015 +0000

    auto merge of #20154 : P1start/rust/qualified-assoc-type-generics, r=nikomatsakis
    
    This modifies `Parser::eat_lt` to always split up `&lt;&lt;`s, instead of doing so only when a lifetime name followed or the `force` parameter (now removed) was `true`. This is because `Foo&lt;&lt;TYPE` is now a valid start to a type, whereas previously only `Foo&lt;&lt;LIFETIME` was valid.
    
    This is a [breaking-change]. Change code that looks like this:
    
    ```rust
    let x = foo as bar &lt;&lt; 13;
    ```
    
    to use parentheses, like this:
    
    ```rust
    let x = (foo as bar) &lt;&lt; 13;
    ```
    
    Closes #17362.

commit 9ca8076cb77a7d7738162c80e1d240ef2ad0b73a
Merge: 073fd5b f9ce6f5
Author:     Alex Crichton &lt;alex@alexcrichton.com&gt;
AuthorDate: Fri Jan 2 09:22:37 2015 -0800
Commit:     Alex Crichton &lt;alex@alexcrichton.com&gt;
CommitDate: Fri Jan 2 09:22:37 2015 -0800

    rollup merge of #20386: frewsxcv/rm-reexports
    
    Part of #19253
    
    [breaking-change]

commit 56290a004493a5d2e211f056601533253497df60
Author:     Alex Crichton &lt;alex@alexcrichton.com&gt;
AuthorDate: Mon Dec 22 09:04:23 2014 -0800
Commit:     Alex Crichton &lt;alex@alexcrichton.com&gt;
CommitDate: Fri Jan 2 08:54:06 2015 -0800

    std: Stabilize the prelude module
    
    This commit is an implementation of [RFC 503][rfc] which is a stabilization
    story for the prelude. Most of the RFC was directly applied, removing reexports.
    Some reexports are kept around, however:
    
    * `range` remains until range syntax has landed to reduce churn.
    * `Path` and `GenericPath` remain until path reform lands. This is done to
      prevent many imports of `GenericPath` which will soon be removed.
    * All `io` traits remain until I/O reform lands so imports can be rewritten all
      at once to `std::io::prelude::*`.
    
    This is a breaking change because many prelude reexports have been removed, and
    the RFC can be consulted for the exact list of removed reexports, as well as to
    find the locations of where to import them.
    
    [rfc]: https://github.com/rust-lang/rfcs/blob/master/text/0503-prelude-stabilization.md
    [breaking-change]
    
    Closes #20068

commit 71b46b18a274edc7f7fb60b490e5ebbb9c911462
Merge: 1f887c8 8dbaa71
Author:     bors &lt;bors@rust-lang.org&gt;
AuthorDate: Fri Jan 2 15:51:25 2015 +0000
Commit:     bors &lt;bors@rust-lang.org&gt;
CommitDate: Fri Jan 2 15:51:25 2015 +0000

    auto merge of #20356 : Gankro/rust/stab, r=aturon
    
    This stabilizes most of libcollections, carefully avoiding sections of API which are being managed in other PRs. APIs which are not stable are marked explicitly unstable with a reason.
    
    Deprecates:
    
    * DList
      * rotate_forward
      * rotate_backward
      * prepend
      * insert_when
      * insert_ordered
      * merge
    
    * VecMap
      * update
      * update_with_key
    
    * Renames and newtypes the Bitv and BitvSet iterators to match conventions.
    
    * Removes the Copy impl from DList's Iter.
    
    as such this is a
    
    [breaking-change]

commit 7506fe52696c5b3b628f173d74dc4a13b5ccc1f3
Author:     Nick Cameron &lt;ncameron@mozilla.com&gt;
AuthorDate: Wed Dec 31 17:25:18 2014 +1300
Commit:     Nick Cameron &lt;ncameron@mozilla.com&gt;
CommitDate: Fri Jan 2 23:05:22 2015 +1300

    Accept `derive` instead of `deriving`
    
    [breaking-change]
    
    `deriving is still accepted, but gives a deprecation warning

commit 74d11d26f4042ce04c56edfd6caafa003383147d
Author:     Nick Cameron &lt;ncameron@mozilla.com&gt;
AuthorDate: Wed Dec 31 17:24:42 2014 +1300
Commit:     Nick Cameron &lt;ncameron@mozilla.com&gt;
CommitDate: Fri Jan 2 23:05:22 2015 +1300

    Accept `self` in place of `mod` in use items
    
    [breaking-change]
    
    `mod` is still accepted, but gives a deprecated warning

commit c61a0092bc236c4be4cb691fcd50ff50e91ab0d6
Author:     Niko Matsakis &lt;niko@alum.mit.edu&gt;
AuthorDate: Fri Dec 26 03:30:51 2014 -0500
Commit:     Niko Matsakis &lt;niko@alum.mit.edu&gt;
CommitDate: Fri Jan 2 04:06:09 2015 -0500

    Fix orphan checking (cc #19470). (This is not a complete fix of #19470 because of the backwards compatibility feature gate.)
    
    This is a [breaking-change]. The new rules require that, for an impl of a trait defined
    in some other crate, two conditions must hold:
    
    1. Some type must be local.
    2. Every type parameter must appear "under" some local type.
    
    Here are some examples that are legal:
    
    ```rust
    struct MyStruct&lt;T&gt; { ... }
    
    // Here `T` appears "under' `MyStruct`.
    impl&lt;T&gt; Clone for MyStruct&lt;T&gt; { }
    
    // Here `T` appears "under' `MyStruct` as well. Note that it also appears
    // elsewhere.
    impl&lt;T&gt; Iterator&lt;T&gt; for MyStruct&lt;T&gt; { }
    ```
    
    Here is an illegal example:
    
    ```rust
    // Here `U` does not appear "under" `MyStruct` or any other local type.
    // We call `U` "uncovered".
    impl&lt;T,U&gt; Iterator&lt;U&gt; for MyStruct&lt;T&gt; { }
    ```
    
    There are a couple of ways to rewrite this last example so that it is
    legal:
    
    1. In some cases, the uncovered type parameter (here, `U`) should be converted
       into an associated type. This is however a non-local change that requires access
       to the original trait. Also, associated types are not fully baked.
    2. Add `U` as a type parameter of `MyStruct`:
       ```rust
       struct MyStruct&lt;T,U&gt; { ... }
       impl&lt;T,U&gt; Iterator&lt;U&gt; for MyStruct&lt;T,U&gt; { }
       ```
    3. Create a newtype wrapper for `U`
       ```rust
       impl&lt;T,U&gt; Iterator&lt;Wrapper&lt;U&gt;&gt; for MyStruct&lt;T,U&gt; { }
       ```
    
    Because associated types are not fully baked, which in the case of the
    `Hash` trait makes adhering to this rule impossible, you can
    temporarily disable this rule in your crate by using
    `#![feature(old_orphan_check)]`. Note that the `old_orphan_check`
    feature will be removed before 1.0 is released.

commit f2ccdfd8914b7b8f8f8f2053f9ecd98d54ef95a6
Author:     Alex Crichton &lt;alex@alexcrichton.com&gt;
AuthorDate: Thu Jan 1 22:24:06 2015 -0800
Commit:     Alex Crichton &lt;alex@alexcrichton.com&gt;
CommitDate: Thu Jan 1 22:31:53 2015 -0800

    std: Second pass stabilization for `boxed`
    
    This commit performs a second pass over the `std::boxed` module, taking the
    following actions:
    
    * `boxed` is now stable
    * `Box` is now stable
    * `BoxAny` is removed in favor of a direct `impl Box&lt;Any&gt;`
    * `Box::downcast` remains unstable while the name of the `downcast` family of
      methods is determined.
    
    This is a breaking change due to the removal of the `BoxAny` trait (note that
    the `downcast` method still exists), and existing consumers of `BoxAny` simply
    need to remove the import in their modules.
    
    [breaking-change]

commit e423fcf0e0166da55f88233e0be5eacba55bc0bc
Author:     Alex Crichton &lt;alex@alexcrichton.com&gt;
AuthorDate: Fri Dec 12 10:59:41 2014 -0800
Commit:     Alex Crichton &lt;alex@alexcrichton.com&gt;
CommitDate: Thu Jan 1 22:04:46 2015 -0800

    std: Enforce Unicode in fmt::Writer
    
    This commit is an implementation of [RFC 526][rfc] which is a change to alter
    the definition of the old `fmt::FormatWriter`. The new trait, renamed to
    `Writer`, now only exposes one method `write_str` in order to guarantee that all
    implementations of the formatting traits can only produce valid Unicode.
    
    [rfc]: https://github.com/rust-lang/rfcs/blob/master/text/0526-fmt-text-writer.md
    
    One of the primary improvements of this patch is the performance of the
    `.to_string()` method by avoiding an almost-always redundant UTF-8 check. This
    is a breaking change due to the renaming of the trait as well as the loss of the
    `write` method, but migration paths should be relatively easy:
    
    * All usage of `write` should move to `write_str`. If truly binary data was
      being written in an implementation of `Show`, then it will need to use a
      different trait or an altogether different code path.
    
    * All usage of `write!` should continue to work as-is with no modifications.
    
    * All usage of `Show` where implementations just delegate to another should
      continue to work as-is.
    
    [breaking-change]
    
    Closes #20352

commit f3a7ec7028c76b3a1c6051131328f372b068e33a
Author:     Alex Crichton &lt;alex@alexcrichton.com&gt;
AuthorDate: Mon Dec 29 15:03:01 2014 -0800
Commit:     Alex Crichton &lt;alex@alexcrichton.com&gt;
CommitDate: Thu Jan 1 22:02:59 2015 -0800

    std: Second pass stabilization of sync
    
    This pass performs a second pass of stabilization through the `std::sync`
    module, avoiding modules/types that are being handled in other PRs (e.g.
    mutexes, rwlocks, condvars, and channels).
    
    The following items are now stable
    
    * `sync::atomic`
    * `sync::atomic::ATOMIC_BOOL_INIT` (was `INIT_ATOMIC_BOOL`)
    * `sync::atomic::ATOMIC_INT_INIT` (was `INIT_ATOMIC_INT`)
    * `sync::atomic::ATOMIC_UINT_INIT` (was `INIT_ATOMIC_UINT`)
    * `sync::Once`
    * `sync::ONCE_INIT`
    * `sync::Once::call_once` (was `doit`)
      * C == `pthread_once(..)`
      * Boost == `call_once(..)`
      * Windows == `InitOnceExecuteOnce`
    * `sync::Barrier`
    * `sync::Barrier::new`
    * `sync::Barrier::wait` (now returns a `bool`)
    * `sync::Semaphore::new`
    * `sync::Semaphore::acquire`
    * `sync::Semaphore::release`
    
    The following items remain unstable
    
    * `sync::SemaphoreGuard`
    * `sync::Semaphore::access` - it's unclear how this relates to the poisoning
                                  story of mutexes.
    * `sync::TaskPool` - the semantics of a failing task and whether a thread is
                         re-attached to a thread pool are somewhat unclear, and the
                         utility of this type in `sync` is question with respect to
                         the jobs of other primitives. This type will likely become
                         stable or move out of the standard library over time.
    * `sync::Future` - futures as-is have yet to be deeply re-evaluated with the
                       recent core changes to Rust's synchronization story, and will
                       likely become stable in the future but are unstable until
                       that time comes.
    
    [breaking-change]

commit d45b5d2ed9b43b3ad573482fb8820a382f20289e
Author:     Nick Cameron &lt;ncameron@mozilla.com&gt;
AuthorDate: Tue Dec 30 19:55:06 2014 +1300
Commit:     Nick Cameron &lt;ncameron@mozilla.com&gt;
CommitDate: Fri Jan 2 10:28:19 2015 +1300

    Disallow [_, ..n] syntax for fixed length arrays and repeating array constructors
    
    Closes #19999
    
    [breaking-change]
    
    Use [_; n] instead.

commit 39d74026663597a8d4ad0ab04e6d117bf9fd6ad4
Merge: c594959 41da99d
Author:     bors &lt;bors@rust-lang.org&gt;
AuthorDate: Thu Jan 1 15:51:08 2015 +0000
Commit:     bors &lt;bors@rust-lang.org&gt;
CommitDate: Thu Jan 1 15:51:08 2015 +0000

    auto merge of #20190 : cmr/rust/gate-macro-args, r=alexcrichton
    
    Uses the same approach as https://github.com/rust-lang/rust/pull/17286 (and
    subsequent changes making it more correct), where the visitor will skip any
    pieces of the AST that are from "foreign code", where the spans don't line up,
    indicating that that piece of code is due to a macro expansion.
    
    If this breaks your code, read the error message to determine which feature
    gate you should add to your crate.
    
    Closes #18102
    
    [breaking-change]

commit 41da99dff417eadf8f296a93529d9810f79e1d1b
Author:     Corey Richardson &lt;corey@octayn.net&gt;
AuthorDate: Wed Dec 24 00:44:13 2014 -0500
Commit:     Corey Richardson &lt;corey@octayn.net&gt;
CommitDate: Thu Jan 1 07:06:46 2015 -0500

    Feature gate macro arguments
    
    Uses the same approach as https://github.com/rust-lang/rust/pull/17286 (and
    subsequent changes making it more correct), where the visitor will skip any
    pieces of the AST that are from "foreign code", where the spans don't line up,
    indicating that that piece of code is due to a macro expansion.
    
    If this breaks your code, read the error message to determine which feature
    gate you should add to your crate, and bask in the knowledge that your code
    won't mysteriously break should you try to use the 1.0 release.
    
    Closes #18102
    
    [breaking-change]

commit 47b8479e73e40395f1b1b2d0c6281f28f80301e4
Merge: 7d4f487 10bbf69
Author:     bors &lt;bors@rust-lang.org&gt;
AuthorDate: Thu Jan 1 04:01:02 2015 +0000
Commit:     bors &lt;bors@rust-lang.org&gt;
CommitDate: Thu Jan 1 04:01:02 2015 +0000

    auto merge of #20363 : japaric/rust/moar-uc, r=nmatsakis
    
    The the last argument of the `ItemDecorator::expand` method has changed to `Box&lt;FnMut&gt;`. Syntax extensions will break.
    
    [breaking-change]
    
    ---
    
    This PR removes pretty much all the remaining uses of boxed closures from the libraries. There are still boxed closures under the `test` directory, but I think those should be removed or replaced with unboxed closures at the same time we remove boxed closures from the language.
    
    In a few places I had to do some contortions (see the first commit for an example) to work around issue #19596. I have marked those workarounds with FIXMEs. In the future when `&amp;mut F where F: FnMut` implements the `FnMut` trait, we should be able to remove those workarounds. I've take care to avoid placing the workaround functions in the public API.
    
    Since `let f = || {}` always gets type checked as a boxed closure, I have explictly annotated those closures (with e.g. `|&amp;:| {}`) to force the compiler to type check them as unboxed closures.
    
    Instead of removing the type aliases (like `GetCrateDataCb`), I could have replaced them with newtypes. But this seemed like overcomplicating things for little to no gain.
    
    I think we should be able to remove the boxed closures from the languge after this PR lands. (I'm being optimistic here)
    
    r? @alexcrichton or @aturon
    cc @nikomatsakis

commit f9ce6f5ba458d6a3d4e63b282bac43a18e90aeb0
Author:     Corey Farwell &lt;coreyf@rwell.org&gt;
AuthorDate: Wed Dec 31 19:10:43 2014 -0800
Commit:     Corey Farwell &lt;coreyf@rwell.org&gt;
CommitDate: Wed Dec 31 19:28:01 2014 -0800

    Remove core::iter::MinMaxResult::* public reexport
    
    Part of #19253
    
    [breaking-change]
</pre></body></html>
