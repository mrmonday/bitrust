<!DOCTYPE html><html><head>
<title>BitRust - Breaking Changes in rust-lang/rust</title>
</head><body><pre>
commit 25d5a3a19423fee01787de87a56d185dd4e0a4e7
Merge: 743d926 ec7a50d
Author: Alex Crichton &lt;alex@alexcrichton.com&gt;
Date:   Mon Jan 5 18:37:22 2015 -0800

    rollup merge of #20507: alexcrichton/issue-20444
    
    This commit is an implementation of [RFC 494][rfc] which removes the entire
    `std::c_vec` module and redesigns the `std::c_str` module as `std::ffi`.
    
    [rfc]: https://github.com/rust-lang/rfcs/blob/master/text/0494-c_str-and-c_vec-stability.md
    
    The interface of the new `CString` is outlined in the linked RFC, the primary
    changes being:
    
    * The `ToCStr` trait is gone, meaning the `with_c_str` and `to_c_str` methods
      are now gone. These two methods are replaced with a `CString::from_slice`
      method.
    * The `CString` type is now just a wrapper around `Vec&lt;u8&gt;` with a static
      guarantee that there is a trailing nul byte with no internal nul bytes. This
      means that `CString` now implements `Deref&lt;Target = [c_char]&gt;`, which is where
      it gains most of its methods from. A few helper methods are added to acquire a
      slice of `u8` instead of `c_char`, as well as including a slice with the
      trailing nul byte if necessary.
    * All usage of non-owned `CString` values is now done via two functions inside
      of `std::ffi`, called `c_str_to_bytes` and `c_str_to_bytes_with_nul`. These
      functions are now the one method used to convert a `*const c_char` to a Rust
      slice of `u8`.
    
    Many more details, including newly deprecated methods, can be found linked in
    the RFC. This is a:
    
    [breaking-change]
    Closes #20444

commit 88b4c8e0d347921673e61bf1770ba0acd4c7d824
Merge: 059566b 5caf847
Author: Alex Crichton &lt;alex@alexcrichton.com&gt;
Date:   Mon Jan 5 18:36:34 2015 -0800

    rollup merge of #20465: nikomatsakis/assoc-types-regions-20303
    
    Treat associated types the same as type parameters when it comes to region bounding. Fixes #20303.
    
    Strictly speaking, this is a [breaking-change] (if you are using
    associated types). You are no longer free to wantonly violate the type
    system rules by closing associated types into objects without any form
    of region bound. Instead you should add region bounds like `T::X :
    'a`, just as you would with a normal type parameter.
    
    r? @aturon

commit 48f50e1e98691d74427e23e82694f528b3fb4d56
Author: Nick Cameron &lt;ncameron@mozilla.com&gt;
Date:   Tue Jan 6 09:44:33 2015 +1300

    Obsolete `Sized? T`
    
    [breaking-change]
    
    Use `T: ?Sized`

commit c7dd3c4d69aee1c4ad8cc220c194b176bba2ab62
Merge: f11f3e7 eb2506c
Author: bors &lt;bors@rust-lang.org&gt;
Date:   Mon Jan 5 23:51:00 2015 +0000

    auto merge of #20578 : japaric/rust/no-more-bc, r=nmatsakis
    
    This PR removes boxed closures from the language, the closure type syntax (`let f: |int| -&gt; bool = /* ... */`) has been obsoleted. Move all your uses of closures to the new unboxed closure system (i.e. `Fn*` traits).
    
    [breaking-change] patterns
    
    - `lef f = || {}`
    
    This binding used to type check to a boxed closure. Now that boxed closures are gone, you need to annotate the "kind" of the unboxed closure, i.e. you need pick one of these: `|&amp;:| {}`, `|&amp;mut:| {}` or `|:| {}`.
    
    In the (near) future we'll have closure "kind" inference, so the compiler will infer which `Fn*` trait to use based on how the closure is used. Once this inference machinery is in place, we'll be able to remove the kind annotation from most closures.
    
    - `type Alias&lt;'a&gt; = |int|:'a -&gt; bool`
    
    Use a trait object: `type Alias&lt;'a&gt; = Box&lt;FnMut(int) -&gt; bool + 'a&gt;`. Use the `Fn*` trait that makes sense for your use case.
    
    - `fn foo(&amp;self, f: |uint| -&gt; bool)`
    
    In this case you can use either a trait object or an unboxed closure:
    
    ``` rust
    fn foo(&amp;self, f: F) where F: FnMut(uint) -&gt; bool;
    // or
    fn foo(&amp;self, f: Box&lt;FnMut(uint) -&gt; bool&gt;);
    ```
    
    - `struct Struct&lt;'a&gt; { f: |uint|:'a -&gt; bool }`
    
    Again, you can use either a trait object or an unboxed closure:
    
    ``` rust
    struct Struct&lt;F&gt; where F: FnMut(uint) -&gt; bool { f: F }
    // or
    struct Struct&lt;'a&gt; { f: Box&lt;FnMut(uint) -&gt; bool + 'a&gt; }
    ```
    
    - Using `|x, y| f(x, y)` for closure "borrows"
    
    This comes up in recursive functions, consider the following (contrived) example:
    
    ``` rust
    fn foo(x: uint, f: |uint| -&gt; bool) -&gt; bool {
        //foo(x / 2, f) &amp;&amp; f(x)  // can't use this because `f` gets moved away in the `foo` call
        foo(x / 2, |x| f(x)) &amp;&amp; f(x)  // instead "borrow" `f` in the `foo` call
    }
    ```
    
    If you attempt to do the same with unboxed closures you'll hit ""error: reached the recursion limit during monomorphization" (see #19596):
    
    ``` rust
    fn foo&lt;F&gt;(x: uint, mut f: F) -&gt; bool where F: FnMut(uint) -&gt; bool {
        foo(x / 2, |x| f(x)) &amp;&amp; f(x)
        //~^ error: reached the recursion limit during monomorphization
    }
    ```
    
    Instead you *should* be able to write this:
    
    ``` rust
    fn foo&lt;F&gt;(x: uint, mut f: F) -&gt; bool where F: FnMut(uint) -&gt; bool {
        foo(x / 2, &amp;mut f) &amp;&amp; f(x)
        //~^ error: the trait `FnMut` is not implemented for the type `&amp;mut F`
    }
    ```
    
    But as you see above `&amp;mut F` doesn't implement the `FnMut` trait. `&amp;mut F` *should* implement the `FnMut` and the above code *should* work, but due to a bug (see #18835) it doesn't (for now).
    
    You can work around the issue by rewriting the function to take `&amp;mut F` instead of `F`:
    
    ``` rust
    fn foo&lt;F&gt;(x: uint, f: &amp;mut F) -&gt; bool where F: FnMut(uint) -&gt; bool {
        foo(x / 2, f) &amp;&amp; (*f)(x)
    }
    ```
    
    This finally works! However writing `foo(0, &amp;mut |x| x == 0)` is unergonomic. So you can use a private helper function to avoid this:
    
    ``` rust
    // public API function
    pub fn foo&lt;F&gt;(x: uint, mut f: F) -&gt; bool where F: FnMut(uint) -&gt; bool {
        foo_(x, &amp;mut f)
    }
    
    // private helper function
    fn foo_&lt;F&gt;(x: uint, f: &amp;mut F) -&gt; bool where F: FnMut(uint) -&gt; bool {
        foo_(x / 2, f) &amp;&amp; (*f)(x)
    }
    ```
    
    Closes #14798
    
    ---
    
    There is more cleanup to do: like renaming functions/types from `unboxed_closure` to just `closure`, removing more dead code, simplify functions which now have unused arguments, update the documentation, etc. But that can be done in another PR.
    
    r? @nikomatsakis @aturon (You probably want to focus on the deleted/modified tests.)
    cc @eddyb

commit 6e68fd09edc7ed37fd76f703247b5410cd338bfe
Author: Niko Matsakis &lt;niko@alum.mit.edu&gt;
Date:   Sun Jan 4 20:35:06 2015 -0500

    Implement new orphan rule that requires that impls of remote traits meet the following two criteria:
    
    - the self type includes some local type; and,
    - type parameters in the self type must be constrained by a local type.
    
    A type parameter is called *constrained* if it appears in some type-parameter of a local type.
    
    Here are some examples that are accepted. In all of these examples, I
    assume that `Foo` is a trait defined in another crate. If `Foo` were
    defined in the local crate, then all the examples would be legal.
    
    - `impl Foo for LocalType`
    - `impl&lt;T&gt; Foo&lt;T&gt; for LocalType` -- T does not appear in Self, so it is OK
    - `impl&lt;T&gt; Foo&lt;T&gt; for LocalType&lt;T&gt;` -- T here is constrained by LocalType
    - `impl&lt;T&gt; Foo&lt;T&gt; for (LocalType&lt;T&gt;, T)` -- T here is constrained by LocalType
    
    Here are some illegal examples (again, these examples assume that
    `Foo` is not local to the current crate):
    
    - `impl Foo for int` -- the Self type is not local
    - `impl&lt;T&gt; Foo for T` -- T appears in Self unconstrained by a local type
    - `impl&lt;T&gt; Foo for (LocalType, T)` -- T appears in Self unconstrained by a local type
    
    This is a [breaking-change]. For the time being, you can opt out of
    the new rules by placing `#[old_orphan_check]` on the trait (and
    enabling the feature gate where the trait is defined). Longer term,
    you should restructure your traits to avoid the problem. Usually this
    means changing the order of parameters so that the "central" type
    parameter is in the `Self` position.
    
    As an example of that refactoring, consider the `BorrowFrom` trait:
    
    ```rust
    pub trait BorrowFrom&lt;Sized? Owned&gt; for Sized? {
        fn borrow_from(owned: &amp;Owned) -&gt; &amp;Self;
    }
    ```
    
    As defined, this trait is commonly implemented for custom pointer
    types, such as `Arc`. Those impls follow the pattern:
    
    ```rust
    impl&lt;T&gt; BorrowFrom&lt;Arc&lt;T&gt;&gt; for T {...}
    ```
    
    Unfortunately, this impl is illegal because the self type `T` is not
    local to the current crate. Therefore, we are going to change the order of the parameters,
    so that `BorrowFrom` becomes `Borrow`:
    
    ```rust
    pub trait Borrow&lt;Sized? Borrowed&gt; for Sized? {
        fn borrow_from(owned: &amp;Self) -&gt; &amp;Borrowed;
    }
    ```
    
    Now the `Arc` impl is written:
    
    ```rust
    impl&lt;T&gt; Borrow&lt;T&gt; for Arc&lt;T&gt; { ... }
    ```
    
    This impl is legal because the self type (`Arc&lt;T&gt;`) is local.

commit 64ec47c9d2a75c8150d153450e7e7b7db60208dc
Author: Aaron Turon &lt;aturon@mozilla.com&gt;
Date:   Sun Jan 4 08:43:27 2015 -0800

    Final alpha stabilization of core::iter
    
    This commit wraps up the adjustments to the iterator for recent language
    changes.
    
    * Moves `rposition` from `ExactSizeIterator` to `IteratorExt` using a
      `where` clause, thereby removing the `ExactSizeIterator:
      DoubleEndedIterator` constraint.
    
    * Merges `MutableDoubleEndedIterator` into `IteratorExt`, renaming
      `reverse_` to `reverse_in_place`.
    
    * Merges `IteratorOrdExt`, `IteratorCloneExt` and `CloneIteratorExt`
      into `IteratorExt` using `where` clauses.
    
    Marks as `#[stable]`:
    
    * the `iter` module itself
    * `FromIterator`, `Extend`
    * `Iterator`, `IteratorExt`
    * `map`
    * `filter`
    * `filter_map`
    * `skip_while`
    * `take_while`
    * `scan`
    * `flat_map`
    * `inspect`
    * `collect`
    * `fold`
    * `all`
    * `any`
    * `find`
    * `rposition`
    * `max`, `min`
    * Various adapter types related to the above methods
    
    Because of the trait merging, this is a:
    
    [breaking-change]

commit ec7a50d20dff416d9fec837a6492dfe244f5f3ab
Author: Alex Crichton &lt;alex@alexcrichton.com&gt;
Date:   Tue Nov 25 13:28:35 2014 -0800

    std: Redesign c_str and c_vec
    
    This commit is an implementation of [RFC 494][rfc] which removes the entire
    `std::c_vec` module and redesigns the `std::c_str` module as `std::ffi`.
    
    [rfc]: https://github.com/rust-lang/rfcs/blob/master/text/0494-c_str-and-c_vec-stability.md
    
    The interface of the new `CString` is outlined in the linked RFC, the primary
    changes being:
    
    * The `ToCStr` trait is gone, meaning the `with_c_str` and `to_c_str` methods
      are now gone. These two methods are replaced with a `CString::from_slice`
      method.
    * The `CString` type is now just a wrapper around `Vec&lt;u8&gt;` with a static
      guarantee that there is a trailing nul byte with no internal nul bytes. This
      means that `CString` now implements `Deref&lt;Target = [c_char]&gt;`, which is where
      it gains most of its methods from. A few helper methods are added to acquire a
      slice of `u8` instead of `c_char`, as well as including a slice with the
      trailing nul byte if necessary.
    * All usage of non-owned `CString` values is now done via two functions inside
      of `std::ffi`, called `c_str_to_bytes` and `c_str_to_bytes_with_nul`. These
      functions are now the one method used to convert a `*const c_char` to a Rust
      slice of `u8`.
    
    Many more details, including newly deprecated methods, can be found linked in
    the RFC. This is a:
    
    [breaking-change]
    Closes #20444

commit c8868942e845254abfd3623a709847d65e015a2f
Author: Niko Matsakis &lt;niko@alum.mit.edu&gt;
Date:   Sat Jan 3 04:40:33 2015 -0500

    Treat associated types the same as type parameters when it comes to region bounding. Fixes #20303.
    
    Strictly speaking, this is a [breaking-change] (if you are using
    associated types). You are no longer free to wantonly violate the type
    system rules by closing associated types into objects without any form
    of region bound. Instead you should add region bounds like `T::X :
    'a`, just as you would with a normal type parameter.

commit 03268bbf35d3ff2350d987fe7b60375839abdf2e
Merge: 8e83af6 0cb7a40
Author: bors &lt;bors@rust-lang.org&gt;
Date:   Mon Jan 5 14:51:03 2015 +0000

    auto merge of #20514 : alexcrichton/rust/serialize-associated-type, r=aturon
    
    This commit moves the libserialize crate (and will force the hand of the
    rustc-serialize crate) to not require the `old_orphan_check` feature gate as
    well as using associated types wherever possible. Concretely, the following
    changes were made:
    
    * The error type of `Encoder` and `Decoder` is now an associated type, meaning
      that these traits have no type parameters.
    
    * The `Encoder` and `Decoder` type parameters on the `Encodable` and `Decodable`
      traits have moved to the corresponding method of the trait. This movement
      alleviates the dependency on `old_orphan_check` but implies that
      implementations can no longer be specialized for the type of encoder/decoder
      being implemented.
    
    Due to the trait definitions changing, this is a:
    
    [breaking-change]

commit 0cb7a4062a3c69bb0c54f0c9136889a1006e4f62
Author: Alex Crichton &lt;alex@alexcrichton.com&gt;
Date:   Sat Jan 3 22:24:50 2015 -0800

    serialize: Use assoc types + less old_orphan_check
    
    This commit moves the libserialize crate (and will force the hand of the
    rustc-serialize crate) to not require the `old_orphan_check` feature gate as
    well as using associated types wherever possible. Concretely, the following
    changes were made:
    
    * The error type of `Encoder` and `Decoder` is now an associated type, meaning
      that these traits have no type parameters.
    
    * The `Encoder` and `Decoder` type parameters on the `Encodable` and `Decodable`
      traits have moved to the corresponding method of the trait. This movement
      alleviates the dependency on `old_orphan_check` but implies that
      implementations can no longer be specialized for the type of encoder/decoder
      being implemented.
    
    Due to the trait definitions changing, this is a:
    
    [breaking-change]

commit bf6c007760169e9c382d3700fd1cdd20037e4343
Author: Huon Wilson &lt;dbau.pp+github@gmail.com&gt;
Date:   Fri Dec 5 15:56:25 2014 -0800

    Change `&amp;` pat to only work with &amp;T, and `&amp;mut` with &amp;mut T.
    
    This implements RFC 179 by making the pattern `&amp;&lt;pat&gt;` require matching
    against a variable of type `&amp;T`, and introducing the pattern `&amp;mut
    &lt;pat&gt;` which only works with variables of type `&amp;mut T`.
    
    The pattern `&amp;mut x` currently parses as `&amp;(mut x)` i.e. a pattern match
    through a `&amp;T` or a `&amp;mut T` that binds the variable `x` to have type
    `T` and to be mutable. This should be rewritten as follows, for example,
    
        for &amp;mut x in slice.iter() {
    
    becomes
    
        for &amp;x in slice.iter() {
            let mut x = x;
    
    Due to this, this is a
    
    [breaking-change]
    
    Closes #20496.

commit 0302d379776fca82d3eb693046239dc66998f691
Author: Huon Wilson &lt;dbau.pp+github@gmail.com&gt;
Date:   Tue Dec 30 13:58:31 2014 +1100

    Merge `UnicodeChar` and `CharExt`.
    
    This "reexports" all the functionality of `core::char::CharExt` as
    methods on `unicode::u_char::UnicodeChar` (renamed to `CharExt`).
    
    Imports may need to be updated (one now just imports
    `unicode::CharExt`, or `std::char::CharExt` rather than two traits from
    either), so this is a
    
    [breaking-change]

commit 19120209d8e532514203d16a2cff0ad3b44de3bb
Author: Huon Wilson &lt;dbau.pp+github@gmail.com&gt;
Date:   Tue Dec 30 13:53:20 2014 +1100

    Rename `core::char::Char` to `CharExt` to match prelude guidelines.
    
    Imports may need to be updated so this is a
    
    [breaking-change]

commit c6c786671d692d7b13c2e5c68a53001327b4b125
Merge: 496dc4e ce8f748
Author: bors &lt;bors@rust-lang.org&gt;
Date:   Sun Jan 4 00:50:59 2015 +0000

    auto merge of #20490 : japaric/rust/assoc-types, r=aturon
    
    closes #20486
    closes #20474
    closes #20441
    
    [breaking-change]
    
    The `Index[Mut]` traits now have one less input parameter, as the return type of the indexing operation is an associated type. This breaks all existing implementations.
    
    ---
    
    binop traits (`Add`, `Sub`, etc) now have an associated type for their return type. Also, the RHS input parameter now defaults to `Self` (except for the `Shl` and `Shr` traits). For example, the `Add` trait now looks like this:
    
    ``` rust
    trait Add&lt;Rhs=Self&gt; {
        type Output;
    
        fn add(self, Rhs) -&gt; Self::Output;
    }
    ```
    
    The `Neg` and `Not` traits now also have an associated type for their return type.
    
    This breaks all existing implementations of these traits.
    
    ---
    Affected traits:
    
    - `Iterator { type Item }`
    - `IteratorExt` no input/output types, uses `&lt;Self as Iterator&gt;::Item` in its methods
    - `DoubleEndedIterator` no input/output types, uses `&lt;Self as Iterator&gt;::Item` in its methods
    - `DoubleEndedIteratorExt` no input/output types, uses `&lt;Self as Iterator&gt;::Item` in its methods
    - `RandomAccessIterator` no input/output types
    - `ExactSizeIterator` no input/output types, uses `&lt;Self as Iterator&gt;::Item` in its methods
    
    This breaks all the implementations of these traits.

commit f031285c3a76b86525695bbb5b46daa9e77df200
Author: Corey Farwell &lt;coreyf@rwell.org&gt;
Date:   Fri Jan 2 19:31:50 2015 -0800

    Remove graphviz::LabelText::* public reexport
    
    Part of #19253
    
    [breaking-change]

commit 9c3e6082e71618c088afd93f7a4a9a7708c9dcbd
Merge: a6b1097 d9769ec
Author: bors &lt;bors@rust-lang.org&gt;
Date:   Sat Jan 3 03:25:21 2015 +0000

    auto merge of #20154 : P1start/rust/qualified-assoc-type-generics, r=nikomatsakis
    
    This modifies `Parser::eat_lt` to always split up `&lt;&lt;`s, instead of doing so only when a lifetime name followed or the `force` parameter (now removed) was `true`. This is because `Foo&lt;&lt;TYPE` is now a valid start to a type, whereas previously only `Foo&lt;&lt;LIFETIME` was valid.
    
    This is a [breaking-change]. Change code that looks like this:
    
    ```rust
    let x = foo as bar &lt;&lt; 13;
    ```
    
    to use parentheses, like this:
    
    ```rust
    let x = (foo as bar) &lt;&lt; 13;
    ```
    
    Closes #17362.

commit 9ca8076cb77a7d7738162c80e1d240ef2ad0b73a
Merge: 073fd5b f9ce6f5
Author: Alex Crichton &lt;alex@alexcrichton.com&gt;
Date:   Fri Jan 2 09:22:37 2015 -0800

    rollup merge of #20386: frewsxcv/rm-reexports
    
    Part of #19253
    
    [breaking-change]

commit 56290a004493a5d2e211f056601533253497df60
Author: Alex Crichton &lt;alex@alexcrichton.com&gt;
Date:   Mon Dec 22 09:04:23 2014 -0800

    std: Stabilize the prelude module
    
    This commit is an implementation of [RFC 503][rfc] which is a stabilization
    story for the prelude. Most of the RFC was directly applied, removing reexports.
    Some reexports are kept around, however:
    
    * `range` remains until range syntax has landed to reduce churn.
    * `Path` and `GenericPath` remain until path reform lands. This is done to
      prevent many imports of `GenericPath` which will soon be removed.
    * All `io` traits remain until I/O reform lands so imports can be rewritten all
      at once to `std::io::prelude::*`.
    
    This is a breaking change because many prelude reexports have been removed, and
    the RFC can be consulted for the exact list of removed reexports, as well as to
    find the locations of where to import them.
    
    [rfc]: https://github.com/rust-lang/rfcs/blob/master/text/0503-prelude-stabilization.md
    [breaking-change]
    
    Closes #20068

commit 71b46b18a274edc7f7fb60b490e5ebbb9c911462
Merge: 1f887c8 8dbaa71
Author: bors &lt;bors@rust-lang.org&gt;
Date:   Fri Jan 2 15:51:25 2015 +0000

    auto merge of #20356 : Gankro/rust/stab, r=aturon
    
    This stabilizes most of libcollections, carefully avoiding sections of API which are being managed in other PRs. APIs which are not stable are marked explicitly unstable with a reason.
    
    Deprecates:
    
    * DList
      * rotate_forward
      * rotate_backward
      * prepend
      * insert_when
      * insert_ordered
      * merge
    
    * VecMap
      * update
      * update_with_key
    
    * Renames and newtypes the Bitv and BitvSet iterators to match conventions.
    
    * Removes the Copy impl from DList's Iter.
    
    as such this is a
    
    [breaking-change]

commit 7506fe52696c5b3b628f173d74dc4a13b5ccc1f3
Author: Nick Cameron &lt;ncameron@mozilla.com&gt;
Date:   Wed Dec 31 17:25:18 2014 +1300

    Accept `derive` instead of `deriving`
    
    [breaking-change]
    
    `deriving is still accepted, but gives a deprecation warning

commit 74d11d26f4042ce04c56edfd6caafa003383147d
Author: Nick Cameron &lt;ncameron@mozilla.com&gt;
Date:   Wed Dec 31 17:24:42 2014 +1300

    Accept `self` in place of `mod` in use items
    
    [breaking-change]
    
    `mod` is still accepted, but gives a deprecated warning

commit c61a0092bc236c4be4cb691fcd50ff50e91ab0d6
Author: Niko Matsakis &lt;niko@alum.mit.edu&gt;
Date:   Fri Dec 26 03:30:51 2014 -0500

    Fix orphan checking (cc #19470). (This is not a complete fix of #19470 because of the backwards compatibility feature gate.)
    
    This is a [breaking-change]. The new rules require that, for an impl of a trait defined
    in some other crate, two conditions must hold:
    
    1. Some type must be local.
    2. Every type parameter must appear "under" some local type.
    
    Here are some examples that are legal:
    
    ```rust
    struct MyStruct&lt;T&gt; { ... }
    
    // Here `T` appears "under' `MyStruct`.
    impl&lt;T&gt; Clone for MyStruct&lt;T&gt; { }
    
    // Here `T` appears "under' `MyStruct` as well. Note that it also appears
    // elsewhere.
    impl&lt;T&gt; Iterator&lt;T&gt; for MyStruct&lt;T&gt; { }
    ```
    
    Here is an illegal example:
    
    ```rust
    // Here `U` does not appear "under" `MyStruct` or any other local type.
    // We call `U` "uncovered".
    impl&lt;T,U&gt; Iterator&lt;U&gt; for MyStruct&lt;T&gt; { }
    ```
    
    There are a couple of ways to rewrite this last example so that it is
    legal:
    
    1. In some cases, the uncovered type parameter (here, `U`) should be converted
       into an associated type. This is however a non-local change that requires access
       to the original trait. Also, associated types are not fully baked.
    2. Add `U` as a type parameter of `MyStruct`:
       ```rust
       struct MyStruct&lt;T,U&gt; { ... }
       impl&lt;T,U&gt; Iterator&lt;U&gt; for MyStruct&lt;T,U&gt; { }
       ```
    3. Create a newtype wrapper for `U`
       ```rust
       impl&lt;T,U&gt; Iterator&lt;Wrapper&lt;U&gt;&gt; for MyStruct&lt;T,U&gt; { }
       ```
    
    Because associated types are not fully baked, which in the case of the
    `Hash` trait makes adhering to this rule impossible, you can
    temporarily disable this rule in your crate by using
    `#![feature(old_orphan_check)]`. Note that the `old_orphan_check`
    feature will be removed before 1.0 is released.

commit f2ccdfd8914b7b8f8f8f2053f9ecd98d54ef95a6
Author: Alex Crichton &lt;alex@alexcrichton.com&gt;
Date:   Thu Jan 1 22:24:06 2015 -0800

    std: Second pass stabilization for `boxed`
    
    This commit performs a second pass over the `std::boxed` module, taking the
    following actions:
    
    * `boxed` is now stable
    * `Box` is now stable
    * `BoxAny` is removed in favor of a direct `impl Box&lt;Any&gt;`
    * `Box::downcast` remains unstable while the name of the `downcast` family of
      methods is determined.
    
    This is a breaking change due to the removal of the `BoxAny` trait (note that
    the `downcast` method still exists), and existing consumers of `BoxAny` simply
    need to remove the import in their modules.
    
    [breaking-change]

commit e423fcf0e0166da55f88233e0be5eacba55bc0bc
Author: Alex Crichton &lt;alex@alexcrichton.com&gt;
Date:   Fri Dec 12 10:59:41 2014 -0800

    std: Enforce Unicode in fmt::Writer
    
    This commit is an implementation of [RFC 526][rfc] which is a change to alter
    the definition of the old `fmt::FormatWriter`. The new trait, renamed to
    `Writer`, now only exposes one method `write_str` in order to guarantee that all
    implementations of the formatting traits can only produce valid Unicode.
    
    [rfc]: https://github.com/rust-lang/rfcs/blob/master/text/0526-fmt-text-writer.md
    
    One of the primary improvements of this patch is the performance of the
    `.to_string()` method by avoiding an almost-always redundant UTF-8 check. This
    is a breaking change due to the renaming of the trait as well as the loss of the
    `write` method, but migration paths should be relatively easy:
    
    * All usage of `write` should move to `write_str`. If truly binary data was
      being written in an implementation of `Show`, then it will need to use a
      different trait or an altogether different code path.
    
    * All usage of `write!` should continue to work as-is with no modifications.
    
    * All usage of `Show` where implementations just delegate to another should
      continue to work as-is.
    
    [breaking-change]
    
    Closes #20352

commit f3a7ec7028c76b3a1c6051131328f372b068e33a
Author: Alex Crichton &lt;alex@alexcrichton.com&gt;
Date:   Mon Dec 29 15:03:01 2014 -0800

    std: Second pass stabilization of sync
    
    This pass performs a second pass of stabilization through the `std::sync`
    module, avoiding modules/types that are being handled in other PRs (e.g.
    mutexes, rwlocks, condvars, and channels).
    
    The following items are now stable
    
    * `sync::atomic`
    * `sync::atomic::ATOMIC_BOOL_INIT` (was `INIT_ATOMIC_BOOL`)
    * `sync::atomic::ATOMIC_INT_INIT` (was `INIT_ATOMIC_INT`)
    * `sync::atomic::ATOMIC_UINT_INIT` (was `INIT_ATOMIC_UINT`)
    * `sync::Once`
    * `sync::ONCE_INIT`
    * `sync::Once::call_once` (was `doit`)
      * C == `pthread_once(..)`
      * Boost == `call_once(..)`
      * Windows == `InitOnceExecuteOnce`
    * `sync::Barrier`
    * `sync::Barrier::new`
    * `sync::Barrier::wait` (now returns a `bool`)
    * `sync::Semaphore::new`
    * `sync::Semaphore::acquire`
    * `sync::Semaphore::release`
    
    The following items remain unstable
    
    * `sync::SemaphoreGuard`
    * `sync::Semaphore::access` - it's unclear how this relates to the poisoning
                                  story of mutexes.
    * `sync::TaskPool` - the semantics of a failing task and whether a thread is
                         re-attached to a thread pool are somewhat unclear, and the
                         utility of this type in `sync` is question with respect to
                         the jobs of other primitives. This type will likely become
                         stable or move out of the standard library over time.
    * `sync::Future` - futures as-is have yet to be deeply re-evaluated with the
                       recent core changes to Rust's synchronization story, and will
                       likely become stable in the future but are unstable until
                       that time comes.
    
    [breaking-change]

commit d45b5d2ed9b43b3ad573482fb8820a382f20289e
Author: Nick Cameron &lt;ncameron@mozilla.com&gt;
Date:   Tue Dec 30 19:55:06 2014 +1300

    Disallow [_, ..n] syntax for fixed length arrays and repeating array constructors
    
    Closes #19999
    
    [breaking-change]
    
    Use [_; n] instead.

commit 39d74026663597a8d4ad0ab04e6d117bf9fd6ad4
Merge: c594959 41da99d
Author: bors &lt;bors@rust-lang.org&gt;
Date:   Thu Jan 1 15:51:08 2015 +0000

    auto merge of #20190 : cmr/rust/gate-macro-args, r=alexcrichton
    
    Uses the same approach as https://github.com/rust-lang/rust/pull/17286 (and
    subsequent changes making it more correct), where the visitor will skip any
    pieces of the AST that are from "foreign code", where the spans don't line up,
    indicating that that piece of code is due to a macro expansion.
    
    If this breaks your code, read the error message to determine which feature
    gate you should add to your crate.
    
    Closes #18102
    
    [breaking-change]

commit 41da99dff417eadf8f296a93529d9810f79e1d1b
Author: Corey Richardson &lt;corey@octayn.net&gt;
Date:   Wed Dec 24 00:44:13 2014 -0500

    Feature gate macro arguments
    
    Uses the same approach as https://github.com/rust-lang/rust/pull/17286 (and
    subsequent changes making it more correct), where the visitor will skip any
    pieces of the AST that are from "foreign code", where the spans don't line up,
    indicating that that piece of code is due to a macro expansion.
    
    If this breaks your code, read the error message to determine which feature
    gate you should add to your crate, and bask in the knowledge that your code
    won't mysteriously break should you try to use the 1.0 release.
    
    Closes #18102
    
    [breaking-change]

commit 47b8479e73e40395f1b1b2d0c6281f28f80301e4
Merge: 7d4f487 10bbf69
Author: bors &lt;bors@rust-lang.org&gt;
Date:   Thu Jan 1 04:01:02 2015 +0000

    auto merge of #20363 : japaric/rust/moar-uc, r=nmatsakis
    
    The the last argument of the `ItemDecorator::expand` method has changed to `Box&lt;FnMut&gt;`. Syntax extensions will break.
    
    [breaking-change]
    
    ---
    
    This PR removes pretty much all the remaining uses of boxed closures from the libraries. There are still boxed closures under the `test` directory, but I think those should be removed or replaced with unboxed closures at the same time we remove boxed closures from the language.
    
    In a few places I had to do some contortions (see the first commit for an example) to work around issue #19596. I have marked those workarounds with FIXMEs. In the future when `&amp;mut F where F: FnMut` implements the `FnMut` trait, we should be able to remove those workarounds. I've take care to avoid placing the workaround functions in the public API.
    
    Since `let f = || {}` always gets type checked as a boxed closure, I have explictly annotated those closures (with e.g. `|&amp;:| {}`) to force the compiler to type check them as unboxed closures.
    
    Instead of removing the type aliases (like `GetCrateDataCb`), I could have replaced them with newtypes. But this seemed like overcomplicating things for little to no gain.
    
    I think we should be able to remove the boxed closures from the languge after this PR lands. (I'm being optimistic here)
    
    r? @alexcrichton or @aturon
    cc @nikomatsakis

commit f9ce6f5ba458d6a3d4e63b282bac43a18e90aeb0
Author: Corey Farwell &lt;coreyf@rwell.org&gt;
Date:   Wed Dec 31 19:10:43 2014 -0800

    Remove core::iter::MinMaxResult::* public reexport
    
    Part of #19253
    
    [breaking-change]

commit a6f5b980cc44621efeed847e8d359f3b90c29080
Author: Alex Crichton &lt;alex@alexcrichton.com&gt;
Date:   Wed Dec 31 15:10:45 2014 -0800

    rustc: Re-jigger -L and -l for MSYS compatibility
    
    As discovered in #20376, the MSYS shell will silently rewrite arguemnts that
    look like unix paths into their windows path counterparts for compatibility, but
    the recently added `:kind` syntax added to the `-L` flag does not allow for this
    form of rewriting. This means that the syntax can be difficult to use at an MSYS
    prompt, as well as causing tests to fail when run manuall right now.
    
    This commit takes the other option presented in the original issue to prefix the
    path with `kind=` instead of suffixing it with `:kind`. For consistence, the
    `-l` flag is also now migrating to `kind=name`.
    
    This is a breaking change due to the *removal* of behavior with `-L`. All code
    using `:kind` should now pass `kind=` for `-L` arguments. This is not currently,
    but will become, a breaking change for `-l` flags. The old `name:kind` syntax is
    still accepted, but all code should update to `kind=name`.
    
    [breaking-change]
    Closes #20376

commit 38f9805f11721d854a59818e0ad7b8a0b6282301
Merge: 04f4221 1d26fb9
Author: Alex Crichton &lt;alex@alexcrichton.com&gt;
Date:   Tue Dec 30 16:26:22 2014 -0800

    rollup merge of #20348: frewsxcv/rm-reexports
    
    Part of #19253
    
    [breaking-change]

commit b94bcbf56eab163517e8ffc93888284b8dbb6238
Author: Aaron Turon &lt;aturon@mozilla.com&gt;
Date:   Tue Dec 30 14:44:26 2014 -0800

    Stabilize cmp
    
    This patch marks `PartialEq`, `Eq`, `PartialOrd`, and `Ord` as
    `#[stable]`, as well as the majorify of manual implementaitons of these
    traits. The traits match the [reform
    RFC](https://github.com/rust-lang/rfcs/pull/439).
    
    Along the way, two changes are made:
    
    * The recently-added type parameters for `Ord` and `Eq` are
      removed. These were mistakenly added while adding them to `PartialOrd`
      and `PartialEq`, but they don't make sense given the laws that are
      required for (and use cases for) `Ord` and `Eq`.
    
    * More explicit laws are added for `PartialEq` and `PartialOrd`,
      connecting them to their associated mathematical concepts.
    
    In the future, many of the impls should be generalized; see
    since generalizing later is not a breaking change.
    
    [breaking-change]

commit e91d810b9b36d6bb163970cd0e8bbf4692f704bb
Author: Aaron Turon &lt;aturon@mozilla.com&gt;
Date:   Sun Nov 2 20:27:46 2014 -0800

    Libs: Unify concat and concat_vec
    
    We've long had traits `StrVector` and `VectorVector` providing
    `concat`/`connect` and `concat_vec`/`connect_vec` respectively. The
    reason for the distinction is that coherence rules did not used to be
    robust enough to allow impls on e.g. `Vec&lt;String&gt;` versus `Vec&lt;&amp;[T]&gt;`.
    
    This commit consolidates the traits into a single `SliceConcatExt` trait
    provided by `slice` and the preldue (where it replaces `StrVector`,
    which is removed.)
    
    [breaking-change]

commit 4f863a338e0a7c33f81a8ac138103f1a0e8b33c5
Author: Aaron Turon &lt;aturon@mozilla.com&gt;
Date:   Wed Dec 17 20:50:16 2014 -0800

    Second pass stabilization: slice
    
    This commit takes a second pass through the `slice` module to
    stabilize its API. The changes are as follows:
    
    **Stable**:
    
    * `as_mut_slice`
    * `as_ptr`, `as_mut_ptr`
    * `binary_search_by` (was: `binary_search`)
    * `binary_search` (was: `binary_search_elem`)
    * `chunks`, `chunks_mut`
    * `contains`
    * `ends_with`
    * `first`, `first_mut` (was: `head`)
    * `get_unchecked`, `get_unchecked_mut` (was: `unsafe_get`)
    * `get`
    * `is_empty`
    * `iter`, `iter_mut`
    * `len`
    * `reverse`
    * `sort_by`
    * `sort`
    * `split_at`, `split_at_mut`
    * `split_mut`, `splitn_mut`, `rsplitn_mut`
    * `split`, `splitn`, `rsplitn`
    * `starts_with`
    * `swap`
    * `to_vec`
    * `windows`
    
    **Deprecated**:
    
    * `head`, `head_mut` (renamed as above)
    * `unsafe_get`, `unsafe_mut` (renamed as above)
    * `binary_search_elem` (renamed as above)
    * `partitioned`, deprecated in favor of a new, more
      general iterator consumer called `partition`.
    * `BinarySearchResult`, deprecated in favor of `Result&lt;uint, uint&gt;`
    
    [breaking-change]

commit 9d919d2302b5df42e3bf8979560e0da21f4b2bad
Author: Aaron Turon &lt;aturon@mozilla.com&gt;
Date:   Tue Dec 16 23:44:43 2014 -0800

    Second pass stabilization: vec
    
    This commit takes a second pass through the `vec` module to
    stabilize its API. The changes are as follows:
    
    **Stable**:
    
    * `dedup`
    * `from_raw_parts`
    * `insert`
    * `into_iter`
    * `is_empty`
    * `remove`
    * `reserve_exact`
    * `reserve`
    * `retain`
    * `swap_remove`
    * `truncate`
    
    **Deprecated**:
    
    * `from_fn`, `from_elem`, `grow_fn` and `grow`, all deprecated in
      favor of iterators. See https://github.com/rust-lang/rfcs/pull/509
    
    * `partition`, `partitioned`, deprecated in favor of a new, more
      general iterator consumer called `partition`.
    
    * `unzip`, deprecated in favor of a new, more general iterator
      consumer called `unzip`.
    
    A few remaining methods are left at experimental status.
    
    [breaking-change]

commit 1d26fb9e07e664b312ca9d7b666f6d1dd52285ed
Author: Corey Farwell &lt;coreyf@rwell.org&gt;
Date:   Tue Dec 30 10:19:20 2014 -0800

    Remove core::atomic::Ordering::* public reexport
    
    Part of #19253
    
    [breaking-change]

commit 79db01a30d22950ad1597d495b76d2f58da859dc
Merge: 806cb35 b26daf3
Author: Alex Crichton &lt;alex@alexcrichton.com&gt;
Date:   Mon Dec 29 16:36:52 2014 -0800

    rollup merge of #20306: alexcrichton/second-pass-string
    
    This commit performs a second pass over the `std::string` module, performing the
    following actions:
    
    * The name `std::string` is now stable.
    * The `String::from_utf8` function is now stable after having been altered to
      return a new `FromUtf8Error` structure. The `FromUtf8Error` structure is now
      stable as well as its `into_bytes` and `utf8_error` methods.
    * The `String::from_utf8_lossy` function is now stable.
    * The `String::from_chars` method is now deprecated in favor of `.collect()`
    * The `String::from_raw_parts` method is now stable
    * The `String::from_str` function remains experimental
    * The `String::from_raw_buf` function remains experimental
    * The `String::from_raw_buf_len` function remains experimental
    * The `String::from_utf8_unchecked` function is now stable
    * The `String::from_char` function is now deprecated in favor of
      `repeat(c).take(n).collect()`
    * The `String::grow` function is now deprecated in favor of
      `.extend(repeat(c).take(n)`
    * The `String::capacity` method is now stable
    * The `String::reserve` method is now stable
    * The `String::reserve_exact` method is now stable
    * The `String::shrink_to_fit` method is now stable
    * The `String::pop` method is now stable
    * The `String::as_mut_vec` method is now stable
    * The `String::is_empty` method is now stable
    * The `IntoString` trait is now deprecated (there are no implementors)
    * The `String::truncate` method is now stable
    * The `String::insert` method is now stable
    * The `String::remove` method is now stable
    * The `String::push` method is now stable
    * The `String::push_str` method is now stable
    * The `String::from_utf16` function is now stable after its error type has now
      become an opaque structure to carry more semantic information in the future.
    
    A number of these changes are breaking changes, but the migrations should be
    fairly straightforward on a case-by-case basis (outlined above where possible).
    
    [breaking-change]

commit 748440c5b3bad8a837918400973e9d6cbb58fa7a
Merge: 9f6eb29 6256973
Author: Alex Crichton &lt;alex@alexcrichton.com&gt;
Date:   Mon Dec 29 16:36:06 2014 -0800

    rollup merge of #20215: csouth3/hashmap-rename
    
    Rename struct `Entries` to `Iter` in hash/table.rs and hash/map.rs, to match the naming convention of rust-lang/rfcs#344.
    
    This is a [breaking-change].

commit cc20d6009ebf46b7ec75020ebfe35ff0ef064d1b
Merge: 94d82c1 35e63e3
Author: Alex Crichton &lt;alex@alexcrichton.com&gt;
Date:   Mon Dec 29 16:35:50 2014 -0800

    rollup merge of #19661: alexcrichton/mutex-result
    
    All of the current std::sync primitives have poisoning enable which means that
    when a task fails inside of a write-access lock then all future attempts to
    acquire the lock will fail. This strategy ensures that stale data whose
    invariants are possibly not upheld are never viewed by other tasks to help
    propagate unexpected panics (bugs in a program) among tasks.
    
    Currently there is no way to test whether a mutex or rwlock is poisoned. One
    method would be to duplicate all the methods with a sister foo_catch function,
    for example. This pattern is, however, against our [error guidelines][errors].
    As a result, this commit exposes the fact that a task has failed internally
    through the return value of a `Result`.
    
    [errors]: https://github.com/rust-lang/rfcs/blob/master/text/0236-error-conventions.md#do-not-provide-both-result-and-fail-variants
    
    All methods now return a `LockResult&lt;T&gt;` or a `TryLockResult&lt;T&gt;` which
    communicates whether the lock was poisoned or not. In a `LockResult`, both the
    `Ok` and `Err` variants contains the `MutexGuard&lt;T&gt;` that is being returned in
    order to allow access to the data if poisoning is not desired. This also means
    that the lock is *always* held upon returning from `.lock()`.
    
    A new type, `PoisonError`, was added with one method `into_guard` which can
    consume the assertion that a lock is poisoned to gain access to the underlying
    data.
    
    This is a breaking change because the signatures of these methods have changed,
    often incompatible ways. One major difference is that the `wait` methods on a
    condition variable now consume the guard and return it in as a `LockResult` to
    indicate whether the lock was poisoned while waiting. Most code can be updated
    by calling `.unwrap()` on the return value of `.lock()`.
    
    [breaking-change]

commit 4e2afb0052618ca3d758fffd0cf50559be774391
Author: Nick Cameron &lt;ncameron@mozilla.com&gt;
Date:   Fri Dec 19 11:47:48 2014 +1300

    Remove ExprSlice by hacking the compiler
    
    [breaking-change]
    
    The `mut` in slices is now redundant. Mutability is 'inferred' from position. This means that if mutability is only obvious from the type, you will need to use explicit calls to the slicing methods.

commit b26daf3a67a4e283a5e2c49227b60a2321434de0
Author: Alex Crichton &lt;alex@alexcrichton.com&gt;
Date:   Sun Dec 28 10:29:56 2014 -0800

    std: Second pass stabilization for `string`
    
    This commit performs a second pass over the `std::string` module, performing the
    following actions:
    
    * The name `std::string` is now stable.
    * The `String::from_utf8` function is now stable after having been altered to
      return a new `FromUtf8Error` structure. The `FromUtf8Error` structure is now
      stable as well as its `into_bytes` and `utf8_error` methods.
    * The `String::from_utf8_lossy` function is now stable.
    * The `String::from_chars` method is now deprecated in favor of `.collect()`
    * The `String::from_raw_parts` method is now stable
    * The `String::from_str` function remains experimental
    * The `String::from_raw_buf` function remains experimental
    * The `String::from_raw_buf_len` function remains experimental
    * The `String::from_utf8_unchecked` function is now stable
    * The `String::from_char` function is now deprecated in favor of
      `repeat(c).take(n).collect()`
    * The `String::grow` function is now deprecated in favor of
      `.extend(repeat(c).take(n)`
    * The `String::capacity` method is now stable
    * The `String::reserve` method is now stable
    * The `String::reserve_exact` method is now stable
    * The `String::shrink_to_fit` method is now stable
    * The `String::pop` method is now stable
    * The `String::as_mut_vec` method is now stable
    * The `String::is_empty` method is now stable
    * The `IntoString` trait is now deprecated (there are no implementors)
    * The `String::truncate` method is now stable
    * The `String::insert` method is now stable
    * The `String::remove` method is now stable
    * The `String::push` method is now stable
    * The `String::push_str` method is now stable
    * The `String::from_utf16` function is now stable after its error type has now
      become an opaque structure to carry more semantic information in the future.
    
    A number of these changes are breaking changes, but the migrations should be
    fairly straightforward on a case-by-case basis (outlined above where possible).
    
    [breaking-change]

commit bc83a009f655dd3896be4a7cd33cac8032a605f2
Author: Alex Crichton &lt;alex@alexcrichton.com&gt;
Date:   Tue Dec 23 11:53:35 2014 -0800

    std: Second pass stabilization for `comm`
    
    This commit is a second pass stabilization for the `std::comm` module,
    performing the following actions:
    
    * The entire `std::comm` module was moved under `std::sync::mpsc`. This movement
      reflects that channels are just yet another synchronization primitive, and
      they don't necessarily deserve a special place outside of the other
      concurrency primitives that the standard library offers.
    * The `send` and `recv` methods have all been removed.
    * The `send_opt` and `recv_opt` methods have been renamed to `send` and `recv`.
      This means that all send/receive operations return a `Result` now indicating
      whether the operation was successful or not.
    * The error type of `send` is now a `SendError` to implement a custom error
      message and allow for `unwrap()`. The error type contains an `into_inner`
      method to extract the value.
    * The error type of `recv` is now `RecvError` for the same reasons as `send`.
    * The `TryRecvError` and `TrySendError` types have had public reexports removed
      of their variants and the variant names have been tweaked with enum
      namespacing rules.
    * The `Messages` iterator is renamed to `Iter`
    
    This functionality is now all `#[stable]`:
    
    * `Sender`
    * `SyncSender`
    * `Receiver`
    * `std::sync::mpsc`
    * `channel`
    * `sync_channel`
    * `Iter`
    * `Sender::send`
    * `Sender::clone`
    * `SyncSender::send`
    * `SyncSender::try_send`
    * `SyncSender::clone`
    * `Receiver::recv`
    * `Receiver::try_recv`
    * `Receiver::iter`
    * `SendError`
    * `RecvError`
    * `TrySendError::{mod, Full, Disconnected}`
    * `TryRecvError::{mod, Empty, Disconnected}`
    * `SendError::into_inner`
    * `TrySendError::into_inner`
    
    This is a breaking change due to the modification of where this module is
    located, as well as the changing of the semantics of `send` and `recv`. Most
    programs just need to rename imports of `std::comm` to `std::sync::mpsc` and
    add calls to `unwrap` after a send or a receive operation.
    
    [breaking-change]

commit 19f73b4ef6fb1d24f19738a8665889396fc1b0c8
Merge: 3dcc409 c1f3aca
Author: bors &lt;bors@rust-lang.org&gt;
Date:   Mon Dec 29 18:02:30 2014 +0000

    auto merge of #20058 : Kimundi/rust/str_pattern_pre, r=alexcrichton
    
    This stabilizes most methods on `&amp;str` working with patterns in a way that is forwards-compatible with a generic string pattern matching API:
    - Methods that are using the primary name for their operation are marked as `#[stable]`, as they can be upgraded to a full `Pattern` API later without existing code breaking. Example: `contains(&amp;str)`
    - Methods that are using a more specific name in order to not clash with the primary one are marked as `#[unstable]`, as they will likely be removed once their functionality is merged into the primary one. Example: `contains_char&lt;C: CharEq&gt;(C)`
    - The method docs got changed to consistently refer to the pattern types as a pattern.
    - Methods whose names do not match in the context of the more generic API got renamed. Example: `trim_chars -&gt; trim_matches`
    
    Additionally, all methods returning iterators got changed to return unique new types with changed names in accordance with the new naming guidelines.
    
    See also https://github.com/rust-lang/rfcs/pull/528
    
    Due to some deprecations and type changes, this is a
    
    [breaking-change]

commit 76e5ed655c762b812c3da4749a55f1bb1b52c787
Author: Alex Crichton &lt;alex@alexcrichton.com&gt;
Date:   Mon Dec 8 20:20:03 2014 -0800

    std: Return Result from RWLock/Mutex methods
    
    All of the current std::sync primitives have poisoning enable which means that
    when a task fails inside of a write-access lock then all future attempts to
    acquire the lock will fail. This strategy ensures that stale data whose
    invariants are possibly not upheld are never viewed by other tasks to help
    propagate unexpected panics (bugs in a program) among tasks.
    
    Currently there is no way to test whether a mutex or rwlock is poisoned. One
    method would be to duplicate all the methods with a sister foo_catch function,
    for example. This pattern is, however, against our [error guidelines][errors].
    As a result, this commit exposes the fact that a task has failed internally
    through the return value of a `Result`.
    
    [errors]: https://github.com/rust-lang/rfcs/blob/master/text/0236-error-conventions.md#do-not-provide-both-result-and-fail-variants
    
    All methods now return a `LockResult&lt;T&gt;` or a `TryLockResult&lt;T&gt;` which
    communicates whether the lock was poisoned or not. In a `LockResult`, both the
    `Ok` and `Err` variants contains the `MutexGuard&lt;T&gt;` that is being returned in
    order to allow access to the data if poisoning is not desired. This also means
    that the lock is *always* held upon returning from `.lock()`.
    
    A new type, `PoisonError`, was added with one method `into_guard` which can
    consume the assertion that a lock is poisoned to gain access to the underlying
    data.
    
    This is a breaking change because the signatures of these methods have changed,
    often incompatible ways. One major difference is that the `wait` methods on a
    condition variable now consume the guard and return it in as a `LockResult` to
    indicate whether the lock was poisoned while waiting. Most code can be updated
    by calling `.unwrap()` on the return value of `.lock()`.
    
    [breaking-change]

commit c32d03f4172580e3f33e4844ed3c01234dca2d53
Author: Alex Crichton &lt;alex@alexcrichton.com&gt;
Date:   Mon Dec 22 09:04:23 2014 -0800

    std: Stabilize the prelude module
    
    This commit is an implementation of [RFC 503][rfc] which is a stabilization
    story for the prelude. Most of the RFC was directly applied, removing reexports.
    Some reexports are kept around, however:
    
    * `range` remains until range syntax has landed to reduce churn.
    * `Path` and `GenericPath` remain until path reform lands. This is done to
      prevent many imports of `GenericPath` which will soon be removed.
    * All `io` traits remain until I/O reform lands so imports can be rewritten all
      at once to `std::io::prelude::*`.
    
    This is a breaking change because many prelude reexports have been removed, and
    the RFC can be consulted for the exact list of removed reexports, as well as to
    find the locations of where to import them.
    
    [rfc]: https://github.com/rust-lang/rfcs/blob/master/text/0503-prelude-stabilization.md
    [breaking-change]
    
    Closes #20068

commit f53314cd70dd194ea40c55a5d8ceae7b94409aea
Author: Nick Cameron &lt;ncameron@mozilla.com&gt;
Date:   Mon Dec 29 09:33:25 2014 +1300

    Remove the glob/shadowing exception bug
    
    [breaking-change]
    
    This and the other commit in this PR change the rules for shadowing and globs to be
    stricter. There were previously bugs where some glob imports would not be checked
    for shadowing. Those are now fixed and you may have to adjust your imports to use
    fewer globs.

commit 1e89bbcb67020892bc0af5af218c35f0fd453fa4
Author: Simonas Kazlauskas &lt;git@kazlauskas.me&gt;
Date:   Sun Dec 28 02:20:47 2014 +0200

    Rename TaskRng to ThreadRng
    
    Since runtime is removed, rust has no tasks anymore and everything is moving
    from being task-* to thread-*. Let’s rename TaskRng as well!
    
    * Rename TaskRng to ThreadRng
    * Rename task_rng to thread_rng
    
    [breaking-change]

commit 3e6b29f8ad1ddfcb134d743a66ee5f467e16c350
Merge: 070ab63 647e54d
Author: bors &lt;bors@rust-lang.org&gt;
Date:   Sun Dec 28 03:11:48 2014 +0000

    auto merge of #20136 : eddyb/rust/format-args, r=alexcrichton
    
    We have the technology: no longer do you need to write closures to use `format_args!`.
    This is a `[breaking-change]`, as it forces you to clean up old hacks - if you had code like this:
    ```rust
    format_args!(fmt::format, "{} {} {}", a, b, c)
    format_args!(|args| { w.write_fmt(args) }, "{} {} {}", x, y, z)
    ```
    change it to this:
    ```rust
    fmt::format(format_args!("{} {} {}", a, b, c))
    w.write_fmt(format_args!("{} {} {}", x, y, z))
    ```
    To allow them to be called with `format_args!(...)` directly, several functions were modified to
    take `fmt::Arguments` by value instead of by reference. Also, `fmt::Arguments` derives `Copy`
    now in order to preserve all usecases that were previously possible.

commit 070ab63807dc80fa6a6c5ee80531284761ab42de
Merge: 0201334 12e6071
Author: bors &lt;bors@rust-lang.org&gt;
Date:   Sat Dec 27 21:51:43 2014 +0000

    auto merge of #19916 : SimonSapin/rust/ascii-reform, r=sfackler
    
    Implements [RFC 486](https://github.com/rust-lang/rfcs/pull/486). Fixes #19908.
    
    * Rename `to_ascii_{lower,upper}` to `to_ascii_{lower,upper}case`, per #14401
    * Remove the `Ascii` type and associated traits: `AsciiCast`, `OwnedAsciiCast`, `AsciiStr`, `IntoBytes`, and `IntoString`.
    * As a replacement, add `.is_ascii()` to `AsciiExt`, and implement `AsciiExt` for `u8` and `char`.
    
    [breaking-change]

commit df0c6d93852c51b6936d4b72b6b4be5f1932fb8a
Author: Nick Cameron &lt;ncameron@mozilla.com&gt;
Date:   Sun Nov 23 22:29:41 2014 +1300

    save-analysis: emit names of items that a glob import actually imports.
    
    There is also some work here to make resolve a bit more stable - it no longer overwrites a specific import with a glob import.
    
    [breaking-change]
    
    Import shadowing of single/list imports by globs is now forbidden. An interesting case is where a glob import imports a re-export (`pub use`) of a single import. This still counts as a single import for the purposes of shadowing .You can usually fix any bustage by re-ordering such imports. A single import may still shadow (override) a glob import or the prelude.

commit 3a6ccdc263d9a169c2d317a6f78664e1f18d3b15
Author: Simon Sapin &lt;simon.sapin@exyr.org&gt;
Date:   Sun Dec 7 01:55:34 2014 +0000

    Remove Ascii, AsciiCast, OwnedAsciiCast, AsciiStr, IntoBytes, IntoString.
    
    As a replacement, add is_ascii() to AsciiExt, and implement AsciiExt for u8 and char.
    
    [breaking-change]

commit d9769ec3834b62318da892925dc24c8883bb1635
Author: P1start &lt;rewi-github@whanau.org&gt;
Date:   Tue Dec 23 13:13:49 2014 +1300

    Parse fully-qualified associated types in generics without whitespace
    
    This breaks code that looks like this:
    
        let x = foo as bar &lt;&lt; 13;
    
    Change such code to look like this:
    
        let x = (foo as bar) &lt;&lt; 13;
    
    Closes #17362.
    
    [breaking-change]

commit 625697354db8a13450f6d56c7a384c202a79c9db
Author: Chase Southwood &lt;chase.southwood@gmail.com&gt;
Date:   Wed Dec 24 20:19:48 2014 -0600

    Rename remaining hashmap and hashtable iterators to match naming
    conventions.
    
    This is a [breaking-change].

commit 7e11b22713aebd28ceaaa2ecef937c9b9d247c2f
Merge: 14597f9 85c1a4b
Author: bors &lt;bors@rust-lang.org&gt;
Date:   Wed Dec 24 20:47:12 2014 +0000

    auto merge of #20117 : lfairy/rust/rename-include-bin, r=alexcrichton
    
    According to [RFC 344][], methods that return `&amp;[u8]` should have names ending in `bytes`. Though `include_bin!` is a macro not a method, it seems reasonable to follow the convention anyway.
    
    We keep the old name around for now, but trigger a deprecation warning when it is used.
    
    [RFC 344]: https://github.com/rust-lang/rfcs/blob/master/text/0344-conventions-galore.md
    
    [breaking-change]

commit 1e5811ef9271644db0d0ddaae351976b0d4abdd2
Author: Simon Sapin &lt;simon.sapin@exyr.org&gt;
Date:   Fri Dec 5 09:57:42 2014 -0800

    Rename to_ascii_{lower,upper} to to_ascii_{lower,upper}case, per #14401
    
    [breaking-change]

commit 96a3c7c6a051ab2f5fc01fe9e686f7fffcc87c61
Merge: d10642e 16f01cc
Author: bors &lt;bors@rust-lang.org&gt;
Date:   Tue Dec 23 22:21:10 2014 +0000

    auto merge of #19758 : tbu-/rust/pr_fp_name, r=alexcrichton
    
    This is a [breaking-change].

commit 16f01cc13f6a092873096c44eed546561b88d245
Author: Tobias Bucher &lt;tobiasbucher5991@gmail.com&gt;
Date:   Mon Dec 22 22:50:57 2014 +0100

    Rename and namespace `FPCategory`
    
    Rename `FPCategory` to `FpCategory` and `Fp* to `*` in order to adhere to the
    naming convention
    
    This is a [breaking-change].
    
    Existing code like this:
    ```
    use std::num::{FPCategory, FPNaN};
    ```
    should be adjusted to this:
    ```
    use std::num::FpCategory as Fp
    ```
    
    In the following code you can use the constants `Fp::Nan`, `Fp::Normal`, etc.

commit 85c1a4b1ba09dae786b3554e0ab596814efabe0e
Author: Chris Wong &lt;lambda.fairy@gmail.com&gt;
Date:   Mon Dec 22 10:57:09 2014 +1300

    Rename include_bin! to include_bytes!
    
    According to [RFC 344][], methods that return `&amp;[u8]` should have names
    ending in `bytes`. Though `include_bin!` is a macro not a method, it
    seems reasonable to follow the convention anyway.
    
    We keep the old name around for now, but trigger a deprecation warning
    when it is used.
    
    [RFC 344]: https://github.com/rust-lang/rfcs/blob/master/text/0344-conventions-galore.md
    
    [breaking-change]

commit fac17defcb8d0642c25bf8f791e1dc5b4e110be8
Merge: ca441df 02feaf2
Author: Alex Crichton &lt;alex@alexcrichton.com&gt;
Date:   Mon Dec 22 12:48:16 2014 -0800

    rollup merge of #20140: frewsxcv/rm-reexports
    
    Part of #19253
    
    I would have removed this public reexport in #19842, but #19812 hadn't merged (and snapshotted) at the time
    
    In #19407, I changed the codebase to stop utilizing this reexport
    
    [breaking-change]

commit 4baeacef5a539fa29b88c951d6eca996d6101148
Merge: 7311b63 ee9de3b
Author: Alex Crichton &lt;alex@alexcrichton.com&gt;
Date:   Mon Dec 22 12:47:31 2014 -0800

    rollup merge of #20075: skade/remove-notrust
    
    Internally refactor all mentions of `notrust` to the
    positive statement `rust`.
    
    [breaking-change] Change remaining `notrust` markers to
    the thing they actually represent, e.g. `sh` or `plain`.
    
    This supersedes #19693 .

commit 7311b6347de4205b71e8a221140a527e789fd353
Merge: b04bc5c abf492d
Author: Alex Crichton &lt;alex@alexcrichton.com&gt;
Date:   Mon Dec 22 12:47:11 2014 -0800

    rollup merge of #20053: csouth3/misc-stab
    
    This pull request:
    
    *Renames `BinaryHeap::top` to `BinaryHeap::peek`
    *Stabilizes `front/back/front_mut/back_mut` in `DList` and `RingBuf`
    *Stabilizes `swap` in `RingBuf`
    
    in accordance with rust-lang/rfcs#509.
    
    Note that this PR does not address `Bitv::{get,set}` or HashMap's iterators, nor does it move `std::vec` to `std::collections::vec`, all of which still need to be done.
    
    Because of the method renaming, this is a [breaking-change].

commit b04bc5cc49a398df712092a68ab9ad83019498ad
Merge: 9b99436 a76a802
Author: Alex Crichton &lt;alex@alexcrichton.com&gt;
Date:   Mon Dec 22 12:46:31 2014 -0800

    rollup merge of #20033: alexcrichton/deprecate-serialise
    
    This commit completes the deprecation story for the in-tree serialization
    library. The compiler will now emit a warning whenever it encounters
    `deriving(Encodable)` or `deriving(Decodable)`, and the library itself is now
    marked `#[unstable]` for when feature staging is enabled.
    
    All users of serialization can migrate to the `rustc-serialize` crate on
    crates.io which provides the exact same interface as the libserialize library
    in-tree. The new deriving modes are named `RustcEncodable` and `RustcDecodable`
    and require `extern crate "rustc-serialize" as rustc_serialize` at the crate
    root in order to expand correctly.
    
    To migrate all crates, add the following to your `Cargo.toml`:
    
        [dependencies]
        rustc-serialize = "0.1.1"
    
    And then add the following to your crate root:
    
        extern crate "rustc-serialize" as rustc_serialize;
    
    Finally, rename `Encodable` and `Decodable` deriving modes to `RustcEncodable`
    and `RustcDecodable`.
    
    [breaking-change]

commit 2f55a9db0de8b2a2d72c7139eae38272d4d8cf41
Merge: 34d6800 20d7a5f
Author: Alex Crichton &lt;alex@alexcrichton.com&gt;
Date:   Mon Dec 22 12:45:52 2014 -0800

    rollup merge of #19216: Gankro/bitv
    
    Part of #18424
    
    This commit changes the semantics of `reserve` and `capacity` for Bitv and BitvSet to match conventions. It also introduces the notion of `reserve_index` and `reserve_index_exact` for collections with maximum-index-based capacity semantics.
    
    Deprecates free function constructors in favour of functions on Bitv itself.
    
    Changes `Bitv::pop` to return an Option rather than panicking.
    
    Deprecates and renames several methods in favour of conventions.
    
    Marks several blessed methods as unstable.
    
    This commit also substantially refactors Bitv and BitvSet's implementations. The new implementation is simpler, cleaner, better documented, and more robust against overflows. It also reduces coupling between Bitv and BitvSet. Tests have been seperated into seperate submodules.
    
    Fixes #16958
    
    [breaking-change]

commit 02feaf2a804e4e810d5a3adbedbcbe3905692286
Author: Corey Farwell &lt;coreyf@rwell.org&gt;
Date:   Mon Dec 22 11:09:55 2014 -0800

    Remove cmp::Ordering::* public reexport
    
    Part of #19253
    
    I would have removed this public reexport in #19842, but #19812 hadn't merged (and snapshotted) at the time
    
    In #19407, I changed the codebase to stop utilizing this reexport
    
    [breaking-change]

commit 22050e3ed44d9b4d79edced506b470a425e0d302
Author: Florian Wilkens &lt;floya@live.de&gt;
Date:   Sat Dec 20 15:28:20 2014 +0100

    Added missing renames:
    
    libcollections:
        AbsEntries -&gt; AbsIter, Entries -&gt; Iter, MoveEntries -&gt; IntoIter, MutEntries -&gt; IterMut
        DifferenceItems -&gt; Difference, SymDifferenceItems -&gt; SymmetricDifference, IntersectionItems -&gt; Intersection, UnionItems -&gt; Union
    
    libstd/hash/{table, map}:
        Entries -&gt; Iter, MoveItems -&gt; IntoIter, MutEntries -&gt; IterMut
    
    Also a [breaking-change].

commit f8cfd2480b69a1cc266fc91d0b60c825a9dc18a7
Author: Florian Wilkens &lt;floya@live.de&gt;
Date:   Fri Dec 19 21:52:10 2014 +0100

    Renaming of the Iter types as in RFC #344
    
    libcore: slice::Items -&gt; slice::Iter, slice::MutItems -&gt; slice::IterMut
    libcollections: *::Items -&gt; *::Iter, *::MoveItems -&gt; *::IntoIter, *::MutItems -&gt; *::IterMut
    
    This is of course a [breaking-change].

commit a76a80276852f05f30adaa4d2a8a2729b5fc0bfa
Author: Alex Crichton &lt;alex@alexcrichton.com&gt;
Date:   Thu Dec 18 22:52:48 2014 -0800

    serialize: Fully deprecate the library
    
    This commit completes the deprecation story for the in-tree serialization
    library. The compiler will now emit a warning whenever it encounters
    `deriving(Encodable)` or `deriving(Decodable)`, and the library itself is now
    marked `#[unstable]` for when feature staging is enabled.
    
    All users of serialization can migrate to the `rustc-serialize` crate on
    crates.io which provides the exact same interface as the libserialize library
    in-tree. The new deriving modes are named `RustcEncodable` and `RustcDecodable`
    and require `extern crate "rustc-serialize" as rustc_serialize` at the crate
    root in order to expand correctly.
    
    To migrate all crates, add the following to your `Cargo.toml`:
    
        [dependencies]
        rustc-serialize = "0.1.1"
    
    And then add the following to your crate root:
    
        extern crate "rustc-serialize" as rustc_serialize;
    
    Finally, rename `Encodable` and `Decodable` deriving modes to `RustcEncodable`
    and `RustcDecodable`.
    
    [breaking-change]

commit abf492d44f0a3b705be8c0920bfb4771f039b843
Author: Chase Southwood &lt;chase.southwood@gmail.com&gt;
Date:   Fri Dec 19 17:53:40 2014 -0600

    Misc Stabilization for collections
    
    This commit:
    
    *Renames `BinaryHeap::top` to `BinaryHeap::peek`
    *Stabilizes `front/back/front_mut/back_mut` in `DList` and `RingBuf`
    *Stabilizes `swap` in `RingBuf`
    
    Because of the method renaming, this is a [breaking-change].

commit 25f8051f2ebdc9444e0f75e91dc0cbb45d194181
Merge: bc99ced 98af642
Author: Alex Crichton &lt;alex@alexcrichton.com&gt;
Date:   Sun Dec 21 00:03:59 2014 -0800

    rollup merge of #19842: frewsxcv/rm-reexports
    
    Remove most of the public reexports mentioned in #19253
    
    These are all leftovers from the enum namespacing transition
    
    In particular:
    
    * src/libstd/num/strconv.rs
     * ExponentFormat
     * SignificantDigits
     * SignFormat
    * src/libstd/path/windows.rs
     * PathPrefix
    * src/libstd/sys/windows/timer.rs
     * Req
    * src/libcollections/str.rs
     * MaybeOwned
    * src/libstd/collections/hash/map.rs
     * Entry
    * src/libstd/collections/hash/table.rs
     * BucketState
    * src/libstd/dynamic_lib.rs
     * Rtld
    * src/libstd/os.rs
     * MemoryMapKind
     * MapOption
     * MapError
    * src/libstd/sys/common/net.rs
     * SocketStatus
     * InAddr
    * src/libstd/sys/unix/timer.rs
     * Req
    
    [breaking-change]

commit 98af642f5c8f60ae141a5d3ff92e8cc4e4317342
Author: Corey Farwell &lt;coreyf@rwell.org&gt;
Date:   Sat Dec 13 11:15:18 2014 -0500

    Remove a ton of public reexports
    
    Remove most of the public reexports mentioned in #19253
    
    These are all leftovers from the enum namespacing transition
    
    In particular:
    
    * src/libstd/num/strconv.rs
     * ExponentFormat
     * SignificantDigits
     * SignFormat
    * src/libstd/path/windows.rs
     * PathPrefix
    * src/libstd/sys/windows/timer.rs
     * Req
    * src/libcollections/str.rs
     * MaybeOwned
    * src/libstd/collections/hash/map.rs
     * Entry
    * src/libstd/collections/hash/table.rs
     * BucketState
    * src/libstd/dynamic_lib.rs
     * Rtld
    * src/libstd/io/net/ip.rs
     * IpAddr
    * src/libstd/os.rs
     * MemoryMapKind
     * MapOption
     * MapError
    * src/libstd/sys/common/net.rs
     * SocketStatus
     * InAddr
    * src/libstd/sys/unix/timer.rs
     * Req
    
    [breaking-change]

commit 9c5101542d2a4983ade627bc593e16c0bb5f23ba
Author: Alexis Beingessner &lt;a.beingessner@gmail.com&gt;
Date:   Fri Nov 21 20:47:40 2014 -0500

    Conventions and cleanup for Bitv and BitvSet
    
    Part of #18424
    
    This commit changes the semantics of `reserve` and `capacity` for Bitv and BitvSet to match conventions. It also introduces the notion of `reserve_index` and `reserve_index_exact` for collections with maximum-index-based capacity semantics.
    
    Deprecates free function constructors in favour of functions on Bitv itself.
    
    Changes `Bitv::pop` to return an Option rather than panicking.
    
    Deprecates and renames several methods in favour of conventions.
    
    Marks several blessed methods as unstable.
    
    This commit also substantially refactors Bitv and BitvSet's implementations. The new implementation is simpler, cleaner, better documented, and more robust against overflows. It also reduces coupling between Bitv and BitvSet. Tests have been seperated into seperate submodules.
    
    Fixes #16958
    
    [breaking-change]

commit cf350ea5eb562fcfb67775ad4d847e441a8006a4
Author: bluss &lt;bluss&gt;
Date:   Fri Dec 19 21:54:50 2014 +0100

    hashset: Clean up and rename the HashSet iterators
    
    This removes the type SetAlgebraItems and replaces it with the
    structs Intersection and Difference.
    
    Rename the existing HashSet iterators according to RFC #344:
    
    * SetItems -&gt; Iter
    * SetMoveItems -&gt; IntoIter
    * Remaining set combination iterators renamed to Union and SymmetricDifference
    
    [breaking-change]

commit 0efafac398ff7f28c5f0fe756c15b9008b3e0534
Merge: 6bdce25 903c5a8
Author: bors &lt;bors@rust-lang.org&gt;
Date:   Fri Dec 19 08:28:52 2014 +0000

    auto merge of #19654 : aturon/rust/merge-rt, r=alexcrichton
    
    This PR substantially narrows the notion of a "runtime" in Rust, and allows calling into Rust code directly without any setup or teardown.
    
    After this PR, the basic "runtime support" in Rust will consist of:
    
    * Unwinding and backtrace support
    * Stack guards
    
    Other support, such as helper threads for timers or the notion of a "current thread" are initialized automatically upon first use.
    
    When using Rust in an embedded context, it should now be possible to call a Rust function directly as a C function with absolutely no setup, though in that case panics will cause the process to abort. In this regard, the C/Rust interface will look much like the C/C++ interface.
    
    In more detail, this PR:
    
    * Merges `librustrt` back into `std::rt`, undoing the facade. While doing so, it removes a substantial amount of redundant functionality (such as mutexes defined in the `rt` module). Code using `librustrt` can now call into `std::rt` to e.g. start executing Rust code with unwinding support.
    
    * Allows all runtime data to be initialized lazily, including the "current thread", the "at_exit" infrastructure, and the "args" storage.
    
    * Deprecates and largely removes `std::task` along with the widespread requirement that there be a "current task" for many APIs in `std`. The entire task infrastructure is replaced with `std::thread`, which provides a more standard API for manipulating and creating native OS threads. In particular, it's possible to join on a created thread, and to get a handle to the currently-running thread. In addition, threads are equipped with some basic blocking support in the form of `park`/`unpark` operations (following a tradition in some OSes as well as the JVM). See the `std::thread` documentation for more details.
    
    * Channels are refactored to use a new internal blocking infrastructure that itself sits on top of `park`/`unpark`.
    
    One important change here is that a Rust program ends when its main thread does, following most threading models. On the other hand, threads will often be created with an RAII-style join handle that will re-institute blocking semantics naturally (and with finer control).
    
    This is very much a:
    
    [breaking-change]
    
    Closes #18000
    r? @alexcrichton

commit 903c5a8f69714382ec9fc22745f902c3e219cb68
Author: Aaron Turon &lt;aturon@mozilla.com&gt;
Date:   Thu Dec 18 23:29:30 2014 -0800

    Disable at_exit handlers
    
    The [final step](https://github.com/rust-lang/rust/pull/19654) of
    runtime removal changes the threading/process model so that the process
    shuts down when the main thread exits. But several shared resources,
    like the helper thread for timeouts, are shut down when the main thread
    exits (but before the process ends), and they are not prepared to be
    used after shut down, but other threads may try to access them during
    the shutdown sequence of the main thread.
    
    As an interim solution, the `at_exit` cleanup routine is simply skipped.
    
    Ultimately, these resources should be made to safely handle asynchronous
    shutdown, usually by panicking if called from a detached thread when the
    main thread is ending.
    
    See issue for details https://github.com/rust-lang/rust/issues/20012
    
    This is a [breaking-change] for anyone relying on `at_exit`.

commit a27fbac86849e07a0a6c746869d8f78319bd3a16
Author: Aaron Turon &lt;aturon@mozilla.com&gt;
Date:   Sun Dec 14 00:05:32 2014 -0800

    Revise std::thread API to join by default
    
    This commit is part of a series that introduces a `std::thread` API to
    replace `std::task`.
    
    In the new API, `spawn` returns a `JoinGuard`, which by default will
    join the spawned thread when dropped. It can also be used to join
    explicitly at any time, returning the thread's result. Alternatively,
    the spawned thread can be explicitly detached (so no join takes place).
    
    As part of this change, Rust processes now terminate when the main
    thread exits, even if other detached threads are still running, moving
    Rust closer to standard threading models. This new behavior may break code
    that was relying on the previously implicit join-all.
    
    In addition to the above, the new thread API also offers some built-in
    support for building blocking abstractions in user space; see the module
    doc for details.
    
    Closes #18000
    
    [breaking-change]

commit 9b03b72d7fb82f07d35e7dcda02754c6da90ae58
Author: Aaron Turon &lt;aturon@mozilla.com&gt;
Date:   Mon Nov 24 17:33:37 2014 -0800

    Remove rt::bookkeeping
    
    This commit removes the runtime bookkeeping previously used to ensure
    that all Rust tasks were joined before the runtime was shut down.
    
    This functionality will be replaced by an RAII style `Thread` API, that
    will also offer a detached mode.
    
    Since this changes the semantics of shutdown, it is a:
    
    [breaking-change]

commit 2b3477d373603527d23cc578f3737857b7b253d7
Author: Aaron Turon &lt;aturon@mozilla.com&gt;
Date:   Sun Nov 23 19:21:17 2014 -0800

    libs: merge librustrt into libstd
    
    This commit merges the `rustrt` crate into `std`, undoing part of the
    facade. This merger continues the paring down of the runtime system.
    
    Code relying on the public API of `rustrt` will break; some of this API
    is now available through `std::rt`, but is likely to change and/or be
    removed very soon.
    
    [breaking-change]

commit 6bdce25e155d846bb9252fa4a18baef7e74cf8bf
Merge: 840de07 9b5de39
Author: bors &lt;bors@rust-lang.org&gt;
Date:   Fri Dec 19 06:12:01 2014 +0000

    auto merge of #19899 : japaric/rust/unops-by-value, r=nikomatsakis
    
    - The following operator traits now take their argument by value: `Neg`, `Not`. This breaks all existing implementations of these traits.
    
    - The unary operation `OP a` now "desugars" to `OpTrait::op_method(a)` and consumes its argument.
    
    [breaking-change]
    
    ---
    
    r? @nikomatsakis This PR is very similar to the binops-by-value PR
    cc @aturon

commit 840de072085df360733c48396224e9966e2dc72c
Merge: 99d6956 67d3823
Author: bors &lt;bors@rust-lang.org&gt;
Date:   Fri Dec 19 02:52:01 2014 +0000

    auto merge of #19955 : Gankro/rust/kill-all-code, r=aturon
    
    EnumSet lives on in libcollections so that librustc can still use it. This adds a direct dependency on libcollections to librustc and libserialize.
    
    Should not be merged until https://github.com/rust-lang/rfcs/pull/509 is accepted.
    
    All of these collections have already been moved to collect-rs where they will ideally be maintained and experimented with, or will be replaced by something better: https://github.com/Gankro/collect-rs/
    
    [breaking-change]
    
    r? @aturon @alexcrichton

commit f9a48492a82f805aa40d8b6fea290badbab0d1b1
Merge: c4d58ce ddb2466
Author: bors &lt;bors@rust-lang.org&gt;
Date:   Thu Dec 18 17:32:07 2014 +0000

    auto merge of #19984 : japaric/rust/macro-expressions, r=alexcrichton
    
    followed by a semicolon.
    
    This allows code like `vec![1i, 2, 3].len();` to work.
    
    This breaks code that uses macros as statements without putting
    semicolons after them, such as:
    
        fn main() {
            ...
            assert!(a == b)
            assert!(c == d)
            println(...);
        }
    
    It also breaks code that uses macros as items without semicolons:
    
        local_data_key!(foo)
    
        fn main() {
            println("hello world")
        }
    
    Add semicolons to fix this code. Those two examples can be fixed as
    follows:
    
        fn main() {
            ...
            assert!(a == b);
            assert!(c == d);
            println(...);
        }
    
        local_data_key!(foo);
    
        fn main() {
            println("hello world")
        }
    
    RFC #378.
    
    Closes #18635.
    
    [breaking-change]
    
    ---
    
    Rebased version of #18958
    r? @alexcrichton
    cc @pcwalton

commit ddb2466f6a1bb66f22824334022a4cee61c73bdc
Author: Patrick Walton &lt;pcwalton@mimiga.net&gt;
Date:   Fri Nov 14 09:18:10 2014 -0800

    librustc: Always parse `macro!()`/`macro![]` as expressions if not
    followed by a semicolon.
    
    This allows code like `vec![1i, 2, 3].len();` to work.
    
    This breaks code that uses macros as statements without putting
    semicolons after them, such as:
    
        fn main() {
            ...
            assert!(a == b)
            assert!(c == d)
            println(...);
        }
    
    It also breaks code that uses macros as items without semicolons:
    
        local_data_key!(foo)
    
        fn main() {
            println("hello world")
        }
    
    Add semicolons to fix this code. Those two examples can be fixed as
    follows:
    
        fn main() {
            ...
            assert!(a == b);
            assert!(c == d);
            println(...);
        }
    
        local_data_key!(foo);
    
        fn main() {
            println("hello world")
        }
    
    RFC #378.
    
    Closes #18635.
    
    [breaking-change]

commit 137a3dbffd5454874bf001e213f695644b78523a
Merge: dea69e6 1fbca88
Author: Alex Crichton &lt;alex@alexcrichton.com&gt;
Date:   Wed Dec 17 08:34:14 2014 -0800

    rollup merge of #19849: alexcrichton/second-pass-option
    
    This commit takes a second pass through the `std::option` module to fully
    stabilize any lingering methods inside of it.
    
    These items were made stable as-is
    
    * Some
    * None
    * as_mut
    * expect
    * unwrap
    * unwrap_or
    * unwrap_or_else
    * map
    * map_or
    * map_or_else
    * and_then
    * or_else
    * unwrap_or_default
    * Default implementation
    * FromIterator implementation
    * Copy implementation
    
    These items were made stable with modifications
    
    * iter - now returns a struct called Iter
    * iter_mut - now returns a struct called IterMut
    * into_iter - now returns a struct called IntoIter, Clone is never implemented
    
    This is a breaking change due to the modifications to the names of the iterator
    types returned. Code referencing the old names should updated to referencing the
    newer names instead. This is also a breaking change due to the fact that
    `IntoIter` no longer implements the `Clone` trait.
    
    These items were explicitly not stabilized
    
    * as_slice - waiting on indexing conventions
    * as_mut_slice - waiting on conventions with as_slice as well
    * cloned - the API was still just recently added
    * ok_or - API remains experimental
    * ok_or_else - API remains experimental
    
    [breaking-change]

commit 5294ceb312b059709f204300156b732cc78cfaf0
Merge: 974e17b c2b0d7d
Author: Alex Crichton &lt;alex@alexcrichton.com&gt;
Date:   Wed Dec 17 08:34:01 2014 -0800

    rollup merge of #19818: emk/regex_at_name_opt
    
    Hello! This is my first Rust patch, and I fear that I've probably skipped at least 7 critical steps. I'd appreciate your feedback and advice about how to contribute to Rust.
    
    This patch is based on a discussion with @BurntSushi in #14602 a while back. I'm happy to revise it as needed to fit into the modern world. :-)
    
    As discussed in that issue, the existing `at` and `name` functions represent two different results with the empty string:
    
    1. Matched the empty string.
    2. Did not match anything.
    
    Consider the following example.  This regex has two named matched groups, `key` and `value`. `value` is optional:
    
    ```rust
    // Matches "foo", "foo;v=bar" and "foo;v=".
    regex!(r"(?P&lt;key&gt;[a-z]+)(;v=(?P&lt;value&gt;[a-z]*))?");
    ```
    
    We can access `value` using `caps.name("value")`, but there's no way for us to distinguish between the `"foo"` and `"foo;v="` cases.
    
    Early this year, @BurntSushi recommended modifying the existing `at` and `name` functions to return `Option`, instead of adding new functions to the API.
    
    This is a [breaking-change], but the fix is easy:
    
    - `refs.at(1)` becomes `refs.at(1).unwrap_or("")`.
    - `refs.name(name)` becomes `refs.name(name).unwrap_or("")`.

commit 974e17b9ea63b38b4a512742fc877a7e4ee94e03
Merge: 126a83f 341cf40
Author: Alex Crichton &lt;alex@alexcrichton.com&gt;
Date:   Wed Dec 17 08:33:58 2014 -0800

    rollup merge of #19770: csouth3/iterator-wrapperstructs
    
    Using a type alias for iterator implementations is fragile since this exposes the implementation to users of the iterator, and any changes could break existing code.
    
    This PR changes the iterators of `BTreeMap`, `BTreeSet`, `HashMap`, and `HashSet` to use proper new types, rather than type aliases.  However, since it is fair-game to treat a type-alias as the aliased type, this is a:
    
    [breaking-change].

commit 71201234d2ed3f20637fc373df063e7750cbc0ad
Merge: 66c297d 81f9a31
Author: Alex Crichton &lt;alex@alexcrichton.com&gt;
Date:   Wed Dec 17 08:33:44 2014 -0800

    rollup merge of #19720: csouth3/vecmap-newtypes
    
    Using a type alias for iterator implementations is fragile since this
    exposes the implementation to users of the iterator, and any changes
    could break existing code.
    
    This commit changes the iterators of `VecMap` to use
    proper new types, rather than type aliases.  However, since it is
    fair-game to treat a type-alias as the aliased type, this is a:
    
    [breaking-change].

commit 4265e86844b6f328ed8a0d144d02a935706c35ee
Merge: 42deaa5 769aa0a
Author: bors &lt;bors@rust-lang.org&gt;
Date:   Wed Dec 17 02:42:57 2014 +0000

    auto merge of #19761 : nick29581/rust/coerce-double, r=nikomatsakis
    
    Part of #18469
    
    [breaking-change]
    
    A receiver will only ever get a single auto-reference. Previously arrays and strings would get two, e.g., [T] would be auto-ref'ed to &amp;&amp;[T]. This is usually apparent when a trait is implemented for `&amp;[T]` and has a method takes self by reference. The usual solution is to implement the trait for `[T]` (the DST form).
    
    r? @nikomatsakis (or anyone else, really)

commit 769aa0a7b378a7b71f5bcbec3485fe171ff4f3b9
Author: Nick Cameron &lt;ncameron@mozilla.com&gt;
Date:   Fri Dec 12 13:23:21 2014 +1300

    Remove the double auto-ref on arrays/strings as receivers
    
    Part of #18469
    
    [breaking-change]
    
    A receiver will only ever get a single auto-reference. Previously arrays and strings would get two, e.g., [T] would be auto-ref'ed to &amp;&amp;[T]. This is usually apparent when a trait is implemented for `&amp;[T]` and has a method takes self by reference. The usual solution is to implement the trait for `[T]` (the DST form).

commit 341cf405e5be56b9b1c8f3be6d0fe9a014eeff26
Author: Chase Southwood &lt;chase.southwood@gmail.com&gt;
Date:   Sat Dec 13 12:36:05 2014 -0600

    Use wrapper structs for `HashSet`'s iterators.
    
    Using a type alias for iterator implementations is fragile since this
    exposes the implementation to users of the iterator, and any changes
    could break existing code.
    
    This commit changes the iterators of `HashSet` to use
    proper new types, rather than type aliases.  However, since it is
    fair-game to treat a type-alias as the aliased type, this is a:
    
    [breaking-change].

commit 85fe141fb7c066e88a6872e74347c5f34d0223a7
Author: Chase Southwood &lt;chase.southwood@gmail.com&gt;
Date:   Fri Dec 12 01:02:19 2014 -0600

    Use wrapper structs for `HashMap`'s iterators.
    
    Using a type alias for iterator implementations is fragile since this
    exposes the implementation to users of the iterator, and any changes
    could break existing code.
    
    This commit changes the keys and values iterators of `HashMap` to use
    proper new types, rather than type aliases.  However, since it is
    fair-game to treat a type-alias as the aliased type, this is a:
    
    [breaking-change].

commit a81c3ab468ad7aebcab8a545b196e74c2fb3ac32
Author: Chase Southwood &lt;chase.southwood@gmail.com&gt;
Date:   Fri Dec 12 23:14:57 2014 -0600

    Use wrapper structs for `BTreeSet`'s iterators.
    
    Using a type alias for iterator implementations is fragile since this
    exposes the implementation to users of the iterator, and any changes
    could break existing code.
    
    This commit changes the iterators of `BTreeSet` to use
    proper new types, rather than type aliases.  However, since it is
    fair-game to treat a type-alias as the aliased type, this is a:
    
    [breaking-change].

commit 765806ef1ee93b352b724aa76870d23d82894e4e
Author: Chase Southwood &lt;chase.southwood@gmail.com&gt;
Date:   Fri Dec 12 00:04:47 2014 -0600

    Use wrapper structs for `BTreeMap`'s iterators.
    
    Using a type alias for iterator implementations is fragile since this
    exposes the implementation to users of the iterator, and any changes
    could break existing code.
    
    This commit changes the keys and values iterators of `BTreeMap` to use
    proper new types, rather than type aliases.  However, since it is
    fair-game to treat a type-alias as the aliased type, this is a:
    
    [breaking-change].

commit 0669a432a2e09ad08886cb2138dbe9f5d681fb7f
Merge: 92e9e70 89d2061
Author: bors &lt;bors@rust-lang.org&gt;
Date:   Mon Dec 15 22:11:44 2014 +0000

    auto merge of #19448 : japaric/rust/binops-by-value, r=nikomatsakis
    
    - The following operator traits now take their arguments by value: `Add`, `Sub`, `Mul`, `Div`, `Rem`, `BitAnd`, `BitOr`, `BitXor`, `Shl`, `Shr`. This breaks all existing implementations of these traits.
    
    - The binary operation `a OP b` now "desugars" to `OpTrait::op_method(a, b)` and consumes both arguments.
    
    - `String` and `Vec` addition have been changed to reuse the LHS owned value, and to avoid internal cloning. Only the following asymmetric operations are available: `String + &amp;str` and `Vec&lt;T&gt; + &amp;[T]`, which are now a short-hand for the "append" operation.
    
    [breaking-change]
    
    ---
    
    This passes `make check` locally. I haven't touch the unary operators in this PR, but converting them to by value should be very similar to this PR. I can work on them after this gets the thumbs up.
    
    @nikomatsakis r? the compiler changes
    @aturon r? the library changes. I think the only controversial bit is the semantic change of the `Vec`/`String` `Add` implementation.
    cc #19148

commit c9ea7c9a58bc2bcfe77d264cedaeca5a3296634a
Author: Alex Crichton &lt;alex@alexcrichton.com&gt;
Date:   Mon Dec 15 09:06:06 2014 -0800

    serialize: Change some FnOnce bounds to FnMut
    
    Relax some of the bounds on the decoder methods back to FnMut to help accomodate
    some more flavorful variants of decoders which may need to run the closure more
    than once when it, for example, attempts to find the first successful enum to
    decode.
    
    This a breaking change due to the bounds for the trait switching, and clients
    will need to update from `FnOnce` to `FnMut` as well as likely making the local
    function binding mutable in order to call the function.
    
    [breaking-change]

commit b60de4bfc2cf45ebe16b9b5b768f0aad54211625
Author: Niko Matsakis &lt;niko@alum.mit.edu&gt;
Date:   Fri Dec 12 11:09:24 2014 -0500

    Emit warning when lifetime names are shadowed.
    
    This is not technically a [breaking-change], but it will be soon, so
    you should update your code. Typically, shadowing is accidental, and
    the shadowing lifetime can simply be removed. This frequently occurs
    in constructor patterns:
    
    ```rust
    // Old:
    impl&lt;'a&gt; SomeStruct&lt;'a&gt; { fn new&lt;'a&gt;(..) -&gt; SomeStruct&lt;'a&gt; { ... } }
    
    // Should be:
    impl&lt;'a&gt; SomeStruct&lt;'a&gt; { fn new(..) -&gt; SomeStruct&lt;'a&gt; { ... } }
    ```
    
    Otherwise, you should rename the inner lifetime to something
    else. Note though that lifetime elision frequently applies:
    
    ```rust
    // Old
    impl&lt;'a&gt; SomeStruct&lt;'a&gt; {
        fn get&lt;'a&gt;(x: &amp;'a self) -&gt; &amp;'a T { &amp;self.field }
    }
    
    // Should be:
    impl&lt;'a&gt; SomeStruct&lt;'a&gt; {
        fn get(x: &amp;self) -&gt; &amp;T { &amp;self.field }
    }
    ``

commit 1fbca8824a6b6018191b7ee998d2c97f30c481d7
Author: Alex Crichton &lt;alex@alexcrichton.com&gt;
Date:   Sun Dec 14 10:34:23 2014 -0800

    std: Fully stabilize Option&lt;T&gt;
    
    This commit takes a second pass through the `std::option` module to fully
    stabilize any lingering methods inside of it.
    
    These items were made stable as-is
    
    * Some
    * None
    * as_mut
    * expect
    * unwrap
    * unwrap_or
    * unwrap_or_else
    * map
    * map_or
    * map_or_else
    * and_then
    * or_else
    * unwrap_or_default
    * Default implementation
    * FromIterator implementation
    * Copy implementation
    
    These items were made stable with modifications
    
    * iter - now returns a struct called Iter
    * iter_mut - now returns a struct called IterMut
    * into_iter - now returns a struct called IntoIter, Clone is never implemented
    
    This is a breaking change due to the modifications to the names of the iterator
    types returned. Code referencing the old names should updated to referencing the
    newer names instead. This is also a breaking change due to the fact that
    `IntoIter` no longer implements the `Clone` trait.
    
    These items were explicitly not stabilized
    
    * as_slice - waiting on indexing conventions
    * as_mut_slice - waiting on conventions with as_slice as well
    * cloned - the API was still just recently added
    * ok_or - API remains experimental
    * ok_or_else - API remains experimental
    
    [breaking-change]

commit c2b0d7dd8818a0dca9b1fa7af6873375907f05ca
Author: Eric Kidd &lt;git@randomhacks.net&gt;
Date:   Sat Dec 13 13:33:18 2014 -0500

    Modify `regex::Captures::{at,name}` to return `Option`
    
    Closes #14602.  As discussed in that issue, the existing `at` and `name`
    functions represent two different results with the empty string:
    
    1. Matched the empty string.
    2. Did not match anything.
    
    Consider the following example.  This regex has two named matched
    groups, `key` and `value`. `value` is optional:
    
    ```rust
    // Matches "foo", "foo;v=bar" and "foo;v=".
    regex!(r"(?P&lt;key&gt;[a-z]+)(;v=(?P&lt;value&gt;[a-z]*))?");
    ```
    
    We can access `value` using `caps.name("value")`, but there's no way for
    us to distinguish between the `"foo"` and `"foo;v="` cases.
    
    Early this year, @BurntSushi recommended modifying the existing `at` and
    `name` functions to return `Option`, instead of adding new functions to
    the API.
    
    This is a [breaking-change], but the fix is easy:
    
    - `refs.at(1)` becomes `refs.at(1).unwrap_or("")`.
    - `refs.name(name)` becomes `refs.name(name).unwrap_or("")`.

commit 52f7a4a351646d3837f214b5c7aec390c9b08221
Merge: 3a9305c f6d60f3
Author: bors &lt;bors@rust-lang.org&gt;
Date:   Sun Dec 14 11:37:27 2014 +0000

    auto merge of #19338 : nikomatsakis/rust/unboxed-closure-purge-the-proc, r=acrichto
    
    They are replaced with unboxed closures.
    
    cc @pcwalton @aturon
    
    This is a [breaking-change]. Mostly, uses of `proc()` simply need to be converted to `move||` (unboxed closures), but in some cases the adaptations required are more complex (particularly for library authors). A detailed write-up can be found here: http://smallcultfollowing.com/babysteps/blog/2014/11/26/purging-proc/
    
    The commits are ordered to emphasize the more important changes, but are not truly standalone.

commit 81f9a319265ddbe6b7823b50c29e3aff076d82c1
Author: Chase Southwood &lt;chase.southwood@gmail.com&gt;
Date:   Wed Dec 10 23:12:31 2014 -0600

    Change `VecMap`'s iterators to use wrapper structs instead of typedefs.
    
    Using a type alias for iterator implementations is fragile since this
    exposes the implementation to users of the iterator, and any changes
    could break existing code.
    
    This commit changes the iterators of `VecMap` to use
    proper new types, rather than type aliases.  However, since it is
    fair-game to treat a type-alias as the aliased type, this is a:
    
    [breaking-change].

commit 444fa1b7cffcd99ca5b8abb51acf979f06a25899
Merge: 567b90f b8e0b81
Author: bors &lt;bors@rust-lang.org&gt;
Date:   Sat Dec 13 22:57:21 2014 +0000

    auto merge of #19467 : japaric/rust/uc, r=alexcrichton
    
    This PR moves almost all our current uses of closures, both in public API and internal uses, to the new "unboxed" closures system.
    
    In most cases, downstream code that *only uses* closures will continue to work as it is. The reason is that the `|| {}` syntax can be inferred either as a boxed or an "unboxed" closure according to the context. For example the following code will continue to work:
    
    ``` rust
    some_option.map(|x| x.transform_with(upvar))
    ```
    
    And will get silently upgraded to an "unboxed" closure.
    
    In some other cases, it may be necessary to "annotate" which `Fn*` trait the closure implements:
    
    ```
    // Change this
    |x| { /* body */}
    // to either of these
    |: x| { /* body */}  // closure implements the FnOnce trait
    |&amp;mut : x| { /* body */}  // FnMut
    |&amp;: x| { /* body */}  // Fn
    ```
    
    This mainly occurs when the closure is assigned to a variable first, and then passed to a function/method.
    
    ``` rust
    let closure = |: x| x.transform_with(upvar);
    some.option.map(closure)
    ```
    
    (It's very likely that in the future, an improved inference engine will make this annotation unnecessary)
    
    Other cases that require annotation are closures that implement some trait via a blanket `impl`, for example:
    
    - `std::finally::Finally`
    - `regex::Replacer`
    - `std::str::CharEq`
    
    ``` rust
    string.trim_left_chars(|c: char| c.is_whitespace())
    //~^ ERROR: the trait `Fn&lt;(char,), bool&gt;` is not implemented for the type `|char| -&gt; bool`
    string.trim_left_chars(|&amp;: c: char| c.is_whitespace())  // OK
    ```
    
    Finally, all implementations of traits that contain boxed closures in the arguments of their methods are now broken. And will need to be updated to use unboxed closures. These are the main affected traits:
    
    - `serialize::Decoder`
    - `serialize::DecoderHelpers`
    - `serialize::Encoder`
    - `serialize::EncoderHelpers`
    - `rustrt::ToCStr`
    
    For example, change this:
    
    ``` rust
    // libserialize/json.rs
    impl&lt;'a&gt; Encoder&lt;io::IoError&gt; for Encoder&lt;'a&gt; {
        fn emit_enum(&amp;mut self,
                     _name: &amp;str,
                     f: |&amp;mut Encoder&lt;'a&gt;| -&gt; EncodeResult) -&gt; EncodeResult {
            f(self)
        }
    }
    ```
    
    to:
    
    ``` rust
    // libserialize/json.rs
    impl&lt;'a&gt; Encoder&lt;io::IoError&gt; for Encoder&lt;'a&gt; {
        fn emit_enum&lt;F&gt;(&amp;mut self, _name: &amp;str, f: F) -&gt; EncodeResult where
            F: FnOnce(&amp;mut Encoder&lt;'a&gt;) -&gt; EncodeResult
        {
            f(self)
        }
    }
    ```
    
    [breaking-change]
    
    ---
    
    ### How the `Fn*` bound has been selected
    
    I've chosen the bounds to make the functions/structs as "generic as possible", i.e. to let them allow the maximum amount of input.
    
    - An `F: FnOnce` bound accepts the three kinds of closures: `|:|`, `|&amp;mut:|` and `|&amp;:|`.
    - An `F: FnMut` bound only accepts "non-consuming" closures: `|&amp;mut:|` and `|&amp;:|`.
    - An `F: Fn` bound only accept the "immutable environment" closures: `|&amp;:|`.
    
    This means that whenever possible the `FnOnce` bound has been used, if the `FnOnce` bound couldn't be used, then the `FnMut` was used. The `Fn` bound was never used in the whole repository.
    
    The `FnMut` bound was the most used, because it resembles the semantics of the current boxed closures: the closure can modify its environment, and the closure may be called several times.
    
    The `FnOnce` bound allows new semantics: you can move out the upvars when the closure is called. This can be effectively paired with the `move || {}` syntax to transfer ownership from the environment to the closure caller.
    
    In the case of trait methods, is hard to select the "right" bound since we can't control how the trait may be implemented by downstream users. In these cases, I have selected the bound based on how we use these traits in the repository. For this reason the selected bounds may not be ideal, and may require tweaking before stabilization.
    
    r? @aturon
</pre></body></html>
