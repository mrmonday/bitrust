<!DOCTYPE html><html><head>
<title>BitRust - Breaking Changes in rust-lang/rust</title>
</head><body><pre>
commit 096a28607fb80c91e6e2ca64d9ef44c4e550e96c
Author: Niko Matsakis &lt;niko@alum.mit.edu&gt;
Date:   Fri Dec 5 17:01:33 2014 -0800

    librustc: Make `Copy` opt-in.
    
    This change makes the compiler no longer infer whether types (structures
    and enumerations) implement the `Copy` trait (and thus are implicitly
    copyable). Rather, you must implement `Copy` yourself via `impl Copy for
    MyType {}`.
    
    A new warning has been added, `missing_copy_implementations`, to warn
    you if a non-generic public type has been added that could have
    implemented `Copy` but didn't.
    
    For convenience, you may *temporarily* opt out of this behavior by using
    `#![feature(opt_out_copy)]`. Note though that this feature gate will never be
    accepted and will be removed by the time that 1.0 is released, so you should
    transition your code away from using it.
    
    This breaks code like:
    
        #[deriving(Show)]
        struct Point2D {
            x: int,
            y: int,
        }
    
        fn main() {
            let mypoint = Point2D {
                x: 1,
                y: 1,
            };
            let otherpoint = mypoint;
            println!("{}{}", mypoint, otherpoint);
        }
    
    Change this code to:
    
        #[deriving(Show)]
        struct Point2D {
            x: int,
            y: int,
        }
    
        impl Copy for Point2D {}
    
        fn main() {
            let mypoint = Point2D {
                x: 1,
                y: 1,
            };
            let otherpoint = mypoint;
            println!("{}{}", mypoint, otherpoint);
        }
    
    This is the backwards-incompatible part of #13231.
    
    Part of RFC #3.
    
    [breaking-change]

commit fec0f16c98ab066ff11be35b5a8bb0d80efa90f1
Author: Barosl Lee &lt;vcs@barosl.com&gt;
Date:   Mon Nov 24 03:14:02 2014 +0900

    libserialize: Always use a decimal point when emitting a float value
    
    JSON doesn't distinguish between integer and float. They are just
    numbers. Also, in the current implementation, a fractional number
    without the fractional part is encoded without a decimal point.
    
    Thereforce, when the value is decoded, it is first rendered as Json,
    either I64 or U64. This reduces type safety, because while the original
    intention was to cast the value to float, it can also be casted to
    integer.
    
    As a workaround of this problem, this commit makes the encoder always
    emit a decimal point even if it is not necessary. If the fractional part
    of a float number is zero, ".0" is padded to the end of the result.
    
    [breaking-change]

commit f102123b659911dbee25bbe518d73d66185bb978
Author: Barosl Lee &lt;vcs@barosl.com&gt;
Date:   Mon Nov 24 03:00:10 2014 +0900

    libserialize: Do not coerce to integer when decoding a float value
    
    When an integral value is expected by the user but a fractional value is
    found, the current implementation uses std::num::cast() to coerce to an
    integer type, losing the fractional part. This behavior is not desirable
    because the number loses precision without notice.
    
    This commit makes it raise ExpectedError when such a situation arises.
    
    [breaking-change]

commit ca4f53655e82a0a0e1d613b16108720bb7a50fde
Author: Barosl Lee &lt;vcs@barosl.com&gt;
Date:   Mon Nov 24 02:22:30 2014 +0900

    libserialize: Remove float preprocessing in serialize::json::Encoder
    
    serialize::json::Encoder currently uses f64 to emit any integral type.
    This is possibly due to the behavior of JavaScript, which uses f64 to
    represent any numeric value.
    
    This leads to a problem that only the integers in the range of [-2^53+1,
    2^53-1] can be encoded. Therefore, i64 and u64 cannot be used reliably
    in the current implementation.
    
    RFC 7159 suggests that good interoperability can be achieved if the
    range is respected by implementations. However, it also says that
    implementations are allowed to set the range of number accepted. And it
    seems that the JSON encoders outside of the JavaScript world usually
    make use of i64 values.
    
    This commit removes the float preprocessing done in the emit_* methods.
    It also increases performance, because transforming f64 into String
    costs more than that of an integral type.
    
    Fixes #18319
    
    [breaking-change]

commit 558f8d8e3ea6b7da3d6d338740637149a7e45840
Merge: a243e88 6e18b5a
Author: bors &lt;bors@rust-lang.org&gt;
Date:   Sun Dec 7 16:12:22 2014 +0000

    auto merge of #19539 : cmr/rust/18959, r=nikomatsakis
    
    Closes #18959
    
    Technically, this causes code that once compiled to no longer compile, but
    that code probably never ran.
    
    [breaking-change]
    
    ------------
    
    Not quite sure the error message is good enough, I feel like it ought to tell you "because it inherits from non-object-safe trait Foo", so I've opened up a follow-up issue #19538

commit 6e18b5af9336947ec5d41e66d216c52c12bf74a3
Author: Corey Richardson &lt;corey@octayn.net&gt;
Date:   Thu Nov 27 11:28:51 2014 -0500

    rustc: check supertraits for object safety
    
    Closes #18959
    
    Technically, this causes code that once compiled to no longer compile, but
    that code probably never ran.
    
    [breaking-change]

commit a6ce402401f0da3a48a5a183ae109a00024ba666
Merge: 26f2867 e7c1f57
Author: Corey Richardson &lt;corey@octayn.net&gt;
Date:   Fri Dec 5 10:06:52 2014 -0800

    rollup merge of #19416: sfackler/global-stdin
    
    io::stdin returns a new `BufferedReader` each time it's called, which
    results in some very confusing behavior with disappearing output. It now
    returns a `StdinReader`, which wraps a global singleton
    `Arc&lt;Mutex&lt;BufferedReader&lt;StdReader&gt;&gt;`. `Reader` is implemented directly
    on `StdinReader`. However, `Buffer` is not, as the `fill_buf` method is
    fundamentaly un-thread safe. A `lock` method is defined on `StdinReader`
    which returns a smart pointer wrapping the underlying `BufferedReader`
    while guaranteeing mutual exclusion.
    
    Code that treats the return value of io::stdin as implementing `Buffer`
    will break. Add a call to `lock`:
    
    ```rust
    io::stdin().read_line();
    // =&gt;
    io::stdin().lock().read_line();
    ```
    
    Closes #14434
    
    [breaking-change]

commit 08ce178866e4533d8815fe5868a520e0fc55b21c
Merge: 4573da6 c3adbd3
Author: Corey Richardson &lt;corey@octayn.net&gt;
Date:   Fri Dec 5 10:06:39 2014 -0800

    rollup merge of #19274: alexcrichton/rewrite-sync
    
    This commit is a reimplementation of `std::sync` to be based on the
    system-provided primitives wherever possible. The previous implementation was
    fundamentally built on top of channels, and as part of the runtime reform it has
    become clear that this is not the level of abstraction that the standard level
    should be providing. This rewrite aims to provide as thin of a shim as possible
    on top of the system primitives in order to make them safe.
    
    The overall interface of the `std::sync` module has in general not changed, but
    there are a few important distinctions, highlighted below:
    
    * The condition variable type, `Condvar`, has been separated out of a `Mutex`.
      A condition variable is now an entirely separate type. This separation
      benefits users who only use one mutex, and provides a clearer distinction of
      who's responsible for managing condition variables (the application).
    
    * All of `Condvar`, `Mutex`, and `RWLock` are now directly built on top of
      system primitives rather than using a custom implementation. The `Once`,
      `Barrier`, and `Semaphore` types are still built upon these abstractions of
      the system primitives.
    
    * The `Condvar`, `Mutex`, and `RWLock` types all have a new static type and
      constant initializer corresponding to them. These are provided primarily for C
      FFI interoperation, but are often useful to otherwise simply have a global
      lock. The types, however, will leak memory unless `destroy()` is called on
      them, which is clearly documented.
    
    * The fundamental architecture of this design is to provide two separate layers.
      The first layer is that exposed by `sys_common` which is a cross-platform
      bare-metal abstraction of the system synchronization primitives. No attempt is
      made at making this layer safe, and it is quite unsafe to use! It is currently
      not exported as part of the API of the standard library, but the stabilization
      of the `sys` module will ensure that these will be exposed in time. The
      purpose of this layer is to provide the core cross-platform abstractions if
      necessary to implementors.
    
      The second layer is the layer provided by `std::sync` which is intended to be
      the thinnest possible layer on top of `sys_common` which is entirely safe to
      use. There are a few concerns which need to be addressed when making these
      system primitives safe:
    
        * Once used, the OS primitives can never be **moved**. This means that they
          essentially need to have a stable address. The static primitives use
          `&amp;'static self` to enforce this, and the non-static primitives all use a
          `Box` to provide this guarantee.
    
        * Poisoning is leveraged to ensure that invalid data is not accessible from
          other tasks after one has panicked.
    
      In addition to these overall blanket safety limitations, each primitive has a
      few restrictions of its own:
    
        * Mutexes and rwlocks can only be unlocked from the same thread that they
          were locked by. This is achieved through RAII lock guards which cannot be
          sent across threads.
    
        * Mutexes and rwlocks can only be unlocked if they were previously locked.
          This is achieved by not exposing an unlocking method.
    
        * A condition variable can only be waited on with a locked mutex. This is
          achieved by requiring a `MutexGuard` in the `wait()` method.
    
        * A condition variable cannot be used concurrently with more than one mutex.
          This is guaranteed by dynamically binding a condition variable to
          precisely one mutex for its entire lifecycle. This restriction may be able
          to be relaxed in the future (a mutex is unbound when no threads are
          waiting on the condvar), but for now it is sufficient to guarantee safety.
    
    * Condvars support timeouts for their blocking operations. The
      implementation for these operations is provided by the system.
    
    Due to the modification of the `Condvar` API, removal of the `std::sync::mutex`
    API, and reimplementation, this is a breaking change. Most code should be fairly
    easy to port using the examples in the documentation of these primitives.
    
    [breaking-change]
    
    Closes #17094
    Closes #18003

commit d91331074862f13d87f67b85eeba2a1192c3a12d
Author: Erick Tryzelaar &lt;erick.tryzelaar@gmail.com&gt;
Date:   Fri Dec 5 09:04:55 2014 -0800

    test: expose boxplot and the extra stats test keeps track of
    
    [breaking-change]

commit 71d4e77db8ad4b6d821da7e5d5300134ac95974e
Author: Alex Crichton &lt;alex@alexcrichton.com&gt;
Date:   Mon Nov 24 11:16:40 2014 -0800

    std: Rewrite the `sync` module
    
    This commit is a reimplementation of `std::sync` to be based on the
    system-provided primitives wherever possible. The previous implementation was
    fundamentally built on top of channels, and as part of the runtime reform it has
    become clear that this is not the level of abstraction that the standard level
    should be providing. This rewrite aims to provide as thin of a shim as possible
    on top of the system primitives in order to make them safe.
    
    The overall interface of the `std::sync` module has in general not changed, but
    there are a few important distinctions, highlighted below:
    
    * The condition variable type, `Condvar`, has been separated out of a `Mutex`.
      A condition variable is now an entirely separate type. This separation
      benefits users who only use one mutex, and provides a clearer distinction of
      who's responsible for managing condition variables (the application).
    
    * All of `Condvar`, `Mutex`, and `RWLock` are now directly built on top of
      system primitives rather than using a custom implementation. The `Once`,
      `Barrier`, and `Semaphore` types are still built upon these abstractions of
      the system primitives.
    
    * The `Condvar`, `Mutex`, and `RWLock` types all have a new static type and
      constant initializer corresponding to them. These are provided primarily for C
      FFI interoperation, but are often useful to otherwise simply have a global
      lock. The types, however, will leak memory unless `destroy()` is called on
      them, which is clearly documented.
    
    * The `Condvar` implementation for an `RWLock` write lock has been removed. This
      may be added back in the future with a userspace implementation, but this
      commit is focused on exposing the system primitives first.
    
    * The fundamental architecture of this design is to provide two separate layers.
      The first layer is that exposed by `sys_common` which is a cross-platform
      bare-metal abstraction of the system synchronization primitives. No attempt is
      made at making this layer safe, and it is quite unsafe to use! It is currently
      not exported as part of the API of the standard library, but the stabilization
      of the `sys` module will ensure that these will be exposed in time. The
      purpose of this layer is to provide the core cross-platform abstractions if
      necessary to implementors.
    
      The second layer is the layer provided by `std::sync` which is intended to be
      the thinnest possible layer on top of `sys_common` which is entirely safe to
      use. There are a few concerns which need to be addressed when making these
      system primitives safe:
    
        * Once used, the OS primitives can never be **moved**. This means that they
          essentially need to have a stable address. The static primitives use
          `&amp;'static self` to enforce this, and the non-static primitives all use a
          `Box` to provide this guarantee.
    
        * Poisoning is leveraged to ensure that invalid data is not accessible from
          other tasks after one has panicked.
    
      In addition to these overall blanket safety limitations, each primitive has a
      few restrictions of its own:
    
        * Mutexes and rwlocks can only be unlocked from the same thread that they
          were locked by. This is achieved through RAII lock guards which cannot be
          sent across threads.
    
        * Mutexes and rwlocks can only be unlocked if they were previously locked.
          This is achieved by not exposing an unlocking method.
    
        * A condition variable can only be waited on with a locked mutex. This is
          achieved by requiring a `MutexGuard` in the `wait()` method.
    
        * A condition variable cannot be used concurrently with more than one mutex.
          This is guaranteed by dynamically binding a condition variable to
          precisely one mutex for its entire lifecycle. This restriction may be able
          to be relaxed in the future (a mutex is unbound when no threads are
          waiting on the condvar), but for now it is sufficient to guarantee safety.
    
    * Condvars now support timeouts for their blocking operations. The
      implementation for these operations is provided by the system.
    
    Due to the modification of the `Condvar` API, removal of the `std::sync::mutex`
    API, and reimplementation, this is a breaking change. Most code should be fairly
    easy to port using the examples in the documentation of these primitives.
    
    [breaking-change]
    
    Closes #17094
    Closes #18003

commit 6d965cc2c99787a949d38abf225412fe502d3ed8
Merge: 53e8bd6 5cfac94
Author: bors &lt;bors@rust-lang.org&gt;
Date:   Thu Dec 4 12:02:56 2014 +0000

    auto merge of #19167 : japaric/rust/rhs-cmp, r=aturon
    
    Comparison traits have gained an `Rhs` input parameter that defaults to `Self`. And now the comparison operators can be overloaded to work between different types. In particular, this PR allows the following operations (and their commutative versions):
    
    - `&amp;str` == `String` == `CowString`
    - `&amp;[A]` == `&amp;mut [B]` == `Vec&lt;C&gt;` == `CowVec&lt;D&gt;` == `[E, ..N]` (for `N` up to 32)
    - `&amp;mut A` == `&amp;B` (for `Sized` `A` and `B`)
    
    Where `A`, `B`, `C`, `D`, `E` may be different types that implement `PartialEq`. For example, these comparisons are now valid: `string == "foo"`, and `vec_of_strings == ["Hello", "world"]`.
    
    [breaking-change]s
    
    Since the `==` may now work on different types, operations that relied on the old "same type restriction" to drive type inference, will need to be type annotated. These are the most common fallout cases:
    
    - `some_vec == some_iter.collect()`: `collect` needs to be type annotated: `collect::&lt;Vec&lt;_&gt;&gt;()`
    - `slice == &amp;[a, b, c]`: RHS doesn't get coerced to an slice, use an array instead `[a, b, c]`
    - `lhs == []`: Change expression to `lhs.is_empty()`
    - `lhs == some_generic_function()`: Type annotate the RHS as necessary
    
    cc #19148
    
    r? @aturon

commit e7c1f57d6c8781cfb3e746eac5f13f760fcde2b4
Author: Steven Fackler &lt;sfackler@gmail.com&gt;
Date:   Sat Nov 29 23:07:43 2014 -0800

    Back io::stdin with a global singleton BufferedReader
    
    io::stdin returns a new `BufferedReader` each time it's called, which
    results in some very confusing behavior with disappearing output. It now
    returns a `StdinReader`, which wraps a global singleton
    `Arc&lt;Mutex&lt;BufferedReader&lt;StdReader&gt;&gt;`. `Reader` is implemented directly
    on `StdinReader`. However, `Buffer` is not, as the `fill_buf` method is
    fundamentaly un-thread safe. A `lock` method is defined on `StdinReader`
    which returns a smart pointer wrapping the underlying `BufferedReader`
    while guaranteeing mutual exclusion.
    
    Code that treats the return value of io::stdin as implementing `Buffer`
    will break. Add a call to `lock`:
    
    ```rust
    io::stdin().lines()
    // =&gt;
    io::stdin().lock().lines()
    ```
    
    Closes #14434
    
    [breaking-change]

commit b82624bf205e83555d7764d9f849fbfd30df0083
Author: Piotr Czarnecki &lt;pioczarn@gmail.com&gt;
Date:   Sat Nov 8 17:26:52 2014 +0100

    std: Change the behavior of `reserve` for HashMap.
    
    HashMap's `reserve` method now takes as an argument the *extra* space
    to reserve.
    
    [breaking-change]

commit 63553a10adc8b507edee1fce43f868d93628ce34
Author: P1start &lt;rewi-github@whanau.org&gt;
Date:   Sun Nov 30 21:33:04 2014 +1300

    Fix the ordering of `unsafe` and `extern` in methods
    
    This breaks code that looks like this:
    
        trait Foo {
            extern "C" unsafe fn foo();
        }
    
        impl Foo for Bar {
            extern "C" unsafe fn foo() { ... }
        }
    
    Change such code to look like this:
    
        trait Foo {
            unsafe extern "C" fn foo();
        }
    
        impl Foo for Bar {
            unsafe extern "C" fn foo() { ... }
        }
    
    Fixes #19398.
    
    [breaking-change]

commit dfaad04b7a14012ac282269eacfb51b4e97673c1
Merge: 8d8f41b 1919b12
Author: bors &lt;bors@rust-lang.org&gt;
Date:   Sun Nov 30 06:56:41 2014 +0000

    auto merge of #19365 : frewsxcv/rust/getopts-cleanup, r=alexcrichton
    
    * Remove public reexports, as a part of #19253
    * Rename getopts::Fail_ to getopts::Fail
     * Didn't see a reason for the suffixed '_'
    * Removed getopts::FailType
     * Looked like it was only beings used for tests; refactored the tests
       to stop requiring it
    * A few other non-breaking trivial refactoring changes
    
    [breaking-change]

commit 1919b12775ca45e8f5bb4b7540ebfa3d100f5bf6
Author: Corey Farwell &lt;coreyf@rwell.org&gt;
Date:   Thu Nov 27 14:39:50 2014 -0500

    getopts: cleanup, renames, remove reexports
    
    * Remove public reexports, as a part of #19253
    * Rename getopts::Fail_ to getopts::Fail
     * Didn't see a reason for the suffixed '_'
    * Removed getopts::FailType
     * Looked like it was only beings used for tests; refactored the tests
       to stop requiring it
    * A few other non-breaking trivial refactoring changes
    
    [breaking-change]

commit f4a775639ca846f29abeed16a7b4e8e1c8819626
Merge: 702127f 21d5d13
Author: Alex Crichton &lt;alex@alexcrichton.com&gt;
Date:   Wed Nov 26 09:44:43 2014 -0800

    rollup merge of #19298: nikomatsakis/unboxed-closure-parse-the-plus
    
    Implements RFC 438.
    
    Fixes #19092.
    
    This is a [breaking-change]: change types like `&amp;Foo+Send` or `&amp;'a mut Foo+'a` to `&amp;(Foo+Send)` and `&amp;'a mut (Foo+'a)`, respectively.
    
    r? @brson

commit 34b98b306ad23ab895f701de1d009ff026a1d2b1
Merge: 60299d7 36372b9
Author: Alex Crichton &lt;alex@alexcrichton.com&gt;
Date:   Wed Nov 26 09:44:30 2014 -0800

    rollup merge of #19287: alexcrichton/issue-19272
    
    At the same time remove the `pub use` of the variants in favor of accessing
    through the enum type itself. This is a breaking change as the `Found` and
    `NotFound` variants must now be imported through `BinarySearchResult` instead of
    just `std::slice`.
    
    [breaking-change]
    Closes #19271

commit 1a44875af985de43d514192d43ef260a24e83d26
Merge: 930f877 b299c2b
Author: bors &lt;bors@rust-lang.org&gt;
Date:   Wed Nov 26 17:42:07 2014 +0000

    auto merge of #19176 : aturon/rust/stab-iter, r=alexcrichton
    
    This is an initial pass at stabilizing the `iter` module. The module is
    fairly large, but is also pretty polished, so most of the stabilization
    leaves things as they are.
    
    Some changes:
    
    * Due to the new object safety rules, various traits needs to be split
      into object-safe traits and extension traits. This includes `Iterator`
      itself. While splitting up the traits adds some complexity, it will
      also increase flexbility: once we have automatic impls of `Trait` for
      trait objects over `Trait`, then things like the iterator adapters
      will all work with trait objects.
    
    * Iterator adapters that use up the entire iterator now take it by
      value, which makes the semantics more clear and helps catch bugs. Due
      to the splitting of Iterator, this does not affect trait objects. If
      the underlying iterator is still desired for some reason, `by_ref` can
      be used. (Note: this change had no fallout in the Rust distro except
      for the useless mut lint.)
    
    * In general, extension traits new and old are following an [in-progress
      convention](rust-lang/rfcs#445). As such, they
      are marked `unstable`.
    
    * As usual, anything involving closures is `unstable` pending unboxed
      closures.
    
    * A few of the more esoteric/underdeveloped iterator forms (like
      `RandomAccessIterator` and `MutableDoubleEndedIterator`, along with
      various unfolds) are left experimental for now.
    
    * The `order` submodule is left `experimental` because it will hopefully
      be replaced by generalized comparison traits.
    
    * "Leaf" iterators (like `Repeat` and `Counter`) are uniformly
      constructed by free fns at the module level. That's because the types
      are not otherwise of any significance (if we had `impl Trait`, you
      wouldn't want to define a type at all).
    
    Closes #17701
    
    Due to renamings and splitting of traits, this is a:
    
    [breaking-change]

commit ce238d752b1e04d4aea21c0fadf420a270ed6ff9
Author: Corey Farwell &lt;coreyf@rwell.org&gt;
Date:   Sat Nov 22 13:48:01 2014 -0500

    Unpublicize reexports, unprefix JSON type aliases
    
    The type aliases json::JsonString and json::JsonObject were originally
    prefixed with 'json' to prevent collisions with (at the time) the enums
    json::String and json::Object respectively. Now that enum namespacing
    has landed, this 'json' prefix is redundant and can be removed:
    
    json::JsonArray -&gt; json::Array
    json::JsonObject -&gt; json::Object
    
    In addition, this commit also unpublicizes all of the re-exports in this
    JSON module, as a part of #19253
    
    [breaking-change]

commit 8fb027e398ef756b7b02a270ef0304be92e70f4d
Merge: 61af402 3293ab1
Author: bors &lt;bors@rust-lang.org&gt;
Date:   Wed Nov 26 12:02:16 2014 +0000

    auto merge of #19252 : japaric/rust/cow, r=aturon
    
    - Add `IntoCow` trait, and put it in the prelude
    - Add `is_owned`/`is_borrowed` methods to `Cow`
    - Add `CowString`/`CowVec` type aliases (to `Cow&lt;'_, String, str&gt;`/`Cow&lt;'_, Vec, [T]&gt;` respectively)
    - `Cow` implements: `Show`, `Hash`, `[Partial]{Eq,Ord}`
    - `impl BorrowFrom&lt;Cow&lt;'a, T, B&gt;&gt; for B`
    
    [breaking-change]s:
    
    - `IntoMaybeOwned` has been removed from the prelude
    - libcollections: `SendStr` is now an alias to `CowString&lt;'static&gt;` (it was aliased to `MaybeOwned&lt;'static&gt;`)
    - libgraphviz:
      - `LabelText` variants now wrap `CowString` instead of `MaybeOwned`
      - `Nodes` and `Edges` are now type aliases to `CowVec` (they were aliased to `MaybeOwnedVec`)
    - libstd/path: `Display::as_maybe_owned` has been renamed to `Display::as_cow` and now returns a `CowString`
    - These functions now accept/return `Cow` instead of `MaybeOwned[Vector]`:
      - libregex: `Replacer::reg_replace`
      - libcollections: `str::from_utf8_lossy`
      - libgraphviz: `Id::new`, `Id::name`, `LabelText::pre_escaped_content`
      - libstd: `TaskBuilder::named`
    
    r? @aturon

commit a86f72d9a2adc6d65f2ba0990caca35c1a3f622d
Author: Aaron Turon &lt;aturon@mozilla.com&gt;
Date:   Thu Nov 6 09:32:32 2014 -0800

    libs: stabilize iter module
    
    This is an initial pass at stabilizing the `iter` module. The module is
    fairly large, but is also pretty polished, so most of the stabilization
    leaves things as they are.
    
    Some changes:
    
    * Due to the new object safety rules, various traits needs to be split
      into object-safe traits and extension traits. This includes `Iterator`
      itself. While splitting up the traits adds some complexity, it will
      also increase flexbility: once we have automatic impls of `Trait` for
      trait objects over `Trait`, then things like the iterator adapters
      will all work with trait objects.
    
    * Iterator adapters that use up the entire iterator now take it by
      value, which makes the semantics more clear and helps catch bugs. Due
      to the splitting of Iterator, this does not affect trait objects. If
      the underlying iterator is still desired for some reason, `by_ref` can
      be used. (Note: this change had no fallout in the Rust distro except
      for the useless mut lint.)
    
    * In general, extension traits new and old are following an [in-progress
      convention](https://github.com/rust-lang/rfcs/pull/445). As such, they
      are marked `unstable`.
    
    * As usual, anything involving closures is `unstable` pending unboxed
      closures.
    
    * A few of the more esoteric/underdeveloped iterator forms (like
      `RandomAccessIterator` and `MutableDoubleEndedIterator`, along with
      various unfolds) are left experimental for now.
    
    * The `order` submodule is left `experimental` because it will hopefully
      be replaced by generalized comparison traits.
    
    * "Leaf" iterators (like `Repeat` and `Counter`) are uniformly
      constructed by free fns at the module level. That's because the types
      are not otherwise of any significance (if we had `impl Trait`, you
      wouldn't want to define a type at all).
    
    Closes #17701
    
    Due to renamings and splitting of traits, this is a:
    
    [breaking-change]

commit 689ef2dabfa3b2b379c953e5fb68ce2c805c2231
Merge: 0e06f71 985acfd
Author: bors &lt;bors@rust-lang.org&gt;
Date:   Tue Nov 25 20:32:20 2014 +0000

    auto merge of #19255 : aturon/rust/merge-sync, r=alexcrichton,alexcrichton
    
    This patch merges the `libsync` crate into `libstd`, undoing part of the
    facade. This is in preparation for ultimately merging `librustrt`, as
    well as the upcoming rewrite of `sync`.
    
    Because this removes the `libsync` crate, it is a:
    
    [breaking-change]
    
    However, all uses of `libsync` should be able to reroute through
    `std::sync` and `std::comm` instead.
    
    r? @alexcrichton

commit f6cb58caeedf509cc80dd376bbb2541a0446046b
Merge: 0c1d853 f1f6c12
Author: bors &lt;bors@rust-lang.org&gt;
Date:   Tue Nov 25 09:21:45 2014 +0000

    auto merge of #19149 : alexcrichton/rust/issue-19091, r=aturon
    
    This change applies the conventions to unwrap listed in [RFC 430][rfc] to rename
    non-failing `unwrap` methods to `into_inner`. This is a breaking change, but all
    `unwrap` methods are retained as `#[deprecated]` for the near future. To update
    code rename `unwrap` method calls to `into_inner`.
    
    [rfc]: https://github.com/rust-lang/rfcs/pull/430
    [breaking-change]
    
    cc #19091

commit 36372b929e9d44c7421827b160505854ceeb9a83
Author: Alex Crichton &lt;alex@alexcrichton.com&gt;
Date:   Mon Nov 24 15:54:14 2014 -0800

    std: Export BinarySearchResult
    
    At the same time remove the `pub use` of the variants in favor of accessing
    through the enum type itself. This is a breaking change as the `Found` and
    `NotFound` variants must now be imported through `BinarySearchResult` instead of
    just `std::slice`.
    
    [breaking-change]
    Closes #19272

commit 3b9dfd6af04ca008a4c2ef13b7fd2e8433dc473f
Author: Ben S &lt;ogham@bsago.me&gt;
Date:   Mon Nov 24 19:04:54 2014 +0000

    Clean up FileType enum following enum namespacing
    
    All of the enum components had a redundant 'Type' specifier: TypeSymlink, TypeDirectory, TypeFile. This change removes them, replacing them with a namespace: FileType::Symlink, FileType::Directory, and FileType::RegularFile.
    
    RegularFile is used instead of just File, as File by itself could be mistakenly thought of as referring to the struct.
    
    [breaking-change]

commit 985acfdb67d550d0259fcdcfbeed0a86ec3da9d0
Author: Aaron Turon &lt;aturon@mozilla.com&gt;
Date:   Sun Nov 23 12:52:37 2014 -0800

    Merge libsync into libstd
    
    This patch merges the `libsync` crate into `libstd`, undoing part of the
    facade. This is in preparation for ultimately merging `librustrt`, as
    well as the upcoming rewrite of `sync`.
    
    Because this removes the `libsync` crate, it is a:
    
    [breaking-change]
    
    However, all uses of `libsync` should be able to reroute through
    `std::sync` and `std::comm` instead.

commit bad1062caaaefe0963d7b8513786c8283e74f1e7
Merge: f5b92b4 a9c1152
Author: bors &lt;bors@rust-lang.org&gt;
Date:   Mon Nov 24 09:56:34 2014 +0000

    auto merge of #19094 : alexcrichton/rust/rm-std-local-data, r=aturon
    
    This commit removes the `std::local_data` module in favor of a new `std::thread_local`
    module providing thread local storage. The module provides two variants of TLS:
    one which owns its contents and one which is based on scoped references. Each
    implementation has pros and cons listed in the documentation.
    
    Both flavors have accessors through a function called `with` which yield a
    reference to a closure provided. Both flavors also panic if a reference cannot
    be yielded and provide a function to test whether an access would panic or not.
    This is an implementation of [RFC 461][rfc] and full details can be found in
    that RFC.
    
    This is a breaking change due to the removal of the `std::local_data` module.
    All users can migrate to the new tls system like so:
    
        thread_local!(static FOO: Rc&lt;RefCell&lt;Option&lt;T&gt;&gt;&gt; = Rc::new(RefCell::new(None)))
    
    The old `local_data` module inherently contained the `Rc&lt;RefCell&lt;Option&lt;T&gt;&gt;&gt;` as
    an implementation detail which must now be explicitly stated by users.
    
    [rfc]: https://github.com/rust-lang/rfcs/pull/461
    [breaking-change]

commit a9c1152c4bf72132806cb76045b3464d59db07da
Author: Alex Crichton &lt;alex@alexcrichton.com&gt;
Date:   Fri Nov 14 14:20:57 2014 -0800

    std: Add a new top-level thread_local module
    
    This commit removes the `std::local_data` module in favor of a new
    `std::thread_local` module providing thread local storage. The module provides
    two variants of TLS: one which owns its contents and one which is based on
    scoped references. Each implementation has pros and cons listed in the
    documentation.
    
    Both flavors have accessors through a function called `with` which yield a
    reference to a closure provided. Both flavors also panic if a reference cannot
    be yielded and provide a function to test whether an access would panic or not.
    This is an implementation of [RFC 461][rfc] and full details can be found in
    that RFC.
    
    This is a breaking change due to the removal of the `std::local_data` module.
    All users can migrate to the new thread local system like so:
    
        thread_local!(static FOO: Rc&lt;RefCell&lt;Option&lt;T&gt;&gt;&gt; = Rc::new(RefCell::new(None)))
    
    The old `local_data` module inherently contained the `Rc&lt;RefCell&lt;Option&lt;T&gt;&gt;&gt;` as
    an implementation detail which must now be explicitly stated by users.
    
    [rfc]: https://github.com/rust-lang/rfcs/pull/461
    [breaking-change]

commit f1f6c1286f24f6f762a9b195ac678b55d20c9a9b
Author: Alex Crichton &lt;alex@alexcrichton.com&gt;
Date:   Thu Nov 20 09:23:43 2014 -0800

    Rename unwrap functions to into_inner
    
    This change applies the conventions to unwrap listed in [RFC 430][rfc] to rename
    non-failing `unwrap` methods to `into_inner`. This is a breaking change, but all
    `unwrap` methods are retained as `#[deprecated]` for the near future. To update
    code rename `unwrap` method calls to `into_inner`.
    
    [rfc]: https://github.com/rust-lang/rfcs/pull/430
    [breaking-change]
    
    Closes #13159
    cc #19091

commit 3594c588bb735117621f6a168116d9e1d086654a
Merge: 5ad1512 40e1f8f
Author: Jakub Bukaj &lt;jakub@jakub.cc&gt;
Date:   Sun Nov 23 14:11:56 2014 -0500

    rollup merge of #19211: aochagavia/tuple-index
    
    This breaks code like
    
    ```
    let t = (42i, 42i);
    ... t.0::&lt;int&gt; ...;
    ```
    
    Change this code to not contain an unused type parameter. For example:
    
    ```
    let t = (42i, 42i);
    ... t.0 ...;
    ```
    
    Closes https://github.com/rust-lang/rust/issues/19096
    
    [breaking-change]
    
    r? @aturon

commit b21b48062f114317025c986fe35af21b15c675d9
Merge: 77d1f0b 6733d8b
Author: Jakub Bukaj &lt;jakub@jakub.cc&gt;
Date:   Sun Nov 23 14:11:51 2014 -0500

    rollup merge of #19194: aturon/stab-ascii
    
    This is an initial API stabilization pass for `std::ascii`. Aside from
    some renaming to match conversion conventions, and deprecations in favor
    of using iterators directly, almost nothing is changed here. However,
    the static case conversion tables that were previously public are now private.
    
    The stabilization of the (rather large!) set of extension traits is left
    to a follow-up pass, because we hope to land some more general machinery
    that will provide the same functionality without custom traits.
    
    [breaking-change]

commit 9a857b4472142b6d0bf65e9185c4c2619e722fb0
Author: Adolfo Ochagav√≠a &lt;aochagavia92@gmail.com&gt;
Date:   Sat Nov 22 16:02:49 2014 +0100

    libsyntax: Forbid type parameters in tuple indices
    
    This breaks code like
    
    ```
    let t = (42i, 42i);
    ... t.0::&lt;int&gt; ...;
    ```
    
    Change this code to not contain an unused type parameter. For example:
    
    ```
    let t = (42i, 42i);
    ... t.0 ...;
    ```
    
    Closes https://github.com/rust-lang/rust/issues/19096
    
    [breaking-change]

commit 641e2a110de4bb1b2c2b596ef1168ae7865aa529
Merge: 529f8bc 8ca27a6
Author: bors &lt;bors@rust-lang.org&gt;
Date:   Sun Nov 23 05:46:52 2014 +0000

    auto merge of #19152 : alexcrichton/rust/issue-17863, r=aturon
    
    This commit is an implementation of [RFC 240][rfc] when applied to the standard
    library. It primarily deprecates the entirety of `string::raw`, `vec::raw`,
    `slice::raw`, and `str::raw` in favor of associated functions, methods, and
    other free functions. The detailed renaming is:
    
    * slice::raw::buf_as_slice =&gt; slice::from_raw_buf
    * slice::raw::mut_buf_as_slice =&gt; slice::from_raw_mut_buf
    * slice::shift_ptr =&gt; deprecated with no replacement
    * slice::pop_ptr =&gt; deprecated with no replacement
    * str::raw::from_utf8 =&gt; str::from_utf8_unchecked
    * str::raw::c_str_to_static_slice =&gt; str::from_c_str
    * str::raw::slice_bytes =&gt; deprecated for slice_unchecked (slight semantic diff)
    * str::raw::slice_unchecked =&gt; str.slice_unchecked
    * string::raw::from_parts =&gt; String::from_raw_parts
    * string::raw::from_buf_len =&gt; String::from_raw_buf_len
    * string::raw::from_buf =&gt; String::from_raw_buf
    * string::raw::from_utf8 =&gt; String::from_utf8_unchecked
    * vec::raw::from_buf =&gt; Vec::from_raw_buf
    
    All previous functions exist in their `#[deprecated]` form, and the deprecation
    messages indicate how to migrate to the newer variants.
    
    [rfc]: https://github.com/rust-lang/rfcs/blob/master/text/0240-unsafe-api-location.md
    [breaking-change]
    
    Closes #17863

commit 8ca27a633ed393438a12bbf074b4f2e6063baa6f
Author: Alex Crichton &lt;alex@alexcrichton.com&gt;
Date:   Thu Nov 20 10:11:15 2014 -0800

    std: Align `raw` modules with unsafe conventions
    
    This commit is an implementation of [RFC 240][rfc] when applied to the standard
    library. It primarily deprecates the entirety of `string::raw`, `vec::raw`,
    `slice::raw`, and `str::raw` in favor of associated functions, methods, and
    other free functions. The detailed renaming is:
    
    * slice::raw::buf_as_slice =&gt; slice::with_raw_buf
    * slice::raw::mut_buf_as_slice =&gt; slice::with_raw_mut_buf
    * slice::shift_ptr =&gt; deprecated with no replacement
    * slice::pop_ptr =&gt; deprecated with no replacement
    * str::raw::from_utf8 =&gt; str::from_utf8_unchecked
    * str::raw::c_str_to_static_slice =&gt; str::from_c_str
    * str::raw::slice_bytes =&gt; deprecated for slice_unchecked (slight semantic diff)
    * str::raw::slice_unchecked =&gt; str.slice_unchecked
    * string::raw::from_parts =&gt; String::from_raw_parts
    * string::raw::from_buf_len =&gt; String::from_raw_buf_len
    * string::raw::from_buf =&gt; String::from_raw_buf
    * string::raw::from_utf8 =&gt; String::from_utf8_unchecked
    * vec::raw::from_buf =&gt; Vec::from_raw_buf
    
    All previous functions exist in their `#[deprecated]` form, and the deprecation
    messages indicate how to migrate to the newer variants.
    
    [rfc]: https://github.com/rust-lang/rfcs/blob/master/text/0240-unsafe-api-location.md
    [breaking-change]
    
    Closes #17863

commit 7ce2d9c3fa3d36ae79b9790e3646e5e746e64cf4
Author: Aaron Turon &lt;aturon@mozilla.com&gt;
Date:   Fri Nov 21 12:00:05 2014 -0800

    libs: stabilize ascii module
    
    This is an initial API stabilization pass for `std::ascii`. Aside from
    some renaming to match conversion conventions, and deprecations in favor
    of using iterators directly, almost nothing is changed here. However,
    the static case conversion tables that were previously public are now private.
    
    The stabilization of the (rather large!) set of extension traits is left
    to a follow-up pass, because we hope to land some more general machinery
    that will provide the same functionality without custom traits.
    
    [breaking-change]

commit d6ee804b632ee03679d6de682841fc7785ef4fbb
Author: Brian Anderson &lt;banderson@mozilla.com&gt;
Date:   Mon Nov 3 10:26:22 2014 -0800

    unicode: Convert UnicodeChar methods to by-value
    
    Extension traits for primitive types should be by-value.
    
    [breaking-change]

commit aad246160451aacc2f7a707c028bdf44e77ad38d
Author: Brian Anderson &lt;banderson@mozilla.com&gt;
Date:   Fri Oct 31 16:20:41 2014 -0700

    core: Convert Char::escape_default, escape_unicode to iterators
    
    [breaking-change]

commit ca1820b1fce5aa803ccc757e79dd659f599d1516
Author: Brian Anderson &lt;banderson@mozilla.com&gt;
Date:   Tue Oct 14 13:08:54 2014 -0700

    core: Convert Char methods to by-val self
    
    Methods on primitmive Copy types generally should take `self`.
    
    [breaking-change]

commit c2aff692fa88235d356725f98184a5ea5b52eb88
Author: Brian Anderson &lt;banderson@mozilla.com&gt;
Date:   Wed Oct 8 17:15:27 2014 -0700

    unicode: Rename UnicodeChar::is_digit to is_numeric
    
    'Numeric' is the proper name of the unicode character class,
    and this frees up the word 'digit' for ascii use in libcore.
    
    Since I'm going to rename `Char::is_digit_radix` to
    `is_digit`, I am not leaving a deprecated method in place,
    because that would just cause name clashes, as both
    `Char` and `UnicodeChar` are in the prelude.
    
    [breaking-change]

commit c9f6d696420107f82304b992cf623b806995fe18
Merge: 9830051 32c3d02
Author: bors &lt;bors@rust-lang.org&gt;
Date:   Fri Nov 21 03:41:45 2014 +0000

    auto merge of #18967 : aturon/rust/remove-runtime, r=alexcrichton
    
    This PR completes the removal of the runtime system and green-threaded abstractions as part of implementing [RFC 230](https://github.com/rust-lang/rfcs/pull/230).
    
    Specifically:
    
    * It removes the `Runtime` trait, welding the scheduling infrastructure directly to native threads.
    
    * It removes `libgreen` and `libnative` entirely.
    
    * It rewrites `sync::mutex` as a trivial layer on top of native mutexes. Eventually, the two modules will be merged.
    
    * It hides the vast majority of `std::rt`.
    
    This completes the basic task of removing the runtime system (I/O and scheduling) and components that depend on it.
    
    After this lands, a follow-up PR will pull the `rustrt` crate back into `std`, turn `std::task` into `std::thread` (with API changes to go along with it), and completely cut out the remaining startup/teardown sequence. Other changes, including new [TLS](https://github.com/rust-lang/rfcs/pull/461) and synchronization are in the RFC or pre-RFC phase.
    
    Closes #17325
    Closes #18687
    
    [breaking-change]
    
    r? @alexcrichton

commit 6987ad22e46f55b12d8749be7522f4578d227c62
Author: Aaron Turon &lt;aturon@mozilla.com&gt;
Date:   Fri Nov 14 16:30:16 2014 -0800

    Make most of std::rt private
    
    Previously, the entire runtime API surface was publicly exposed, but
    that is neither necessary nor desirable. This commit hides most of the
    module, using librustrt directly as needed. The arrangement will need to
    be revisited when rustrt is pulled into std.
    
    [breaking-change]

commit 91a2c0d51241677d71b8c0abc80535e580fe3939
Author: Aaron Turon &lt;aturon@mozilla.com&gt;
Date:   Fri Nov 14 13:56:15 2014 -0800

    Remove libgreen
    
    With runtime removal complete, there is no longer any reason to provide
    libgreen.
    
    [breaking-change]

commit 3ee916e50bd86768cb2a9141f9b2c52d2601b412
Author: Aaron Turon &lt;aturon@mozilla.com&gt;
Date:   Fri Nov 14 13:55:57 2014 -0800

    Remove libnative
    
    With runtime removal complete, there's nothing left of libnative. This
    commit removes it.
    
    Fixes #18687
    
    [breaking-change]

commit ad022b1a1bcdb8d2e6d1f200f5824f16de2c2193
Author: Aaron Turon &lt;aturon@mozilla.com&gt;
Date:   Fri Nov 14 13:40:34 2014 -0800

    Remove Runtime trait
    
    This commit removes most of the remaining runtime infrastructure related
    to the green/native split. In particular, it removes the `Runtime` trait
    and instead inlines the native implementation.
    
    Closes #17325
    
    [breaking-change]

commit b825b3496aff1ed784f7a7ca935245208b95aabb
Merge: dd5ce5a c287afb
Author: bors &lt;bors@rust-lang.org&gt;
Date:   Thu Nov 20 10:01:42 2014 +0000

    auto merge of #18638 : aturon/rust/as_slice_dst, r=japaric
    
    This PR changes `AsSlice` to work on unsized types, and changes the
    `impl` for `&amp;[T]` to `[T]`. Aside from making the trait more general,
    this also helps some ongoing work with method resolution changes.
    
    This is a breaking change: code that uses generics bounded by `AsSlice`
    will have to change. In particular, such code previously often took
    arguments of type `V` where `V: AsSlice&lt;T&gt;` by value. These should now
    be taken by reference:
    
    ```rust
    fn foo&lt;Sized? V: AsSlice&lt;T&gt;&gt;(v: &amp;V) { .. }
    ```
    
    A few std lib functions have been changed accordingly.
    
    The PR also relaxes constraints on generics and traits within the
    `core::ops` module and for the `Equiv` trait.
    
    [breaking-change]
    
    r? @nikomatsakis
    cc @japaric

commit 3f3b2d6b7ef68d3a3817804fa4dba849a74e6878
Author: Huon Wilson &lt;dbau.pp+github@gmail.com&gt;
Date:   Tue Nov 18 23:03:58 2014 +1100

    Rename `col!` to `column!`.
    
    This macro is very rarely used, so there is no need (and it is better)
    for it to avoid the abbreviation.
    
    Closes rust-lang/rfcs#467.
    
    [breaking-change]

commit 004db80afe08b28d79741c486ceb8398e6725829
Author: Aaron Turon &lt;aturon@mozilla.com&gt;
Date:   Tue Nov 4 15:31:46 2014 -0800

    libcore: DST-ify AsSlice
    
    This commit changes `AsSlice` to work on unsized types, and changes the
    `impl` for `&amp;[T]` to `[T]`. Aside from making the trait more general,
    this also helps some ongoing work with method resolution changes.
    
    This is a breaking change: code that uses generics bounded by `AsSlice`
    will have to change. In particular, such code previously often took
    arguments of type `V` where `V: AsSlice&lt;T&gt;` by value. These should now
    be taken by reference:
    
    ```rust
    fn foo&lt;Sized? V: AsSlice&lt;T&gt;&gt;(v: &amp;V) { .. }
    ```
    
    A few std lib functions have been changed accordingly.
    
    [breaking-change]

commit 793624261a221aa4592381fa8067e1f597b90c22
Merge: 399ff25 e7fab22
Author: bors &lt;bors@rust-lang.org&gt;
Date:   Thu Nov 20 02:31:31 2014 +0000

    auto merge of #18999 : aturon/rust/stab-floats, r=alexcrichton,alexcrichton
    
    This commit adds stability markers for the APIs that have recently been aligned with [numerics reform](https://github.com/rust-lang/rfcs/pull/369). For APIs that were changed as part of that reform, `#[unstable]` is used to reflect the recency, but the APIs will become `#[stable]` in a follow-up pass.
    
    In addition, a few aspects of the APIs not explicitly covered by the RFC are marked here -- in particular, constants for floats.
    
    This commit does not mark the `uint` or `int` modules as `#[stable]`, given the ongoing debate out the names and roles of these types.
    
    Due to some deprecation (see the RFC for details), this is a:
    
    [breaking-change]
    
    r? @alexcrichton
    cc @bjz

commit 7884dd9cec832e667594aaeed1144a2a9bab3800
Merge: 9b5ec0e 1b5cbd0
Author: Jakub Bukaj &lt;jakub@jakub.cc&gt;
Date:   Wed Nov 19 22:39:29 2014 +0100

    rollup merge of #19087: jakub-/issue-19086
    
    Fixes #19086.
    
    Whilst the code that this PR renders invalid was never meant to be valid, this is still a...
    
    [breaking-change]

commit 1faa09615e02d0d2739ea091cb49c040a5c9c41b
Merge: 8997b09 bde225e
Author: Jakub Bukaj &lt;jakub@jakub.cc&gt;
Date:   Wed Nov 19 22:39:12 2014 +0100

    rollup merge of #19073: jakub-/issue-19069
    
    Fixes #19069.
    
    These were never intended not to be feature-gated but this PR is nonetheless a...
    
    [breaking-change]

commit a22f06db19851bc437aefefb5688eeb9dab79079
Merge: 384f611 4af3494
Author: Jakub Bukaj &lt;jakub@jakub.cc&gt;
Date:   Wed Nov 19 22:38:26 2014 +0100

    rollup merge of #19040: alexcrichton/issue-18904
    
    This commit applies the stabilization of std::fmt as outlined in [RFC 380][rfc].
    There are a number of breaking changes as a part of this commit which will need
    to be handled to migrated old code:
    
    * A number of formatting traits have been removed: String, Bool, Char, Unsigned,
      Signed, and Float. It is recommended to instead use Show wherever possible or
      to use adaptor structs to implement other methods of formatting.
    
    * The format specifier for Boolean has changed from `t` to `b`.
    
    * The enum `FormatError` has been renamed to `Error` as well as becoming a unit
      struct instead of an enum. The `WriteError` variant no longer exists.
    
    * The `format_args_method!` macro has been removed with no replacement. Alter
      code to use the `format_args!` macro instead.
    
    * The public fields of a `Formatter` have become read-only with no replacement.
      Use a new formatting string to alter the formatting flags in combination with
      the `write!` macro. The fields can be accessed through accessor methods on the
      `Formatter` structure.
    
    Other than these breaking changes, the contents of std::fmt should now also all
    contain stability markers. Most of them are still #[unstable] or #[experimental]
    
    [rfc]: https://github.com/rust-lang/rfcs/blob/master/text/0380-stabilize-std-fmt.md
    [breaking-change]
    
    Closes #18904

commit 4af3494bb02e80badc978faa65e59625ade0c675
Author: Alex Crichton &lt;alex@alexcrichton.com&gt;
Date:   Mon Nov 17 11:29:38 2014 -0800

    std: Stabilize std::fmt
    
    This commit applies the stabilization of std::fmt as outlined in [RFC 380][rfc].
    There are a number of breaking changes as a part of this commit which will need
    to be handled to migrated old code:
    
    * A number of formatting traits have been removed: String, Bool, Char, Unsigned,
      Signed, and Float. It is recommended to instead use Show wherever possible or
      to use adaptor structs to implement other methods of formatting.
    
    * The format specifier for Boolean has changed from `t` to `b`.
    
    * The enum `FormatError` has been renamed to `Error` as well as becoming a unit
      struct instead of an enum. The `WriteError` variant no longer exists.
    
    * The `format_args_method!` macro has been removed with no replacement. Alter
      code to use the `format_args!` macro instead.
    
    * The public fields of a `Formatter` have become read-only with no replacement.
      Use a new formatting string to alter the formatting flags in combination with
      the `write!` macro. The fields can be accessed through accessor methods on the
      `Formatter` structure.
    
    Other than these breaking changes, the contents of std::fmt should now also all
    contain stability markers. Most of them are still #[unstable] or #[experimental]
    
    [rfc]: https://github.com/rust-lang/rfcs/blob/master/text/0380-stabilize-std-fmt.md
    [breaking-change]
    
    Closes #18904

commit bdbc09ad484847378b87ee8d60096cd39d8fb47a
Author: Aaron Turon &lt;aturon@mozilla.com&gt;
Date:   Sat Nov 15 22:03:34 2014 -0800

    libs: stabilize most numerics after RFC changes
    
    This commit adds stability markers for the APIs that have recently been
    aligned with [numerics
    reform](https://github.com/rust-lang/rfcs/pull/369). For APIs that were
    changed as part of that reform, `#[unstable]` is used to reflect the
    recency, but the APIs will become `#[stable]` in a follow-up pass.
    
    In addition, a few aspects of the APIs not explicitly covered by the RFC
    are marked here -- in particular, constants for floats.
    
    This commit does not mark the `uint` or `int` modules as `#[stable]`,
    given the ongoing debate out the names and roles of these types.
    
    Due to some deprecation (see the RFC for details), this is a:
    
    [breaking-change]

commit 5de56b3ca1defd9206db8364ecef5f3fd8cc5b38
Author: Barosl Lee &lt;vcs@barosl.com&gt;
Date:   Tue Nov 11 17:13:10 2014 +0900

    Make os::change_dir() return IoResult&lt;()&gt;
    
    os::change_dir() returns bool, without a meaningful error message.
    Change it to return IoResult&lt;()&gt; to indicate what IoError caused the
    failure.
    
    Fixes #16315.
    
    [breaking-change]

commit 6f422c4c05f4d108ba6429a174aa0c2ef3b183fa
Author: Barosl Lee &lt;vcs@barosl.com&gt;
Date:   Tue Nov 11 14:38:20 2014 +0900

    Make os::getcwd() return IoResult&lt;Path&gt;
    
    os::getcwd() panics if the current directory is not available. According
    to getcwd(3), there are three cases:
    
    - EACCES: Permission denied.
    - ENOENT: The current working directory has been removed.
    - ERANGE: The buffer size is less than the actual absolute path.
    
    This commit makes os::getcwd() return IoResult&lt;Path&gt;, not just Path,
    preventing it from panicking.
    
    As os::make_absolute() depends on os::getcwd(), it is also modified to
    return IoResult&lt;Path&gt;.
    
    Fixes #16946.
    
    [breaking-change]

commit c8d6e3b2c2a780eff92299da5d1c02e081617088
Merge: 09e2ad1 6866bf3
Author: bors &lt;bors@rust-lang.org&gt;
Date:   Tue Nov 18 19:11:43 2014 +0000

    auto merge of #18993 : nikomatsakis/rust/hrtb-5, r=pcwalton
    
    Enough said.
    
    Fixes #18639.
    
    r? @pcwalton (or someone else?)
    
    This is a [breaking-change]. In particular, several feature gates related to unboxed closures were consolidated into one (`overloaded_calls`, `unboxed_closure_sugar` =&gt; `unboxed_closures`). Otherwise, I think everything that worked before should still work. File a bug and cc @nikomatsakis if you find otherwise. :)

commit d7a29d87ba6bfca0bfe6207a99c7ec2b7ce869b9
Merge: 516ece6 3fcf284
Author: bors &lt;bors@rust-lang.org&gt;
Date:   Tue Nov 18 13:41:38 2014 +0000

    auto merge of #19031 : nodakai/rust/libcore-pow-and-sq, r=bjz
    
    [breaking-change]
    
    Deprecates `core::num::pow` in favor of `Int::pow`.

commit 7137c2cc83526e1f74af472380e625fc7c552826
Merge: fcf9fb6 46be8eb
Author: Jakub Bukaj &lt;jakub@jakub.cc&gt;
Date:   Tue Nov 18 00:23:53 2014 +0100

    rollup merge of #18910: aturon/borrow-traits
    
    Following [the collections reform RFC](https://github.com/rust-lang/rfcs/pull/235), this PR:
    
    * Adds a new `borrow` module to libcore. The module contains traits for borrowing data (`BorrowFrom` and `BorrowFromMut`), generalized cloning (`ToOwned`), and a clone-on-write smartpointer (`Cow`).
    
    * Deprecates the `_equiv` family of methods on `HashMap` and `HashSet` by instead generalizing the "normal" methods like `get` and `remove` to use the new `std::borrow` infrastructure.
    
    * Generalizes `TreeMap`, `TreeSet`, `BTreeMap` and `BTreeSet` to use the new `std::borrow` infrastructure for lookups.
    
    [breaking-change]

commit 85914df05a95b1d14e483b69d9c4f0eba44b5d25
Author: Nick Cameron &lt;ncameron@mozilla.com&gt;
Date:   Tue Nov 4 14:42:24 2014 +1300

    Disallow coercions from [T, ..n] to &amp;[T]or *[T]
    
    [breaking-change]
    
    Insert an `&amp;` to fix

commit 80a2867ea736007397aa2fbaa0e4c539c80e162c
Author: Aaron Turon &lt;aturon@mozilla.com&gt;
Date:   Wed Nov 12 14:55:51 2014 -0800

    libstd: Deprecate _equiv methods
    
    This commit deprecates the `_equiv` family of methods on `HashMap` and
    `HashSet` by instead generalizing the "normal" methods like `get` and
    `remove` to use the new `std::borrow` infrastructure.
    
    [breaking-change]

commit 5eec666c8c4be3706a79755e6cb1119990390c79
Author: Aaron Turon &lt;aturon@mozilla.com&gt;
Date:   Wed Nov 12 14:55:44 2014 -0800

    libcollections: use BorrowFrom in TreeSet, Map
    
    This commit generalizes methods like `get` and `remove` for `TreeMap`
    and `TreeSet` to use the new `std::borrow` infrastructure.
    
    [breaking-change]

commit f09279395b6ca40f1398277971586197f949738a
Merge: 88c743d 3dcd215
Author: bors &lt;bors@rust-lang.org&gt;
Date:   Mon Nov 17 17:22:06 2014 +0000

    auto merge of #18973 : sfackler/rust/enum-namespace-pt2, r=pcwalton
    
    This breaks code that referred to variant names in the same namespace as
    their enum. Reexport the variants in the old location or alter code to
    refer to the new locations:
    
    ```
    pub enum Foo {
        A,
        B
    }
    
    fn main() {
        let a = A;
    }
    ```
    =&gt;
    ```
    pub use self::Foo::{A, B};
    
    pub enum Foo {
        A,
        B
    }
    
    fn main() {
        let a = A;
    }
    ```
    or
    ```
    pub enum Foo {
        A,
        B
    }
    
    fn main() {
        let a = Foo::A;
    }
    ```
    
    [breaking-change]

commit 3dcd2157403163789aaf21a9ab3c4d30a7c6494d
Author: Steven Fackler &lt;sfackler@gmail.com&gt;
Date:   Thu Nov 6 00:05:53 2014 -0800

    Switch to purely namespaced enums
    
    This breaks code that referred to variant names in the same namespace as
    their enum. Reexport the variants in the old location or alter code to
    refer to the new locations:
    
    ```
    pub enum Foo {
        A,
        B
    }
    
    fn main() {
        let a = A;
    }
    ```
    =&gt;
    ```
    pub use self::Foo::{A, B};
    
    pub enum Foo {
        A,
        B
    }
    
    fn main() {
        let a = A;
    }
    ```
    or
    ```
    pub enum Foo {
        A,
        B
    }
    
    fn main() {
        let a = Foo::A;
    }
    ```
    
    [breaking-change]

commit 197a0ac481ae6d154c0966b21849432f1b32c28f
Author: Andrew Cann &lt;shum@canndrew.org&gt;
Date:   Mon Nov 17 17:35:18 2014 +0800

    change return type of slice_shift_char
    
    `slice_shift_char` splits a `str` into it's leading `char` and the remainder
    of the `str`. Currently, it returns a `(Option&lt;char&gt;, &amp;str)` such that:
    
        "bar".slice_shift_char() =&gt; (Some('b'), "ar")
        "ar".slice_shift_char()  =&gt; (Some('a'), "r")
        "r".slice_shift_char()   =&gt; (Some('r'), "")
        "".slice_shift_char()    =&gt; (None,      "")
    
    This is a little odd. Either a `str` can be split into both a head and a
    tail or it cannot. So the return type should be `Option&lt;(char, &amp;str)&gt;`.
    With the current behaviour, in the case of the empty string, the `str`
    returned is meaningless - it is always the empty string.
    
    This commit changes slice_shift_char so that:
    
        "bar".slice_shift_char() =&gt; Some(('b', "ar"))
        "ar".slice_shift_char()  =&gt; Some(('a', "r"))
        "r".slice_shift_char()   =&gt; Some(('r', ""))
        "".slice_shift_char()    =&gt; None
    
    [breaking-change]

commit edfb83c9e28df2a8f326d688f3d5b1f6faa72db8
Merge: 803aacd dfb7a81
Author: bors &lt;bors@rust-lang.org&gt;
Date:   Mon Nov 17 09:26:57 2014 +0000

    auto merge of #18914 : Gankro/rust/cloned, r=aturon
    
    Part of #18424. r? @aturon
    
    [breaking-change]

commit aad75471fd327c0138f80aba46c650a7f9839d17
Merge: 321488b 579c65d
Author: bors &lt;bors@rust-lang.org&gt;
Date:   Sun Nov 16 18:27:10 2014 +0000

    auto merge of #18994 : sfackler/rust/struct-variants-pt2, r=jakub-
    
    Struct variant field visibility is now inherited. Remove `pub` keywords
    from declarations.
    
    Closes #18641
    
    [breaking-change]
    
    r? @alexcrichton

commit eb01b17b06eb35542bb80ff7456043b0ed5572ba
Author: Jakub Bukaj &lt;jakub@jakub.cc&gt;
Date:   Sun Nov 9 16:14:15 2014 +0100

    Complete the removal of ty_nil, ast::LitNil, ast::TyBot and ast::TyUniq
    
    [breaking-change]
    
    This will break any uses of macros that assumed () being a valid literal.

commit cb51567e1911452f3da4b924a91e5360f5efe67c
Merge: 7e43f41 43fd644
Author: bors &lt;bors@rust-lang.org&gt;
Date:   Sun Nov 16 04:37:36 2014 +0000

    auto merge of #18788 : ricky26/rust/master, r=aturon
    
    This moves chars() and lines() out of Buffer and into separate traits (CharsBuffer and LinesBuffer respectively) - this matches the pattern used for bytes() on Reader (with BytesReader).
    
    (I came across this when I wanted a trait object of a Buffer, so that I could use read_line(); rustc errors about std::io::Buffer not being object-safe.)
    
    [breaking-change]
    Any uses of Buffer::lines() will need to use the new trait std::io::LinesBuffer.
    The same is true for Buffer::chars() with std::io::CharsBuffer.

commit 579c65da1babbcfa5f3fd1cb5a1062acbe5b61eb
Author: Steven Fackler &lt;sfackler@gmail.com&gt;
Date:   Sat Nov 15 17:57:54 2014 -0800

    Un-feature gate struct variants
    
    Struct variant field visibility is now inherited. Remove `pub` keywords
    from declarations.
    
    Closes #18641
    
    [breaking-change]

commit 93c4942690753e982cbb4bf6667940da71c5d286
Author: Jonathan Reem &lt;jonathan.reem@gmail.com&gt;
Date:   Thu Nov 13 18:04:28 2014 -0800

    Rewrite std::sync::TaskPool to be load balancing and panic-resistant
    
    The previous implementation was very likely to cause panics during
    unwinding through this process:
    
    - child panics, drops its receiver
    - taskpool comes back around and sends another job over to that child
    - the child receiver has hung up, so the taskpool panics on send
    - during unwinding, the taskpool attempts to send a quit message to
      the child, causing a panic during unwinding
    - panic during unwinding causes a process abort
    
    This meant that TaskPool upgraded any child panic to a full process
    abort. This came up in Iron when it caused crashes in long-running
    servers.
    
    This implementation uses a single channel to communicate between
    spawned tasks and the TaskPool, which significantly reduces the complexity
    of the implementation and cuts down on allocation. The TaskPool uses
    the channel as a single-producer-multiple-consumer queue.
    
    Additionally, through the use of send_opt and recv_opt instead of
    send and recv, this TaskPool is robust on the face of child panics,
    both before, during, and after the TaskPool itself is dropped.
    
    Due to the TaskPool no longer using an `init_fn_factory`, this is a
    
    [breaking-change]
    
    otherwise, the API has not changed.
    
    If you used `init_fn_factory` in your code, and this change breaks for
    you, you can instead use an `AtomicUint` counter and a channel to
    move information into child tasks.

commit 6f7081fad5889c7b41460103fc8abc98f3285c60
Merge: a58fc68 c9e6bda
Author: bors &lt;bors@rust-lang.org&gt;
Date:   Fri Nov 14 05:37:17 2014 +0000

    auto merge of #18827 : bjz/rust/rfc369-numerics, r=alexcrichton
    
    This implements a considerable portion of rust-lang/rfcs#369 (tracked in #18640). Some interpretations had to be made in order to get this to work. The breaking changes are listed below:
    
    [breaking-change]
    
    - `core::num::{Num, Unsigned, Primitive}` have been deprecated and their re-exports removed from the `{std, core}::prelude`.
    - `core::num::{Zero, One, Bounded}` have been deprecated. Use the static methods on `core::num::{Float, Int}` instead. There is no equivalent to `Zero::is_zero`. Use `(==)` with `{Float, Int}::zero` instead.
    - `Signed::abs_sub` has been moved to `std::num::FloatMath`, and is no longer implemented for signed integers.
    - `core::num::Signed` has been removed, and its methods have been moved to `core::num::Float` and a new trait, `core::num::SignedInt`. The methods now take the `self` parameter by value.
    - `core::num::{Saturating, CheckedAdd, CheckedSub, CheckedMul, CheckedDiv}` have been removed, and their methods moved to `core::num::Int`. Their parameters are now taken by value. This means that
    - `std::time::Duration` no longer implements `core::num::{Zero, CheckedAdd, CheckedSub}` instead defining the required methods non-polymorphically.
    - `core::num::{zero, one, abs, signum}` have been deprecated. Use their respective methods instead.
    - The `core::num::{next_power_of_two, is_power_of_two, checked_next_power_of_two}` functions have been deprecated in favor of methods defined a new trait, `core::num::UnsignedInt`
    - `core::iter::{AdditiveIterator, MultiplicativeIterator}` are now only implemented for the built-in numeric types.
    - `core::iter::{range, range_inclusive, range_step, range_step_inclusive}` now require `core::num::Int` to be implemented for the type they a re parametrized over.

commit 43fd6446add0bcf237f3fe15b7d715eceee2a08c
Author: Ricky Taylor &lt;rickytaylor26@gmail.com&gt;
Date:   Sat Nov 8 21:59:09 2014 +0000

    Make std::io::Buffer object-safe.
    
    [breaking-change]
    Any uses of Buffer::lines() and Buffer::chars() will need to use the new trait std::io::BufferPrelude.

commit 82f383839c7cc0ce66d7cfbd400182b535029f0f
Merge: f6c0250 e6e58e4
Author: bors &lt;bors@rust-lang.org&gt;
Date:   Thu Nov 13 12:27:03 2014 +0000

    auto merge of #18879 : pcwalton/rust/path-silliness, r=aturon
    
    This breaks code like:
    
        struct Foo {
            x: int,
        }
    
        let f: Foo = ...;
        ... f.x::&lt;int&gt; ...
    
    Change this code to not contain an unused type parameter. For example:
    
        struct Foo {
            x: int,
        }
    
        let f: Foo = ...;
        ... f.x ...
    
    Closes #18680.
    
    [breaking-change]
    
    r? @aturon

commit 5745e419502d753deb3f42026fa35e015bc5d3fb
Merge: 7a86aa8 fcd05ed
Author: bors &lt;bors@rust-lang.org&gt;
Date:   Wed Nov 12 22:57:16 2014 +0000

    auto merge of #18858 : alexcrichton/rust/remove-time, r=jakub
    
    This commit deprecates the entire libtime library in favor of the
    externally-provided libtime in the rust-lang organization. Users of the
    `libtime` crate as-is today should add this to their Cargo manifests:
    
        [dependencies.time]
        git = "https://github.com/rust-lang/time"
    
    To implement this transition, a new function `Duration::span` was added to the
    `std::time::Duration` time. This function takes a closure and then returns the
    duration of time it took that closure to execute. This interface will likely
    improve with `FnOnce` unboxed closures as moving in and out will be a little
    easier.
    
    Due to the deprecation of the in-tree crate, this is a:
    
    [breaking-change]
    
    cc #18855, some of the conversions in the `src/test/bench` area may have been a
    little nicer with that implemented

commit fcd05ed99ff0aa6157e427a698ac53dbc450135f
Author: Alex Crichton &lt;alex@alexcrichton.com&gt;
Date:   Mon Nov 10 12:27:56 2014 -0800

    time: Deprecate the library in the distribution
    
    This commit deprecates the entire libtime library in favor of the
    externally-provided libtime in the rust-lang organization. Users of the
    `libtime` crate as-is today should add this to their Cargo manifests:
    
        [dependencies.time]
        git = "https://github.com/rust-lang/time"
    
    To implement this transition, a new function `Duration::span` was added to the
    `std::time::Duration` time. This function takes a closure and then returns the
    duration of time it took that closure to execute. This interface will likely
    improve with `FnOnce` unboxed closures as moving in and out will be a little
    easier.
    
    Due to the deprecation of the in-tree crate, this is a:
    
    [breaking-change]
    
    cc #18855, some of the conversions in the `src/test/bench` area may have been a
    little nicer with that implemented

commit e6e58e43f8f9507474fdf35544b6b0c0fc6cef39
Author: Patrick Walton &lt;pcwalton@mimiga.net&gt;
Date:   Tue Nov 11 10:45:59 2014 -0800

    libsyntax: Forbid type parameters in field expressions.
    
    This breaks code like:
    
        struct Foo {
            x: int,
        }
    
        let f: Foo = ...;
        ... f.x::&lt;int&gt; ...
    
    Change this code to not contain an unused type parameter. For example:
    
        struct Foo {
            x: int,
        }
    
        let f: Foo = ...;
        ... f.x ...
    
    Closes #18680.
    
    [breaking-change]

commit 16d80de231abb2b1756f3951ffd4776d681035eb
Merge: a2f303a 5ea09e6
Author: bors &lt;bors@rust-lang.org&gt;
Date:   Sun Nov 9 05:51:44 2014 +0000

    auto merge of #18557 : aturon/rust/io-removal, r=alexcrichton
    
    This PR includes a sequence of commits that gradually dismantles the `librustrt` `rtio` system -- the main trait previously used to abstract over green and native io. It also largely dismantles `libnative`, moving much of its code into `libstd` and refactoring as it does so.
    
    TL;DR:
    
    * Before this PR: `rustc hello.rs &amp;&amp; wc -c hello` produces 715,996
    * After this PR:  `rustc hello.rs &amp;&amp; wc -c hello` produces 368,100
    
    That is, this PR reduces the footprint of hello world by ~50%.
    
    This is a major step toward #17325 (i.e. toward implementing the [runtime removal RFC](https://github.com/rust-lang/rfcs/pull/230).) What remains is to pull out the scheduling, synchronization and task infrastructure, and to remove `libgreen`. These will be done soon in a follow-up PR.
    
    Part of the work here is eliminating the `rtio` abstraction, which in many cases means bringing the implementation of io closer to the actual API presented in `std::io`.
    
    Another aspect of this PR is the creation of two new, *private* modules within `std` that implement io:
    
    * The `sys` module, which represents a platform-specific implementation of a number of low-level abstractions that are used directly within `std::io` and `std::os`. These "abstractions" are left largely the same as they were in `libnative` (except for the removal of `Arc` in file descriptors), but they are expected to evolve greatly over time. Organizationally, there are `sys/unix/` and `sys/windows/` directories which both implement the entire `sys` module hierarchy; this means that nearly all of the platform-specific code is isolated and you can get a handle on each platform in isolation.
    
    * The `sys_common` module, which is rooted at `sys/common`, and provides a few pieces of private, low-level, but cross-platform functionality.
    
    In the long term, the `sys` modules will provide hooks for exposing high-level platform-specific APIs as part of `libstd`. The first such API will be access to file descriptors from `std::io` abstractions, but a bit of design work remains before that step can be taken.
    
    The `sys_common` module includes some traits (like `AsFileDesc`) which allow communication of private details between modules in disparate locations in the hierarchy; this helps overcome the relatively simple hierarchical privacy system in Rust.
    
    To emphasize: the organization in `sys` is *very preliminary* and the main goal was to migrate away from `rtio` as quickly and simply as possible. The design will certainly evolve over time, and all of the details are currently private.
    
    Along the way, this PR also entirely removes signal handling, since it was only supported on `librustuv` which was removed a while ago.
    
    Because of the removal of APIs from `libnative` and `librustrt`, and the removal of signal handling, this is a:
    
    [breaking-change]
    
    Some of these APIs will return in public from from `std` over time.
    
    r? @alexcrichton

commit fa94fdad3e880d2d6cbd82c12bd12caefbeb81a8
Author: Aaron Turon &lt;aturon@mozilla.com&gt;
Date:   Fri Oct 17 13:39:27 2014 -0700

    Runtime removal: fully remove rtio
    
    This patch cleans up the remnants of the runtime IO interface.
    
    Because this eliminates APIs in `libnative` and `librustrt`, it is a:
    
    [breaking-change]
    
    This functionality is likely to be available publicly, in some form,
    from `std` in the future.

commit 431dcdc840a27f7c7418b7dff73a329eada8a407
Author: Aaron Turon &lt;aturon@mozilla.com&gt;
Date:   Fri Oct 17 13:33:08 2014 -0700

    Runtime removal: refactor tty
    
    This patch continues runtime removal by moving the tty implementations
    into `sys`.
    
    Because this eliminates APIs in `libnative` and `librustrt`, it is a:
    
    [breaking-change]
    
    This functionality is likely to be available publicly, in some form,
    from `std` in the future.

commit b8f1193bb1bb66610f479cd78e3dc5526e93058d
Author: Aaron Turon &lt;aturon@mozilla.com&gt;
Date:   Thu Oct 16 18:57:11 2014 -0700

    Runtime removal: refactor timer
    
    This patch continues runtime removal by moving out timer-related code
    into `sys`.
    
    Because this eliminates APIs in `libnative` and `librustrt`, it is a:
    
    [breaking-change]
    
    This functionality is likely to be available publicly, in some form,
    from `std` in the future.

commit 0f98e75b69d16edce9ca60d7961b8440856a3f72
Author: Aaron Turon &lt;aturon@mozilla.com&gt;
Date:   Thu Oct 9 16:27:28 2014 -0700

    Runtime removal: refactor process
    
    This patch continues the runtime removal by moving and refactoring the
    process implementation into the new `sys` module.
    
    Because this eliminates APIs in `libnative` and `librustrt`, it is a:
    
    [breaking-change]
    
    This functionality is likely to be available publicly, in some form,
    from `std` in the future.

commit 3d195482a45bf3ed0f12dc9d70d14192262ca711
Author: Aaron Turon &lt;aturon@mozilla.com&gt;
Date:   Wed Oct 15 15:45:59 2014 -0700

    Runtime removal: refactor helper threads
    
    This patch continues the runtime removal by moving
    libnative::io::helper_thread into sys::helper_signal and
    sys_common::helper_thread
    
    Because this eliminates APIs in `libnative` and `librustrt`, it is a:
    
    [breaking-change]
    
    This functionality is likely to be available publicly, in some form,
    from `std` in the future.

commit d34b1b0ca9bf5e0d7cd30952f5de0ab09ed57b41
Author: Aaron Turon &lt;aturon@mozilla.com&gt;
Date:   Fri Oct 10 10:11:49 2014 -0700

    Runtime removal: refactor pipes and networking
    
    This patch continues the runtime removal by moving pipe and
    networking-related code into `sys`.
    
    Because this eliminates APIs in `libnative` and `librustrt`, it is a:
    
    [breaking-change]
    
    This functionality is likely to be available publicly, in some form,
    from `std` in the future.

commit 0c1e1ff1e300868a29405a334e65eae690df971d
Author: Aaron Turon &lt;aturon@mozilla.com&gt;
Date:   Tue Sep 30 17:34:14 2014 -0700

    Runtime removal: refactor fs
    
    This moves the filesystem implementation from libnative into the new
    `sys` modules, refactoring along the way and hooking into `std::io::fs`.
    
    Because this eliminates APIs in `libnative` and `librustrt`, it is a:
    
    [breaking-change]
    
    This functionality is likely to be available publicly, in some form,
    from `std` in the future.

commit 16470cf01b688c576f47b93bdb4af88db33cf1e1
Author: Aaron Turon &lt;aturon@mozilla.com&gt;
Date:   Thu Oct 9 16:40:05 2014 -0700

    Remove signal handling.
    
    Since signal handling was only implemented through librustuv, which is
    now gone, there's no reason to even provide the API.
    
    [breaking-change]

commit a2f303ad098844351d08800038a4f99fa2ff0817
Merge: 93c85eb cf4e53e
Author: bors &lt;bors@rust-lang.org&gt;
Date:   Sun Nov 9 03:51:41 2014 +0000

    auto merge of #18743 : nikomatsakis/rust/hrtb-refactor-2, r=pcwalton
    
    Various miscellaneous changes pushing towards HRTB support:
    
    1. Update parser and adjust ast to support `for&lt;'a,'b&gt;` syntax, both in closures and trait bounds. Warn on the old syntax (not error, for stage0).
    2. Refactor TyTrait representation to include a TraitRef.
    3. Purge `once_fns` feature gate and `once` keyword.
    
    r? @pcwalton
    
    This is a [breaking-change]:
    
    - The `once_fns` feature is now officially deprecated. Rewrite using normal closures or unboxed closures.
    - The new `for`-based syntax now issues warnings (but not yet errors):
      - `fn&lt;'a&gt;(T) -&gt; U` becomes `for&lt;'a&gt; fn(T) -&gt; U`
      - `&lt;'a&gt; |T| -&gt; U` becomes `for&lt;'a&gt; |T| -&gt; U`

commit 16c8cd931cd5ccc9c73b87cac488938556018019
Author: gamazeps &lt;gamaz3ps@gmail.com&gt;
Date:   Sat Nov 8 01:39:39 2014 +0100

    Renamed Extendable to Extend
    
    In order to upgrade, simply rename the Extendable trait to Extend in
    your code
    
    Part of #18424
    
    [breaking-change]

commit afd657e20724f6a9093e34818c4923aa8601cafb
Merge: 7bc3588 7ddf8cb
Author: bors &lt;bors@rust-lang.org&gt;
Date:   Sat Nov 8 07:06:36 2014 +0000

    auto merge of #18556 : seanmonstar/rust/tm-fmt, r=alexcrichton
    
    The internals of strftime were converted to use a single formatter,
    instead of creating and concatenating a bunch of small strings. This
    showed ~3x improvement in the benches.
    
    Also, since the formatted time may be going straight to a Writer, TmFmt
    was introduced, and is returned from all formatting methods on Tm. This
    allows the saving of another string allocation. Anyone wanting a String
    can just call .to_string() on the returned value.
    
    This runs validation prior to return the created `TmFmt`, catching errors before formatting happens. The specialized formats skip this validation, since we already know they are valid.
    
    [breaking-change]

commit 7ddf8cb0e02549e6df7afe7e8486d735f8ee7eae
Author: Sean McArthur &lt;sean.monstar@gmail.com&gt;
Date:   Wed Sep 3 14:56:35 2014 -0700

    libtime: alter strftime to use a TmFmt
    
    The internals of strftime were converted to use a single formatter,
    instead of creating and concatenating a bunch of small strings. This
    showed ~3x improvement in the benches.
    
    Also, since the formatted time may be going straight to a Writer, TmFmt
    was introduced, and is returned from all formatting methods on Tm. This
    allows the saving of another string allocation. Anyone wanting a String
    can just call .to_string() on the returned value.
    
    [breaking-change]

commit 0b48001c28329392b26961eaf1c3ed293a352d6f
Merge: 223ca76 00676c8
Author: bors &lt;bors@rust-lang.org&gt;
Date:   Fri Nov 7 15:26:26 2014 +0000

    auto merge of #17830 : pczarn/rust/interp_tt, r=pnkfelix
    
    Closes #14197
    
    Removes the `matchers` nonterminal.
    
    If you're using `$foo:matchers` in a macro, write `$foo:tt` instead.
    
    [breaking-change]

commit b39f1dcba0d79fa9b791e6d0735b411795f44979
Author: Alex Crichton &lt;alex@alexcrichton.com&gt;
Date:   Tue Nov 4 11:22:32 2014 -0800

    Remove rlibc from the distribution
    
    To make progress on #18585 we're paring down the distribution to theoretically
    "only libstd", and this commit makes progress on this by removing the rlibc
    crate from the distribution.
    
    The crate has now been moved into an external cargo package located in the rust
    lang organization [1]. This is a breaking change due to this removal, and
    existing crates depending on `rlibc` should use the Cargo crate instead.
    
    [1]: https://github.com/rust-lang/rlibc
    
    [breaking-change]
    cc #18585

commit cf3b2e4fe6044cce018b723de9b21c500c6eac41
Author: Alexis Beingessner &lt;a.beingessner@gmail.com&gt;
Date:   Thu Nov 6 12:24:47 2014 -0500

    Implement low-hanging fruit of collection conventions
    
    * Renames/deprecates the simplest and most obvious methods
    * Adds FIXME(conventions)s for outstanding work
    * Marks "handled" methods as unstable
    
    NOTE: the semantics of reserve and reserve_exact have changed!
    Other methods have had their semantics changed as well, but in a
    way that should obviously not typecheck if used incorrectly.
    
    Lots of work and breakage to come, but this handles most of the core
    APIs and most eggregious breakage. Future changes should *mostly* focus on
    niche collections, APIs, or simply back-compat additions.
    
    [breaking-change]

commit 8ed288edb27fc83b15a549af69c82b5bb4f8ac1e
Merge: 60a669a cfafc1b
Author: bors &lt;bors@rust-lang.org&gt;
Date:   Thu Nov 6 16:52:09 2014 +0000

    auto merge of #18559 : aturon/rust/prelude_cleanup, r=alexcrichton
    
    This commit renames a number of extension traits for slices and string slices, now that they have been refactored for DST. In many cases, multiple extension traits could now be consolidated. Further consolidation will be possible with generalized where clauses.
    
    The renamings are consistent with the [new `-Prelude` suffix](https://github.com/rust-lang/rfcs/pull/344). There are probably a few more candidates for being renamed this way, but that is left for API stabilization of the relevant modules.
    
    Because this renames traits, it is a:
    
    [breaking-change]
    
    However, I do not expect any code that currently uses the standard library to actually break.
    
    Closes #17917

commit cfafc1b7377d34d8c60db7cd386836d39b80af41
Author: Aaron Turon &lt;aturon@mozilla.com&gt;
Date:   Sun Nov 2 17:04:32 2014 -0800

    Prelude: rename and consolidate extension traits
    
    This commit renames a number of extension traits for slices and string
    slices, now that they have been refactored for DST. In many cases,
    multiple extension traits could now be consolidated. Further
    consolidation will be possible with generalized where clauses.
    
    The renamings are consistent with the [new `-Prelude`
    suffix](https://github.com/rust-lang/rfcs/pull/344). There are probably
    a few more candidates for being renamed this way, but that is left for
    API stabilization of the relevant modules.
    
    Because this renames traits, it is a:
    
    [breaking-change]
    
    However, I do not expect any code that currently uses the standard
    library to actually break.
    
    Closes #17917

commit e84e7a00ddec76570bbaa9afea385d544f616814
Merge: 0e2f9b9 11f4bae
Author: bors &lt;bors@rust-lang.org&gt;
Date:   Thu Nov 6 08:06:50 2014 +0000

    auto merge of #18467 : japaric/rust/eq, r=alexcrichton
    
    `eq`, `ne`, `cmp`, etc methods now require one less level of indirection when dealing with `&amp;str`/`&amp;[T]`
    
    ``` rust
    "foo".ne(&amp;"bar") -&gt; "foo".ne("bar")
    slice.cmp(&amp;another_slice) -&gt; slice.cmp(another_slice)
    // slice and another_slice have type `&amp;[T]`
    ```
    
    [breaking-change]

commit 63c4f22f2bf9f1c070311cdc08c6ceb279434733
Merge: 5c1fd5f 81c00e6
Author: bors &lt;bors@rust-lang.org&gt;
Date:   Wed Nov 5 22:31:44 2014 +0000

    auto merge of #18486 : nikomatsakis/rust/operator-dispatch, r=pcwalton
    
    This branch cleans up overloaded operator resolution so that it is strictly based on the traits in `ops`, rather than going through the normal method lookup mechanism. It also adds full support for autoderef to overloaded index (whereas before autoderef only worked for non-overloaded index) as well as for the slicing operators.
    
    This is a [breaking-change]: in the past, we were accepting combinations of operands that were not intended to be accepted. For example, it was possible to compare a fixed-length array and a slice, or apply the `!` operator to a `&amp;int`. See the first two commits in this pull-request for examples.
    
    One downside of this change is that comparing fixed-length arrays doesn't always work as smoothly as it did before. Before this, comparisons sometimes worked due to various coercions to slices. I've added impls for `Eq`, `Ord`, etc for fixed-lengths arrays up to and including length 32, but if the array is longer than that you'll need to either newtype the array or convert to slices. Note that this plays better with deriving in any case than the previous scheme.
    
    Fixes #4920.
    Fixes #16821.
    Fixes #15757.
    
    cc @alexcrichton
    cc @aturon

commit 7e3344b17f777f5bca0d3eaa9278fa2d628ca064
Author: Vladimir Matveev &lt;vladimir.matweev@gmail.com&gt;
Date:   Wed Oct 29 22:59:43 2014 +0300

    Migrated io::net::udp over to ToSocketAddr
    
    UdpSocket constructor methods now use ToSocketAddr trait instead of
    SocketAddr.
    
    [breaking-change]

commit ac846749f0abbd0b6107406ba2f97886605e1ad4
Author: Vladimir Matveev &lt;vladimir.matweev@gmail.com&gt;
Date:   Wed Oct 22 23:00:47 2014 +0400

    Switched io::net::tcp to use ToSocketAddr
    
    TcpListener and TcpStream are converted to use ToSocketAddr trait in
    their constructor methods.
    
    [breaking-change]

commit eca8f11315cb3cd9836e6d8501a07fbb137f5e88
Merge: 4375b32 3036b00
Author: bors &lt;bors@rust-lang.org&gt;
Date:   Wed Nov 5 07:01:38 2014 +0000

    auto merge of #18592 : alexcrichton/rust/dylib-harder, r=pcwalton
    
    If a dylib is being produced, the compiler will now first check to see if it can
    be created entirely statically before falling back to dynamic dependencies. This
    behavior can be overridden with `-C prefer-dynamic`.
    
    Due to the alteration in behavior, this is a breaking change. Any previous users
    relying on dylibs implicitly maximizing dynamic dependencies should start
    passing `-C prefer-dynamic` to compilations.
    
    Closes #18499
    [breaking-change]
</pre></body></html>
