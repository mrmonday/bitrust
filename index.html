<!DOCTYPE html><html><head>
<title>BitRust - Breaking Changes in rust-lang/rust</title>
</head><body><pre>
commit 7e11b22713aebd28ceaaa2ecef937c9b9d247c2f
Merge: 14597f9 85c1a4b
Author: bors &lt;bors@rust-lang.org&gt;
Date:   Wed Dec 24 20:47:12 2014 +0000

    auto merge of #20117 : lfairy/rust/rename-include-bin, r=alexcrichton
    
    According to [RFC 344][], methods that return `&amp;[u8]` should have names ending in `bytes`. Though `include_bin!` is a macro not a method, it seems reasonable to follow the convention anyway.
    
    We keep the old name around for now, but trigger a deprecation warning when it is used.
    
    [RFC 344]: https://github.com/rust-lang/rfcs/blob/master/text/0344-conventions-galore.md
    
    [breaking-change]

commit 96a3c7c6a051ab2f5fc01fe9e686f7fffcc87c61
Merge: d10642e 16f01cc
Author: bors &lt;bors@rust-lang.org&gt;
Date:   Tue Dec 23 22:21:10 2014 +0000

    auto merge of #19758 : tbu-/rust/pr_fp_name, r=alexcrichton
    
    This is a [breaking-change].

commit 16f01cc13f6a092873096c44eed546561b88d245
Author: Tobias Bucher &lt;tobiasbucher5991@gmail.com&gt;
Date:   Mon Dec 22 22:50:57 2014 +0100

    Rename and namespace `FPCategory`
    
    Rename `FPCategory` to `FpCategory` and `Fp* to `*` in order to adhere to the
    naming convention
    
    This is a [breaking-change].
    
    Existing code like this:
    ```
    use std::num::{FPCategory, FPNaN};
    ```
    should be adjusted to this:
    ```
    use std::num::FpCategory as Fp
    ```
    
    In the following code you can use the constants `Fp::Nan`, `Fp::Normal`, etc.

commit 85c1a4b1ba09dae786b3554e0ab596814efabe0e
Author: Chris Wong &lt;lambda.fairy@gmail.com&gt;
Date:   Mon Dec 22 10:57:09 2014 +1300

    Rename include_bin! to include_bytes!
    
    According to [RFC 344][], methods that return `&amp;[u8]` should have names
    ending in `bytes`. Though `include_bin!` is a macro not a method, it
    seems reasonable to follow the convention anyway.
    
    We keep the old name around for now, but trigger a deprecation warning
    when it is used.
    
    [RFC 344]: https://github.com/rust-lang/rfcs/blob/master/text/0344-conventions-galore.md
    
    [breaking-change]

commit fac17defcb8d0642c25bf8f791e1dc5b4e110be8
Merge: ca441df 02feaf2
Author: Alex Crichton &lt;alex@alexcrichton.com&gt;
Date:   Mon Dec 22 12:48:16 2014 -0800

    rollup merge of #20140: frewsxcv/rm-reexports
    
    Part of #19253
    
    I would have removed this public reexport in #19842, but #19812 hadn't merged (and snapshotted) at the time
    
    In #19407, I changed the codebase to stop utilizing this reexport
    
    [breaking-change]

commit 4baeacef5a539fa29b88c951d6eca996d6101148
Merge: 7311b63 ee9de3b
Author: Alex Crichton &lt;alex@alexcrichton.com&gt;
Date:   Mon Dec 22 12:47:31 2014 -0800

    rollup merge of #20075: skade/remove-notrust
    
    Internally refactor all mentions of `notrust` to the
    positive statement `rust`.
    
    [breaking-change] Change remaining `notrust` markers to
    the thing they actually represent, e.g. `sh` or `plain`.
    
    This supersedes #19693 .

commit 7311b6347de4205b71e8a221140a527e789fd353
Merge: b04bc5c abf492d
Author: Alex Crichton &lt;alex@alexcrichton.com&gt;
Date:   Mon Dec 22 12:47:11 2014 -0800

    rollup merge of #20053: csouth3/misc-stab
    
    This pull request:
    
    *Renames `BinaryHeap::top` to `BinaryHeap::peek`
    *Stabilizes `front/back/front_mut/back_mut` in `DList` and `RingBuf`
    *Stabilizes `swap` in `RingBuf`
    
    in accordance with rust-lang/rfcs#509.
    
    Note that this PR does not address `Bitv::{get,set}` or HashMap's iterators, nor does it move `std::vec` to `std::collections::vec`, all of which still need to be done.
    
    Because of the method renaming, this is a [breaking-change].

commit b04bc5cc49a398df712092a68ab9ad83019498ad
Merge: 9b99436 a76a802
Author: Alex Crichton &lt;alex@alexcrichton.com&gt;
Date:   Mon Dec 22 12:46:31 2014 -0800

    rollup merge of #20033: alexcrichton/deprecate-serialise
    
    This commit completes the deprecation story for the in-tree serialization
    library. The compiler will now emit a warning whenever it encounters
    `deriving(Encodable)` or `deriving(Decodable)`, and the library itself is now
    marked `#[unstable]` for when feature staging is enabled.
    
    All users of serialization can migrate to the `rustc-serialize` crate on
    crates.io which provides the exact same interface as the libserialize library
    in-tree. The new deriving modes are named `RustcEncodable` and `RustcDecodable`
    and require `extern crate "rustc-serialize" as rustc_serialize` at the crate
    root in order to expand correctly.
    
    To migrate all crates, add the following to your `Cargo.toml`:
    
        [dependencies]
        rustc-serialize = "0.1.1"
    
    And then add the following to your crate root:
    
        extern crate "rustc-serialize" as rustc_serialize;
    
    Finally, rename `Encodable` and `Decodable` deriving modes to `RustcEncodable`
    and `RustcDecodable`.
    
    [breaking-change]

commit 2f55a9db0de8b2a2d72c7139eae38272d4d8cf41
Merge: 34d6800 20d7a5f
Author: Alex Crichton &lt;alex@alexcrichton.com&gt;
Date:   Mon Dec 22 12:45:52 2014 -0800

    rollup merge of #19216: Gankro/bitv
    
    Part of #18424
    
    This commit changes the semantics of `reserve` and `capacity` for Bitv and BitvSet to match conventions. It also introduces the notion of `reserve_index` and `reserve_index_exact` for collections with maximum-index-based capacity semantics.
    
    Deprecates free function constructors in favour of functions on Bitv itself.
    
    Changes `Bitv::pop` to return an Option rather than panicking.
    
    Deprecates and renames several methods in favour of conventions.
    
    Marks several blessed methods as unstable.
    
    This commit also substantially refactors Bitv and BitvSet's implementations. The new implementation is simpler, cleaner, better documented, and more robust against overflows. It also reduces coupling between Bitv and BitvSet. Tests have been seperated into seperate submodules.
    
    Fixes #16958
    
    [breaking-change]

commit 02feaf2a804e4e810d5a3adbedbcbe3905692286
Author: Corey Farwell &lt;coreyf@rwell.org&gt;
Date:   Mon Dec 22 11:09:55 2014 -0800

    Remove cmp::Ordering::* public reexport
    
    Part of #19253
    
    I would have removed this public reexport in #19842, but #19812 hadn't merged (and snapshotted) at the time
    
    In #19407, I changed the codebase to stop utilizing this reexport
    
    [breaking-change]

commit 22050e3ed44d9b4d79edced506b470a425e0d302
Author: Florian Wilkens &lt;floya@live.de&gt;
Date:   Sat Dec 20 15:28:20 2014 +0100

    Added missing renames:
    
    libcollections:
        AbsEntries -&gt; AbsIter, Entries -&gt; Iter, MoveEntries -&gt; IntoIter, MutEntries -&gt; IterMut
        DifferenceItems -&gt; Difference, SymDifferenceItems -&gt; SymmetricDifference, IntersectionItems -&gt; Intersection, UnionItems -&gt; Union
    
    libstd/hash/{table, map}:
        Entries -&gt; Iter, MoveItems -&gt; IntoIter, MutEntries -&gt; IterMut
    
    Also a [breaking-change].

commit f8cfd2480b69a1cc266fc91d0b60c825a9dc18a7
Author: Florian Wilkens &lt;floya@live.de&gt;
Date:   Fri Dec 19 21:52:10 2014 +0100

    Renaming of the Iter types as in RFC #344
    
    libcore: slice::Items -&gt; slice::Iter, slice::MutItems -&gt; slice::IterMut
    libcollections: *::Items -&gt; *::Iter, *::MoveItems -&gt; *::IntoIter, *::MutItems -&gt; *::IterMut
    
    This is of course a [breaking-change].

commit a76a80276852f05f30adaa4d2a8a2729b5fc0bfa
Author: Alex Crichton &lt;alex@alexcrichton.com&gt;
Date:   Thu Dec 18 22:52:48 2014 -0800

    serialize: Fully deprecate the library
    
    This commit completes the deprecation story for the in-tree serialization
    library. The compiler will now emit a warning whenever it encounters
    `deriving(Encodable)` or `deriving(Decodable)`, and the library itself is now
    marked `#[unstable]` for when feature staging is enabled.
    
    All users of serialization can migrate to the `rustc-serialize` crate on
    crates.io which provides the exact same interface as the libserialize library
    in-tree. The new deriving modes are named `RustcEncodable` and `RustcDecodable`
    and require `extern crate "rustc-serialize" as rustc_serialize` at the crate
    root in order to expand correctly.
    
    To migrate all crates, add the following to your `Cargo.toml`:
    
        [dependencies]
        rustc-serialize = "0.1.1"
    
    And then add the following to your crate root:
    
        extern crate "rustc-serialize" as rustc_serialize;
    
    Finally, rename `Encodable` and `Decodable` deriving modes to `RustcEncodable`
    and `RustcDecodable`.
    
    [breaking-change]

commit abf492d44f0a3b705be8c0920bfb4771f039b843
Author: Chase Southwood &lt;chase.southwood@gmail.com&gt;
Date:   Fri Dec 19 17:53:40 2014 -0600

    Misc Stabilization for collections
    
    This commit:
    
    *Renames `BinaryHeap::top` to `BinaryHeap::peek`
    *Stabilizes `front/back/front_mut/back_mut` in `DList` and `RingBuf`
    *Stabilizes `swap` in `RingBuf`
    
    Because of the method renaming, this is a [breaking-change].

commit 25f8051f2ebdc9444e0f75e91dc0cbb45d194181
Merge: bc99ced 98af642
Author: Alex Crichton &lt;alex@alexcrichton.com&gt;
Date:   Sun Dec 21 00:03:59 2014 -0800

    rollup merge of #19842: frewsxcv/rm-reexports
    
    Remove most of the public reexports mentioned in #19253
    
    These are all leftovers from the enum namespacing transition
    
    In particular:
    
    * src/libstd/num/strconv.rs
     * ExponentFormat
     * SignificantDigits
     * SignFormat
    * src/libstd/path/windows.rs
     * PathPrefix
    * src/libstd/sys/windows/timer.rs
     * Req
    * src/libcollections/str.rs
     * MaybeOwned
    * src/libstd/collections/hash/map.rs
     * Entry
    * src/libstd/collections/hash/table.rs
     * BucketState
    * src/libstd/dynamic_lib.rs
     * Rtld
    * src/libstd/os.rs
     * MemoryMapKind
     * MapOption
     * MapError
    * src/libstd/sys/common/net.rs
     * SocketStatus
     * InAddr
    * src/libstd/sys/unix/timer.rs
     * Req
    
    [breaking-change]

commit 98af642f5c8f60ae141a5d3ff92e8cc4e4317342
Author: Corey Farwell &lt;coreyf@rwell.org&gt;
Date:   Sat Dec 13 11:15:18 2014 -0500

    Remove a ton of public reexports
    
    Remove most of the public reexports mentioned in #19253
    
    These are all leftovers from the enum namespacing transition
    
    In particular:
    
    * src/libstd/num/strconv.rs
     * ExponentFormat
     * SignificantDigits
     * SignFormat
    * src/libstd/path/windows.rs
     * PathPrefix
    * src/libstd/sys/windows/timer.rs
     * Req
    * src/libcollections/str.rs
     * MaybeOwned
    * src/libstd/collections/hash/map.rs
     * Entry
    * src/libstd/collections/hash/table.rs
     * BucketState
    * src/libstd/dynamic_lib.rs
     * Rtld
    * src/libstd/io/net/ip.rs
     * IpAddr
    * src/libstd/os.rs
     * MemoryMapKind
     * MapOption
     * MapError
    * src/libstd/sys/common/net.rs
     * SocketStatus
     * InAddr
    * src/libstd/sys/unix/timer.rs
     * Req
    
    [breaking-change]

commit 9c5101542d2a4983ade627bc593e16c0bb5f23ba
Author: Alexis Beingessner &lt;a.beingessner@gmail.com&gt;
Date:   Fri Nov 21 20:47:40 2014 -0500

    Conventions and cleanup for Bitv and BitvSet
    
    Part of #18424
    
    This commit changes the semantics of `reserve` and `capacity` for Bitv and BitvSet to match conventions. It also introduces the notion of `reserve_index` and `reserve_index_exact` for collections with maximum-index-based capacity semantics.
    
    Deprecates free function constructors in favour of functions on Bitv itself.
    
    Changes `Bitv::pop` to return an Option rather than panicking.
    
    Deprecates and renames several methods in favour of conventions.
    
    Marks several blessed methods as unstable.
    
    This commit also substantially refactors Bitv and BitvSet's implementations. The new implementation is simpler, cleaner, better documented, and more robust against overflows. It also reduces coupling between Bitv and BitvSet. Tests have been seperated into seperate submodules.
    
    Fixes #16958
    
    [breaking-change]

commit cf350ea5eb562fcfb67775ad4d847e441a8006a4
Author: bluss &lt;bluss&gt;
Date:   Fri Dec 19 21:54:50 2014 +0100

    hashset: Clean up and rename the HashSet iterators
    
    This removes the type SetAlgebraItems and replaces it with the
    structs Intersection and Difference.
    
    Rename the existing HashSet iterators according to RFC #344:
    
    * SetItems -&gt; Iter
    * SetMoveItems -&gt; IntoIter
    * Remaining set combination iterators renamed to Union and SymmetricDifference
    
    [breaking-change]

commit 0efafac398ff7f28c5f0fe756c15b9008b3e0534
Merge: 6bdce25 903c5a8
Author: bors &lt;bors@rust-lang.org&gt;
Date:   Fri Dec 19 08:28:52 2014 +0000

    auto merge of #19654 : aturon/rust/merge-rt, r=alexcrichton
    
    This PR substantially narrows the notion of a "runtime" in Rust, and allows calling into Rust code directly without any setup or teardown.
    
    After this PR, the basic "runtime support" in Rust will consist of:
    
    * Unwinding and backtrace support
    * Stack guards
    
    Other support, such as helper threads for timers or the notion of a "current thread" are initialized automatically upon first use.
    
    When using Rust in an embedded context, it should now be possible to call a Rust function directly as a C function with absolutely no setup, though in that case panics will cause the process to abort. In this regard, the C/Rust interface will look much like the C/C++ interface.
    
    In more detail, this PR:
    
    * Merges `librustrt` back into `std::rt`, undoing the facade. While doing so, it removes a substantial amount of redundant functionality (such as mutexes defined in the `rt` module). Code using `librustrt` can now call into `std::rt` to e.g. start executing Rust code with unwinding support.
    
    * Allows all runtime data to be initialized lazily, including the "current thread", the "at_exit" infrastructure, and the "args" storage.
    
    * Deprecates and largely removes `std::task` along with the widespread requirement that there be a "current task" for many APIs in `std`. The entire task infrastructure is replaced with `std::thread`, which provides a more standard API for manipulating and creating native OS threads. In particular, it's possible to join on a created thread, and to get a handle to the currently-running thread. In addition, threads are equipped with some basic blocking support in the form of `park`/`unpark` operations (following a tradition in some OSes as well as the JVM). See the `std::thread` documentation for more details.
    
    * Channels are refactored to use a new internal blocking infrastructure that itself sits on top of `park`/`unpark`.
    
    One important change here is that a Rust program ends when its main thread does, following most threading models. On the other hand, threads will often be created with an RAII-style join handle that will re-institute blocking semantics naturally (and with finer control).
    
    This is very much a:
    
    [breaking-change]
    
    Closes #18000
    r? @alexcrichton

commit 903c5a8f69714382ec9fc22745f902c3e219cb68
Author: Aaron Turon &lt;aturon@mozilla.com&gt;
Date:   Thu Dec 18 23:29:30 2014 -0800

    Disable at_exit handlers
    
    The [final step](https://github.com/rust-lang/rust/pull/19654) of
    runtime removal changes the threading/process model so that the process
    shuts down when the main thread exits. But several shared resources,
    like the helper thread for timeouts, are shut down when the main thread
    exits (but before the process ends), and they are not prepared to be
    used after shut down, but other threads may try to access them during
    the shutdown sequence of the main thread.
    
    As an interim solution, the `at_exit` cleanup routine is simply skipped.
    
    Ultimately, these resources should be made to safely handle asynchronous
    shutdown, usually by panicking if called from a detached thread when the
    main thread is ending.
    
    See issue for details https://github.com/rust-lang/rust/issues/20012
    
    This is a [breaking-change] for anyone relying on `at_exit`.

commit a27fbac86849e07a0a6c746869d8f78319bd3a16
Author: Aaron Turon &lt;aturon@mozilla.com&gt;
Date:   Sun Dec 14 00:05:32 2014 -0800

    Revise std::thread API to join by default
    
    This commit is part of a series that introduces a `std::thread` API to
    replace `std::task`.
    
    In the new API, `spawn` returns a `JoinGuard`, which by default will
    join the spawned thread when dropped. It can also be used to join
    explicitly at any time, returning the thread's result. Alternatively,
    the spawned thread can be explicitly detached (so no join takes place).
    
    As part of this change, Rust processes now terminate when the main
    thread exits, even if other detached threads are still running, moving
    Rust closer to standard threading models. This new behavior may break code
    that was relying on the previously implicit join-all.
    
    In addition to the above, the new thread API also offers some built-in
    support for building blocking abstractions in user space; see the module
    doc for details.
    
    Closes #18000
    
    [breaking-change]

commit 9b03b72d7fb82f07d35e7dcda02754c6da90ae58
Author: Aaron Turon &lt;aturon@mozilla.com&gt;
Date:   Mon Nov 24 17:33:37 2014 -0800

    Remove rt::bookkeeping
    
    This commit removes the runtime bookkeeping previously used to ensure
    that all Rust tasks were joined before the runtime was shut down.
    
    This functionality will be replaced by an RAII style `Thread` API, that
    will also offer a detached mode.
    
    Since this changes the semantics of shutdown, it is a:
    
    [breaking-change]

commit 2b3477d373603527d23cc578f3737857b7b253d7
Author: Aaron Turon &lt;aturon@mozilla.com&gt;
Date:   Sun Nov 23 19:21:17 2014 -0800

    libs: merge librustrt into libstd
    
    This commit merges the `rustrt` crate into `std`, undoing part of the
    facade. This merger continues the paring down of the runtime system.
    
    Code relying on the public API of `rustrt` will break; some of this API
    is now available through `std::rt`, but is likely to change and/or be
    removed very soon.
    
    [breaking-change]

commit 6bdce25e155d846bb9252fa4a18baef7e74cf8bf
Merge: 840de07 9b5de39
Author: bors &lt;bors@rust-lang.org&gt;
Date:   Fri Dec 19 06:12:01 2014 +0000

    auto merge of #19899 : japaric/rust/unops-by-value, r=nikomatsakis
    
    - The following operator traits now take their argument by value: `Neg`, `Not`. This breaks all existing implementations of these traits.
    
    - The unary operation `OP a` now "desugars" to `OpTrait::op_method(a)` and consumes its argument.
    
    [breaking-change]
    
    ---
    
    r? @nikomatsakis This PR is very similar to the binops-by-value PR
    cc @aturon

commit 840de072085df360733c48396224e9966e2dc72c
Merge: 99d6956 67d3823
Author: bors &lt;bors@rust-lang.org&gt;
Date:   Fri Dec 19 02:52:01 2014 +0000

    auto merge of #19955 : Gankro/rust/kill-all-code, r=aturon
    
    EnumSet lives on in libcollections so that librustc can still use it. This adds a direct dependency on libcollections to librustc and libserialize.
    
    Should not be merged until https://github.com/rust-lang/rfcs/pull/509 is accepted.
    
    All of these collections have already been moved to collect-rs where they will ideally be maintained and experimented with, or will be replaced by something better: https://github.com/Gankro/collect-rs/
    
    [breaking-change]
    
    r? @aturon @alexcrichton

commit f9a48492a82f805aa40d8b6fea290badbab0d1b1
Merge: c4d58ce ddb2466
Author: bors &lt;bors@rust-lang.org&gt;
Date:   Thu Dec 18 17:32:07 2014 +0000

    auto merge of #19984 : japaric/rust/macro-expressions, r=alexcrichton
    
    followed by a semicolon.
    
    This allows code like `vec![1i, 2, 3].len();` to work.
    
    This breaks code that uses macros as statements without putting
    semicolons after them, such as:
    
        fn main() {
            ...
            assert!(a == b)
            assert!(c == d)
            println(...);
        }
    
    It also breaks code that uses macros as items without semicolons:
    
        local_data_key!(foo)
    
        fn main() {
            println("hello world")
        }
    
    Add semicolons to fix this code. Those two examples can be fixed as
    follows:
    
        fn main() {
            ...
            assert!(a == b);
            assert!(c == d);
            println(...);
        }
    
        local_data_key!(foo);
    
        fn main() {
            println("hello world")
        }
    
    RFC #378.
    
    Closes #18635.
    
    [breaking-change]
    
    ---
    
    Rebased version of #18958
    r? @alexcrichton
    cc @pcwalton

commit ddb2466f6a1bb66f22824334022a4cee61c73bdc
Author: Patrick Walton &lt;pcwalton@mimiga.net&gt;
Date:   Fri Nov 14 09:18:10 2014 -0800

    librustc: Always parse `macro!()`/`macro![]` as expressions if not
    followed by a semicolon.
    
    This allows code like `vec![1i, 2, 3].len();` to work.
    
    This breaks code that uses macros as statements without putting
    semicolons after them, such as:
    
        fn main() {
            ...
            assert!(a == b)
            assert!(c == d)
            println(...);
        }
    
    It also breaks code that uses macros as items without semicolons:
    
        local_data_key!(foo)
    
        fn main() {
            println("hello world")
        }
    
    Add semicolons to fix this code. Those two examples can be fixed as
    follows:
    
        fn main() {
            ...
            assert!(a == b);
            assert!(c == d);
            println(...);
        }
    
        local_data_key!(foo);
    
        fn main() {
            println("hello world")
        }
    
    RFC #378.
    
    Closes #18635.
    
    [breaking-change]

commit 137a3dbffd5454874bf001e213f695644b78523a
Merge: dea69e6 1fbca88
Author: Alex Crichton &lt;alex@alexcrichton.com&gt;
Date:   Wed Dec 17 08:34:14 2014 -0800

    rollup merge of #19849: alexcrichton/second-pass-option
    
    This commit takes a second pass through the `std::option` module to fully
    stabilize any lingering methods inside of it.
    
    These items were made stable as-is
    
    * Some
    * None
    * as_mut
    * expect
    * unwrap
    * unwrap_or
    * unwrap_or_else
    * map
    * map_or
    * map_or_else
    * and_then
    * or_else
    * unwrap_or_default
    * Default implementation
    * FromIterator implementation
    * Copy implementation
    
    These items were made stable with modifications
    
    * iter - now returns a struct called Iter
    * iter_mut - now returns a struct called IterMut
    * into_iter - now returns a struct called IntoIter, Clone is never implemented
    
    This is a breaking change due to the modifications to the names of the iterator
    types returned. Code referencing the old names should updated to referencing the
    newer names instead. This is also a breaking change due to the fact that
    `IntoIter` no longer implements the `Clone` trait.
    
    These items were explicitly not stabilized
    
    * as_slice - waiting on indexing conventions
    * as_mut_slice - waiting on conventions with as_slice as well
    * cloned - the API was still just recently added
    * ok_or - API remains experimental
    * ok_or_else - API remains experimental
    
    [breaking-change]

commit 5294ceb312b059709f204300156b732cc78cfaf0
Merge: 974e17b c2b0d7d
Author: Alex Crichton &lt;alex@alexcrichton.com&gt;
Date:   Wed Dec 17 08:34:01 2014 -0800

    rollup merge of #19818: emk/regex_at_name_opt
    
    Hello! This is my first Rust patch, and I fear that I've probably skipped at least 7 critical steps. I'd appreciate your feedback and advice about how to contribute to Rust.
    
    This patch is based on a discussion with @BurntSushi in #14602 a while back. I'm happy to revise it as needed to fit into the modern world. :-)
    
    As discussed in that issue, the existing `at` and `name` functions represent two different results with the empty string:
    
    1. Matched the empty string.
    2. Did not match anything.
    
    Consider the following example.  This regex has two named matched groups, `key` and `value`. `value` is optional:
    
    ```rust
    // Matches "foo", "foo;v=bar" and "foo;v=".
    regex!(r"(?P&lt;key&gt;[a-z]+)(;v=(?P&lt;value&gt;[a-z]*))?");
    ```
    
    We can access `value` using `caps.name("value")`, but there's no way for us to distinguish between the `"foo"` and `"foo;v="` cases.
    
    Early this year, @BurntSushi recommended modifying the existing `at` and `name` functions to return `Option`, instead of adding new functions to the API.
    
    This is a [breaking-change], but the fix is easy:
    
    - `refs.at(1)` becomes `refs.at(1).unwrap_or("")`.
    - `refs.name(name)` becomes `refs.name(name).unwrap_or("")`.

commit 974e17b9ea63b38b4a512742fc877a7e4ee94e03
Merge: 126a83f 341cf40
Author: Alex Crichton &lt;alex@alexcrichton.com&gt;
Date:   Wed Dec 17 08:33:58 2014 -0800

    rollup merge of #19770: csouth3/iterator-wrapperstructs
    
    Using a type alias for iterator implementations is fragile since this exposes the implementation to users of the iterator, and any changes could break existing code.
    
    This PR changes the iterators of `BTreeMap`, `BTreeSet`, `HashMap`, and `HashSet` to use proper new types, rather than type aliases.  However, since it is fair-game to treat a type-alias as the aliased type, this is a:
    
    [breaking-change].

commit 71201234d2ed3f20637fc373df063e7750cbc0ad
Merge: 66c297d 81f9a31
Author: Alex Crichton &lt;alex@alexcrichton.com&gt;
Date:   Wed Dec 17 08:33:44 2014 -0800

    rollup merge of #19720: csouth3/vecmap-newtypes
    
    Using a type alias for iterator implementations is fragile since this
    exposes the implementation to users of the iterator, and any changes
    could break existing code.
    
    This commit changes the iterators of `VecMap` to use
    proper new types, rather than type aliases.  However, since it is
    fair-game to treat a type-alias as the aliased type, this is a:
    
    [breaking-change].

commit 4265e86844b6f328ed8a0d144d02a935706c35ee
Merge: 42deaa5 769aa0a
Author: bors &lt;bors@rust-lang.org&gt;
Date:   Wed Dec 17 02:42:57 2014 +0000

    auto merge of #19761 : nick29581/rust/coerce-double, r=nikomatsakis
    
    Part of #18469
    
    [breaking-change]
    
    A receiver will only ever get a single auto-reference. Previously arrays and strings would get two, e.g., [T] would be auto-ref'ed to &amp;&amp;[T]. This is usually apparent when a trait is implemented for `&amp;[T]` and has a method takes self by reference. The usual solution is to implement the trait for `[T]` (the DST form).
    
    r? @nikomatsakis (or anyone else, really)

commit 769aa0a7b378a7b71f5bcbec3485fe171ff4f3b9
Author: Nick Cameron &lt;ncameron@mozilla.com&gt;
Date:   Fri Dec 12 13:23:21 2014 +1300

    Remove the double auto-ref on arrays/strings as receivers
    
    Part of #18469
    
    [breaking-change]
    
    A receiver will only ever get a single auto-reference. Previously arrays and strings would get two, e.g., [T] would be auto-ref'ed to &amp;&amp;[T]. This is usually apparent when a trait is implemented for `&amp;[T]` and has a method takes self by reference. The usual solution is to implement the trait for `[T]` (the DST form).

commit 341cf405e5be56b9b1c8f3be6d0fe9a014eeff26
Author: Chase Southwood &lt;chase.southwood@gmail.com&gt;
Date:   Sat Dec 13 12:36:05 2014 -0600

    Use wrapper structs for `HashSet`'s iterators.
    
    Using a type alias for iterator implementations is fragile since this
    exposes the implementation to users of the iterator, and any changes
    could break existing code.
    
    This commit changes the iterators of `HashSet` to use
    proper new types, rather than type aliases.  However, since it is
    fair-game to treat a type-alias as the aliased type, this is a:
    
    [breaking-change].

commit 85fe141fb7c066e88a6872e74347c5f34d0223a7
Author: Chase Southwood &lt;chase.southwood@gmail.com&gt;
Date:   Fri Dec 12 01:02:19 2014 -0600

    Use wrapper structs for `HashMap`'s iterators.
    
    Using a type alias for iterator implementations is fragile since this
    exposes the implementation to users of the iterator, and any changes
    could break existing code.
    
    This commit changes the keys and values iterators of `HashMap` to use
    proper new types, rather than type aliases.  However, since it is
    fair-game to treat a type-alias as the aliased type, this is a:
    
    [breaking-change].

commit a81c3ab468ad7aebcab8a545b196e74c2fb3ac32
Author: Chase Southwood &lt;chase.southwood@gmail.com&gt;
Date:   Fri Dec 12 23:14:57 2014 -0600

    Use wrapper structs for `BTreeSet`'s iterators.
    
    Using a type alias for iterator implementations is fragile since this
    exposes the implementation to users of the iterator, and any changes
    could break existing code.
    
    This commit changes the iterators of `BTreeSet` to use
    proper new types, rather than type aliases.  However, since it is
    fair-game to treat a type-alias as the aliased type, this is a:
    
    [breaking-change].

commit 765806ef1ee93b352b724aa76870d23d82894e4e
Author: Chase Southwood &lt;chase.southwood@gmail.com&gt;
Date:   Fri Dec 12 00:04:47 2014 -0600

    Use wrapper structs for `BTreeMap`'s iterators.
    
    Using a type alias for iterator implementations is fragile since this
    exposes the implementation to users of the iterator, and any changes
    could break existing code.
    
    This commit changes the keys and values iterators of `BTreeMap` to use
    proper new types, rather than type aliases.  However, since it is
    fair-game to treat a type-alias as the aliased type, this is a:
    
    [breaking-change].

commit 0669a432a2e09ad08886cb2138dbe9f5d681fb7f
Merge: 92e9e70 89d2061
Author: bors &lt;bors@rust-lang.org&gt;
Date:   Mon Dec 15 22:11:44 2014 +0000

    auto merge of #19448 : japaric/rust/binops-by-value, r=nikomatsakis
    
    - The following operator traits now take their arguments by value: `Add`, `Sub`, `Mul`, `Div`, `Rem`, `BitAnd`, `BitOr`, `BitXor`, `Shl`, `Shr`. This breaks all existing implementations of these traits.
    
    - The binary operation `a OP b` now "desugars" to `OpTrait::op_method(a, b)` and consumes both arguments.
    
    - `String` and `Vec` addition have been changed to reuse the LHS owned value, and to avoid internal cloning. Only the following asymmetric operations are available: `String + &amp;str` and `Vec&lt;T&gt; + &amp;[T]`, which are now a short-hand for the "append" operation.
    
    [breaking-change]
    
    ---
    
    This passes `make check` locally. I haven't touch the unary operators in this PR, but converting them to by value should be very similar to this PR. I can work on them after this gets the thumbs up.
    
    @nikomatsakis r? the compiler changes
    @aturon r? the library changes. I think the only controversial bit is the semantic change of the `Vec`/`String` `Add` implementation.
    cc #19148

commit c9ea7c9a58bc2bcfe77d264cedaeca5a3296634a
Author: Alex Crichton &lt;alex@alexcrichton.com&gt;
Date:   Mon Dec 15 09:06:06 2014 -0800

    serialize: Change some FnOnce bounds to FnMut
    
    Relax some of the bounds on the decoder methods back to FnMut to help accomodate
    some more flavorful variants of decoders which may need to run the closure more
    than once when it, for example, attempts to find the first successful enum to
    decode.
    
    This a breaking change due to the bounds for the trait switching, and clients
    will need to update from `FnOnce` to `FnMut` as well as likely making the local
    function binding mutable in order to call the function.
    
    [breaking-change]

commit b60de4bfc2cf45ebe16b9b5b768f0aad54211625
Author: Niko Matsakis &lt;niko@alum.mit.edu&gt;
Date:   Fri Dec 12 11:09:24 2014 -0500

    Emit warning when lifetime names are shadowed.
    
    This is not technically a [breaking-change], but it will be soon, so
    you should update your code. Typically, shadowing is accidental, and
    the shadowing lifetime can simply be removed. This frequently occurs
    in constructor patterns:
    
    ```rust
    // Old:
    impl&lt;'a&gt; SomeStruct&lt;'a&gt; { fn new&lt;'a&gt;(..) -&gt; SomeStruct&lt;'a&gt; { ... } }
    
    // Should be:
    impl&lt;'a&gt; SomeStruct&lt;'a&gt; { fn new(..) -&gt; SomeStruct&lt;'a&gt; { ... } }
    ```
    
    Otherwise, you should rename the inner lifetime to something
    else. Note though that lifetime elision frequently applies:
    
    ```rust
    // Old
    impl&lt;'a&gt; SomeStruct&lt;'a&gt; {
        fn get&lt;'a&gt;(x: &amp;'a self) -&gt; &amp;'a T { &amp;self.field }
    }
    
    // Should be:
    impl&lt;'a&gt; SomeStruct&lt;'a&gt; {
        fn get(x: &amp;self) -&gt; &amp;T { &amp;self.field }
    }
    ``

commit 1fbca8824a6b6018191b7ee998d2c97f30c481d7
Author: Alex Crichton &lt;alex@alexcrichton.com&gt;
Date:   Sun Dec 14 10:34:23 2014 -0800

    std: Fully stabilize Option&lt;T&gt;
    
    This commit takes a second pass through the `std::option` module to fully
    stabilize any lingering methods inside of it.
    
    These items were made stable as-is
    
    * Some
    * None
    * as_mut
    * expect
    * unwrap
    * unwrap_or
    * unwrap_or_else
    * map
    * map_or
    * map_or_else
    * and_then
    * or_else
    * unwrap_or_default
    * Default implementation
    * FromIterator implementation
    * Copy implementation
    
    These items were made stable with modifications
    
    * iter - now returns a struct called Iter
    * iter_mut - now returns a struct called IterMut
    * into_iter - now returns a struct called IntoIter, Clone is never implemented
    
    This is a breaking change due to the modifications to the names of the iterator
    types returned. Code referencing the old names should updated to referencing the
    newer names instead. This is also a breaking change due to the fact that
    `IntoIter` no longer implements the `Clone` trait.
    
    These items were explicitly not stabilized
    
    * as_slice - waiting on indexing conventions
    * as_mut_slice - waiting on conventions with as_slice as well
    * cloned - the API was still just recently added
    * ok_or - API remains experimental
    * ok_or_else - API remains experimental
    
    [breaking-change]

commit c2b0d7dd8818a0dca9b1fa7af6873375907f05ca
Author: Eric Kidd &lt;git@randomhacks.net&gt;
Date:   Sat Dec 13 13:33:18 2014 -0500

    Modify `regex::Captures::{at,name}` to return `Option`
    
    Closes #14602.  As discussed in that issue, the existing `at` and `name`
    functions represent two different results with the empty string:
    
    1. Matched the empty string.
    2. Did not match anything.
    
    Consider the following example.  This regex has two named matched
    groups, `key` and `value`. `value` is optional:
    
    ```rust
    // Matches "foo", "foo;v=bar" and "foo;v=".
    regex!(r"(?P&lt;key&gt;[a-z]+)(;v=(?P&lt;value&gt;[a-z]*))?");
    ```
    
    We can access `value` using `caps.name("value")`, but there's no way for
    us to distinguish between the `"foo"` and `"foo;v="` cases.
    
    Early this year, @BurntSushi recommended modifying the existing `at` and
    `name` functions to return `Option`, instead of adding new functions to
    the API.
    
    This is a [breaking-change], but the fix is easy:
    
    - `refs.at(1)` becomes `refs.at(1).unwrap_or("")`.
    - `refs.name(name)` becomes `refs.name(name).unwrap_or("")`.

commit 52f7a4a351646d3837f214b5c7aec390c9b08221
Merge: 3a9305c f6d60f3
Author: bors &lt;bors@rust-lang.org&gt;
Date:   Sun Dec 14 11:37:27 2014 +0000

    auto merge of #19338 : nikomatsakis/rust/unboxed-closure-purge-the-proc, r=acrichto
    
    They are replaced with unboxed closures.
    
    cc @pcwalton @aturon
    
    This is a [breaking-change]. Mostly, uses of `proc()` simply need to be converted to `move||` (unboxed closures), but in some cases the adaptations required are more complex (particularly for library authors). A detailed write-up can be found here: http://smallcultfollowing.com/babysteps/blog/2014/11/26/purging-proc/
    
    The commits are ordered to emphasize the more important changes, but are not truly standalone.

commit 81f9a319265ddbe6b7823b50c29e3aff076d82c1
Author: Chase Southwood &lt;chase.southwood@gmail.com&gt;
Date:   Wed Dec 10 23:12:31 2014 -0600

    Change `VecMap`'s iterators to use wrapper structs instead of typedefs.
    
    Using a type alias for iterator implementations is fragile since this
    exposes the implementation to users of the iterator, and any changes
    could break existing code.
    
    This commit changes the iterators of `VecMap` to use
    proper new types, rather than type aliases.  However, since it is
    fair-game to treat a type-alias as the aliased type, this is a:
    
    [breaking-change].

commit 444fa1b7cffcd99ca5b8abb51acf979f06a25899
Merge: 567b90f b8e0b81
Author: bors &lt;bors@rust-lang.org&gt;
Date:   Sat Dec 13 22:57:21 2014 +0000

    auto merge of #19467 : japaric/rust/uc, r=alexcrichton
    
    This PR moves almost all our current uses of closures, both in public API and internal uses, to the new "unboxed" closures system.
    
    In most cases, downstream code that *only uses* closures will continue to work as it is. The reason is that the `|| {}` syntax can be inferred either as a boxed or an "unboxed" closure according to the context. For example the following code will continue to work:
    
    ``` rust
    some_option.map(|x| x.transform_with(upvar))
    ```
    
    And will get silently upgraded to an "unboxed" closure.
    
    In some other cases, it may be necessary to "annotate" which `Fn*` trait the closure implements:
    
    ```
    // Change this
    |x| { /* body */}
    // to either of these
    |: x| { /* body */}  // closure implements the FnOnce trait
    |&amp;mut : x| { /* body */}  // FnMut
    |&amp;: x| { /* body */}  // Fn
    ```
    
    This mainly occurs when the closure is assigned to a variable first, and then passed to a function/method.
    
    ``` rust
    let closure = |: x| x.transform_with(upvar);
    some.option.map(closure)
    ```
    
    (It's very likely that in the future, an improved inference engine will make this annotation unnecessary)
    
    Other cases that require annotation are closures that implement some trait via a blanket `impl`, for example:
    
    - `std::finally::Finally`
    - `regex::Replacer`
    - `std::str::CharEq`
    
    ``` rust
    string.trim_left_chars(|c: char| c.is_whitespace())
    //~^ ERROR: the trait `Fn&lt;(char,), bool&gt;` is not implemented for the type `|char| -&gt; bool`
    string.trim_left_chars(|&amp;: c: char| c.is_whitespace())  // OK
    ```
    
    Finally, all implementations of traits that contain boxed closures in the arguments of their methods are now broken. And will need to be updated to use unboxed closures. These are the main affected traits:
    
    - `serialize::Decoder`
    - `serialize::DecoderHelpers`
    - `serialize::Encoder`
    - `serialize::EncoderHelpers`
    - `rustrt::ToCStr`
    
    For example, change this:
    
    ``` rust
    // libserialize/json.rs
    impl&lt;'a&gt; Encoder&lt;io::IoError&gt; for Encoder&lt;'a&gt; {
        fn emit_enum(&amp;mut self,
                     _name: &amp;str,
                     f: |&amp;mut Encoder&lt;'a&gt;| -&gt; EncodeResult) -&gt; EncodeResult {
            f(self)
        }
    }
    ```
    
    to:
    
    ``` rust
    // libserialize/json.rs
    impl&lt;'a&gt; Encoder&lt;io::IoError&gt; for Encoder&lt;'a&gt; {
        fn emit_enum&lt;F&gt;(&amp;mut self, _name: &amp;str, f: F) -&gt; EncodeResult where
            F: FnOnce(&amp;mut Encoder&lt;'a&gt;) -&gt; EncodeResult
        {
            f(self)
        }
    }
    ```
    
    [breaking-change]
    
    ---
    
    ### How the `Fn*` bound has been selected
    
    I've chosen the bounds to make the functions/structs as "generic as possible", i.e. to let them allow the maximum amount of input.
    
    - An `F: FnOnce` bound accepts the three kinds of closures: `|:|`, `|&amp;mut:|` and `|&amp;:|`.
    - An `F: FnMut` bound only accepts "non-consuming" closures: `|&amp;mut:|` and `|&amp;:|`.
    - An `F: Fn` bound only accept the "immutable environment" closures: `|&amp;:|`.
    
    This means that whenever possible the `FnOnce` bound has been used, if the `FnOnce` bound couldn't be used, then the `FnMut` was used. The `Fn` bound was never used in the whole repository.
    
    The `FnMut` bound was the most used, because it resembles the semantics of the current boxed closures: the closure can modify its environment, and the closure may be called several times.
    
    The `FnOnce` bound allows new semantics: you can move out the upvars when the closure is called. This can be effectively paired with the `move || {}` syntax to transfer ownership from the environment to the closure caller.
    
    In the case of trait methods, is hard to select the "right" bound since we can't control how the trait may be implemented by downstream users. In these cases, I have selected the bound based on how we use these traits in the repository. For this reason the selected bounds may not be ideal, and may require tweaking before stabilization.
    
    r? @aturon

commit bc486dc233b23f79d5f144cbbbd67cde208c14b6
Merge: daa2bde 20eaf16
Author: bors &lt;bors@rust-lang.org&gt;
Date:   Wed Dec 10 15:22:18 2014 +0000

    auto merge of #19663 : tbu-/rust/pr_fix_vecmap, r=Gankro
    
    - Introduce a named type for the return type of `VecMap::move_iter`
    - Rename all type parameters to `V` for "Value".
    - Remove unnecessary call to an `Option::unwrap`, use pattern matching instead.
    - Remove incorrect `Hash` implementation which took the `VecMap`'s capacity
      into account.
    
    This is a [breaking-change], however whoever used the `Hash` implementation
    relied on an incorrect implementation.

commit 2457375534dc51bff5229a21f9966c60d5800c47
Merge: b4b1bb0 9af324a
Author: Alex Crichton &lt;alex@alexcrichton.com&gt;
Date:   Tue Dec 9 09:25:14 2014 -0800

    rollup merge of #19653: frewsxcv/rm-reexports
    
    Brief note: This does *not* affect anything in the prelude
    
    Part of #19253
    
    All this does is remove the reexporting of Result and Option from their
    respective modules. More core reexports might be removed, but these ones
    are the safest to remove since these enums (and their variants) are included in
    the prelude.
    
    Depends on https://github.com/rust-lang/rust/pull/19407 which is merged, but might need a new snapshot
    
    [breaking-change]

commit d0ad3c7f933d575d3700d8f5124e5474dfcdbd63
Merge: ae60f9c a119ad8
Author: Alex Crichton &lt;alex@alexcrichton.com&gt;
Date:   Tue Dec 9 09:24:50 2014 -0800

    rollup merge of #19594: Arcterus/master
    
    It is useful to have configurable newlines in base64 as the standard
    leaves that for the implementation to decide.  GNU `base64` apparently
    uses LF, which meant in `uutils` we had to manually convert the CRLF to
    LF.  This made the program very slow for large inputs.
    
    [breaking-change]

commit 26c24221e47f76aef8c479ec66c01700df4d6ebb
Merge: 60f97fc e852419
Author: Alex Crichton &lt;alex@alexcrichton.com&gt;
Date:   Tue Dec 9 09:24:44 2014 -0800

    rollup merge of #19587: huonw/closure-feature-gate
    
    detect UFCS drop and allow UFCS methods to have explicit type parameters.
    
    Work towards #18875.
    
    Since code could previously call the methods &amp; implement the traits
    manually, this is a
    
    [breaking-change]
    
    Closes #19586. Closes #19375.

commit 67ae3a49e4864133784cd745a9a8866889f3ae15
Author: Tobias Bucher &lt;tobiasbucher5991@gmail.com&gt;
Date:   Tue Dec 9 18:17:18 2014 +0100

    Clean up `libcollections::VecMap`
    
    - Introduce a named type for the return type of `VecMap::move_iter`
    - Rename all type parameters to `V` for "Value".
    - Remove unnecessary call to an `Option::unwrap`, use pattern matching instead.
    - Remove incorrect `Hash` implementation which took the `VecMap`'s capacity
      into account.
    
    This is a [breaking-change], however whoever used the `Hash` implementation
    relied on an incorrect implementation.

commit 553ab271a31a9573fb6e95d03d8f4d00e17d6511
Author: Arcterus &lt;Arcterus@mail.com&gt;
Date:   Sat Dec 6 02:35:26 2014 -0800

    serialize: base64: allow LF in addition to CRLF and optimize slightly
    
    It is useful to have configurable newlines in base64 as the standard
    leaves that for the implementation to decide.  GNU `base64` apparently
    uses LF, which meant in `uutils` we had to manually convert the CRLF to
    LF.  This made the program very slow for large inputs.
    
    [breaking-change]

commit 9af324a673443367c5b58a182804982c11f73981
Author: Corey Farwell &lt;coreyf@rwell.org&gt;
Date:   Mon Dec 8 12:58:01 2014 -0500

    Remove Result and Option reexports
    
    Brief note: This does *not* affect anything in the prelude
    
    Part of #19253
    
    All this does is remove the reexporting of Result and Option from their
    respective modules. More core reexports might be removed, but these ones
    are the safest to remove since these enums (and their variants) are included in
    the prelude.
    
    [breaking-change]

commit 096a28607fb80c91e6e2ca64d9ef44c4e550e96c
Author: Niko Matsakis &lt;niko@alum.mit.edu&gt;
Date:   Fri Dec 5 17:01:33 2014 -0800

    librustc: Make `Copy` opt-in.
    
    This change makes the compiler no longer infer whether types (structures
    and enumerations) implement the `Copy` trait (and thus are implicitly
    copyable). Rather, you must implement `Copy` yourself via `impl Copy for
    MyType {}`.
    
    A new warning has been added, `missing_copy_implementations`, to warn
    you if a non-generic public type has been added that could have
    implemented `Copy` but didn't.
    
    For convenience, you may *temporarily* opt out of this behavior by using
    `#![feature(opt_out_copy)]`. Note though that this feature gate will never be
    accepted and will be removed by the time that 1.0 is released, so you should
    transition your code away from using it.
    
    This breaks code like:
    
        #[deriving(Show)]
        struct Point2D {
            x: int,
            y: int,
        }
    
        fn main() {
            let mypoint = Point2D {
                x: 1,
                y: 1,
            };
            let otherpoint = mypoint;
            println!("{}{}", mypoint, otherpoint);
        }
    
    Change this code to:
    
        #[deriving(Show)]
        struct Point2D {
            x: int,
            y: int,
        }
    
        impl Copy for Point2D {}
    
        fn main() {
            let mypoint = Point2D {
                x: 1,
                y: 1,
            };
            let otherpoint = mypoint;
            println!("{}{}", mypoint, otherpoint);
        }
    
    This is the backwards-incompatible part of #13231.
    
    Part of RFC #3.
    
    [breaking-change]

commit fec0f16c98ab066ff11be35b5a8bb0d80efa90f1
Author: Barosl Lee &lt;vcs@barosl.com&gt;
Date:   Mon Nov 24 03:14:02 2014 +0900

    libserialize: Always use a decimal point when emitting a float value
    
    JSON doesn't distinguish between integer and float. They are just
    numbers. Also, in the current implementation, a fractional number
    without the fractional part is encoded without a decimal point.
    
    Thereforce, when the value is decoded, it is first rendered as Json,
    either I64 or U64. This reduces type safety, because while the original
    intention was to cast the value to float, it can also be casted to
    integer.
    
    As a workaround of this problem, this commit makes the encoder always
    emit a decimal point even if it is not necessary. If the fractional part
    of a float number is zero, ".0" is padded to the end of the result.
    
    [breaking-change]

commit f102123b659911dbee25bbe518d73d66185bb978
Author: Barosl Lee &lt;vcs@barosl.com&gt;
Date:   Mon Nov 24 03:00:10 2014 +0900

    libserialize: Do not coerce to integer when decoding a float value
    
    When an integral value is expected by the user but a fractional value is
    found, the current implementation uses std::num::cast() to coerce to an
    integer type, losing the fractional part. This behavior is not desirable
    because the number loses precision without notice.
    
    This commit makes it raise ExpectedError when such a situation arises.
    
    [breaking-change]

commit ca4f53655e82a0a0e1d613b16108720bb7a50fde
Author: Barosl Lee &lt;vcs@barosl.com&gt;
Date:   Mon Nov 24 02:22:30 2014 +0900

    libserialize: Remove float preprocessing in serialize::json::Encoder
    
    serialize::json::Encoder currently uses f64 to emit any integral type.
    This is possibly due to the behavior of JavaScript, which uses f64 to
    represent any numeric value.
    
    This leads to a problem that only the integers in the range of [-2^53+1,
    2^53-1] can be encoded. Therefore, i64 and u64 cannot be used reliably
    in the current implementation.
    
    RFC 7159 suggests that good interoperability can be achieved if the
    range is respected by implementations. However, it also says that
    implementations are allowed to set the range of number accepted. And it
    seems that the JSON encoders outside of the JavaScript world usually
    make use of i64 values.
    
    This commit removes the float preprocessing done in the emit_* methods.
    It also increases performance, because transforming f64 into String
    costs more than that of an integral type.
    
    Fixes #18319
    
    [breaking-change]

commit 558f8d8e3ea6b7da3d6d338740637149a7e45840
Merge: a243e88 6e18b5a
Author: bors &lt;bors@rust-lang.org&gt;
Date:   Sun Dec 7 16:12:22 2014 +0000

    auto merge of #19539 : cmr/rust/18959, r=nikomatsakis
    
    Closes #18959
    
    Technically, this causes code that once compiled to no longer compile, but
    that code probably never ran.
    
    [breaking-change]
    
    ------------
    
    Not quite sure the error message is good enough, I feel like it ought to tell you "because it inherits from non-object-safe trait Foo", so I've opened up a follow-up issue #19538

commit 6e18b5af9336947ec5d41e66d216c52c12bf74a3
Author: Corey Richardson &lt;corey@octayn.net&gt;
Date:   Thu Nov 27 11:28:51 2014 -0500

    rustc: check supertraits for object safety
    
    Closes #18959
    
    Technically, this causes code that once compiled to no longer compile, but
    that code probably never ran.
    
    [breaking-change]

commit e8524198e3931373f5e097dece21e36d21c4a537
Author: Huon Wilson &lt;dbau.pp+github@gmail.com&gt;
Date:   Fri Dec 5 15:53:30 2014 -0800

    Feature-gate explicit unboxed closure method calls &amp; manual impls,
    detect UFCS drop and allow UFCS methods to have explicit type parameters.
    
    Work towards #18875.
    
    Since code could previously call the methods &amp; implement the traits
    manually, this is a
    
    [breaking-change]
    
    Closes #19586. Closes #19375.

commit a6ce402401f0da3a48a5a183ae109a00024ba666
Merge: 26f2867 e7c1f57
Author: Corey Richardson &lt;corey@octayn.net&gt;
Date:   Fri Dec 5 10:06:52 2014 -0800

    rollup merge of #19416: sfackler/global-stdin
    
    io::stdin returns a new `BufferedReader` each time it's called, which
    results in some very confusing behavior with disappearing output. It now
    returns a `StdinReader`, which wraps a global singleton
    `Arc&lt;Mutex&lt;BufferedReader&lt;StdReader&gt;&gt;`. `Reader` is implemented directly
    on `StdinReader`. However, `Buffer` is not, as the `fill_buf` method is
    fundamentaly un-thread safe. A `lock` method is defined on `StdinReader`
    which returns a smart pointer wrapping the underlying `BufferedReader`
    while guaranteeing mutual exclusion.
    
    Code that treats the return value of io::stdin as implementing `Buffer`
    will break. Add a call to `lock`:
    
    ```rust
    io::stdin().read_line();
    // =&gt;
    io::stdin().lock().read_line();
    ```
    
    Closes #14434
    
    [breaking-change]

commit 08ce178866e4533d8815fe5868a520e0fc55b21c
Merge: 4573da6 c3adbd3
Author: Corey Richardson &lt;corey@octayn.net&gt;
Date:   Fri Dec 5 10:06:39 2014 -0800

    rollup merge of #19274: alexcrichton/rewrite-sync
    
    This commit is a reimplementation of `std::sync` to be based on the
    system-provided primitives wherever possible. The previous implementation was
    fundamentally built on top of channels, and as part of the runtime reform it has
    become clear that this is not the level of abstraction that the standard level
    should be providing. This rewrite aims to provide as thin of a shim as possible
    on top of the system primitives in order to make them safe.
    
    The overall interface of the `std::sync` module has in general not changed, but
    there are a few important distinctions, highlighted below:
    
    * The condition variable type, `Condvar`, has been separated out of a `Mutex`.
      A condition variable is now an entirely separate type. This separation
      benefits users who only use one mutex, and provides a clearer distinction of
      who's responsible for managing condition variables (the application).
    
    * All of `Condvar`, `Mutex`, and `RWLock` are now directly built on top of
      system primitives rather than using a custom implementation. The `Once`,
      `Barrier`, and `Semaphore` types are still built upon these abstractions of
      the system primitives.
    
    * The `Condvar`, `Mutex`, and `RWLock` types all have a new static type and
      constant initializer corresponding to them. These are provided primarily for C
      FFI interoperation, but are often useful to otherwise simply have a global
      lock. The types, however, will leak memory unless `destroy()` is called on
      them, which is clearly documented.
    
    * The fundamental architecture of this design is to provide two separate layers.
      The first layer is that exposed by `sys_common` which is a cross-platform
      bare-metal abstraction of the system synchronization primitives. No attempt is
      made at making this layer safe, and it is quite unsafe to use! It is currently
      not exported as part of the API of the standard library, but the stabilization
      of the `sys` module will ensure that these will be exposed in time. The
      purpose of this layer is to provide the core cross-platform abstractions if
      necessary to implementors.
    
      The second layer is the layer provided by `std::sync` which is intended to be
      the thinnest possible layer on top of `sys_common` which is entirely safe to
      use. There are a few concerns which need to be addressed when making these
      system primitives safe:
    
        * Once used, the OS primitives can never be **moved**. This means that they
          essentially need to have a stable address. The static primitives use
          `&amp;'static self` to enforce this, and the non-static primitives all use a
          `Box` to provide this guarantee.
    
        * Poisoning is leveraged to ensure that invalid data is not accessible from
          other tasks after one has panicked.
    
      In addition to these overall blanket safety limitations, each primitive has a
      few restrictions of its own:
    
        * Mutexes and rwlocks can only be unlocked from the same thread that they
          were locked by. This is achieved through RAII lock guards which cannot be
          sent across threads.
    
        * Mutexes and rwlocks can only be unlocked if they were previously locked.
          This is achieved by not exposing an unlocking method.
    
        * A condition variable can only be waited on with a locked mutex. This is
          achieved by requiring a `MutexGuard` in the `wait()` method.
    
        * A condition variable cannot be used concurrently with more than one mutex.
          This is guaranteed by dynamically binding a condition variable to
          precisely one mutex for its entire lifecycle. This restriction may be able
          to be relaxed in the future (a mutex is unbound when no threads are
          waiting on the condvar), but for now it is sufficient to guarantee safety.
    
    * Condvars support timeouts for their blocking operations. The
      implementation for these operations is provided by the system.
    
    Due to the modification of the `Condvar` API, removal of the `std::sync::mutex`
    API, and reimplementation, this is a breaking change. Most code should be fairly
    easy to port using the examples in the documentation of these primitives.
    
    [breaking-change]
    
    Closes #17094
    Closes #18003

commit d91331074862f13d87f67b85eeba2a1192c3a12d
Author: Erick Tryzelaar &lt;erick.tryzelaar@gmail.com&gt;
Date:   Fri Dec 5 09:04:55 2014 -0800

    test: expose boxplot and the extra stats test keeps track of
    
    [breaking-change]

commit 71d4e77db8ad4b6d821da7e5d5300134ac95974e
Author: Alex Crichton &lt;alex@alexcrichton.com&gt;
Date:   Mon Nov 24 11:16:40 2014 -0800

    std: Rewrite the `sync` module
    
    This commit is a reimplementation of `std::sync` to be based on the
    system-provided primitives wherever possible. The previous implementation was
    fundamentally built on top of channels, and as part of the runtime reform it has
    become clear that this is not the level of abstraction that the standard level
    should be providing. This rewrite aims to provide as thin of a shim as possible
    on top of the system primitives in order to make them safe.
    
    The overall interface of the `std::sync` module has in general not changed, but
    there are a few important distinctions, highlighted below:
    
    * The condition variable type, `Condvar`, has been separated out of a `Mutex`.
      A condition variable is now an entirely separate type. This separation
      benefits users who only use one mutex, and provides a clearer distinction of
      who's responsible for managing condition variables (the application).
    
    * All of `Condvar`, `Mutex`, and `RWLock` are now directly built on top of
      system primitives rather than using a custom implementation. The `Once`,
      `Barrier`, and `Semaphore` types are still built upon these abstractions of
      the system primitives.
    
    * The `Condvar`, `Mutex`, and `RWLock` types all have a new static type and
      constant initializer corresponding to them. These are provided primarily for C
      FFI interoperation, but are often useful to otherwise simply have a global
      lock. The types, however, will leak memory unless `destroy()` is called on
      them, which is clearly documented.
    
    * The `Condvar` implementation for an `RWLock` write lock has been removed. This
      may be added back in the future with a userspace implementation, but this
      commit is focused on exposing the system primitives first.
    
    * The fundamental architecture of this design is to provide two separate layers.
      The first layer is that exposed by `sys_common` which is a cross-platform
      bare-metal abstraction of the system synchronization primitives. No attempt is
      made at making this layer safe, and it is quite unsafe to use! It is currently
      not exported as part of the API of the standard library, but the stabilization
      of the `sys` module will ensure that these will be exposed in time. The
      purpose of this layer is to provide the core cross-platform abstractions if
      necessary to implementors.
    
      The second layer is the layer provided by `std::sync` which is intended to be
      the thinnest possible layer on top of `sys_common` which is entirely safe to
      use. There are a few concerns which need to be addressed when making these
      system primitives safe:
    
        * Once used, the OS primitives can never be **moved**. This means that they
          essentially need to have a stable address. The static primitives use
          `&amp;'static self` to enforce this, and the non-static primitives all use a
          `Box` to provide this guarantee.
    
        * Poisoning is leveraged to ensure that invalid data is not accessible from
          other tasks after one has panicked.
    
      In addition to these overall blanket safety limitations, each primitive has a
      few restrictions of its own:
    
        * Mutexes and rwlocks can only be unlocked from the same thread that they
          were locked by. This is achieved through RAII lock guards which cannot be
          sent across threads.
    
        * Mutexes and rwlocks can only be unlocked if they were previously locked.
          This is achieved by not exposing an unlocking method.
    
        * A condition variable can only be waited on with a locked mutex. This is
          achieved by requiring a `MutexGuard` in the `wait()` method.
    
        * A condition variable cannot be used concurrently with more than one mutex.
          This is guaranteed by dynamically binding a condition variable to
          precisely one mutex for its entire lifecycle. This restriction may be able
          to be relaxed in the future (a mutex is unbound when no threads are
          waiting on the condvar), but for now it is sufficient to guarantee safety.
    
    * Condvars now support timeouts for their blocking operations. The
      implementation for these operations is provided by the system.
    
    Due to the modification of the `Condvar` API, removal of the `std::sync::mutex`
    API, and reimplementation, this is a breaking change. Most code should be fairly
    easy to port using the examples in the documentation of these primitives.
    
    [breaking-change]
    
    Closes #17094
    Closes #18003

commit 6d965cc2c99787a949d38abf225412fe502d3ed8
Merge: 53e8bd6 5cfac94
Author: bors &lt;bors@rust-lang.org&gt;
Date:   Thu Dec 4 12:02:56 2014 +0000

    auto merge of #19167 : japaric/rust/rhs-cmp, r=aturon
    
    Comparison traits have gained an `Rhs` input parameter that defaults to `Self`. And now the comparison operators can be overloaded to work between different types. In particular, this PR allows the following operations (and their commutative versions):
    
    - `&amp;str` == `String` == `CowString`
    - `&amp;[A]` == `&amp;mut [B]` == `Vec&lt;C&gt;` == `CowVec&lt;D&gt;` == `[E, ..N]` (for `N` up to 32)
    - `&amp;mut A` == `&amp;B` (for `Sized` `A` and `B`)
    
    Where `A`, `B`, `C`, `D`, `E` may be different types that implement `PartialEq`. For example, these comparisons are now valid: `string == "foo"`, and `vec_of_strings == ["Hello", "world"]`.
    
    [breaking-change]s
    
    Since the `==` may now work on different types, operations that relied on the old "same type restriction" to drive type inference, will need to be type annotated. These are the most common fallout cases:
    
    - `some_vec == some_iter.collect()`: `collect` needs to be type annotated: `collect::&lt;Vec&lt;_&gt;&gt;()`
    - `slice == &amp;[a, b, c]`: RHS doesn't get coerced to an slice, use an array instead `[a, b, c]`
    - `lhs == []`: Change expression to `lhs.is_empty()`
    - `lhs == some_generic_function()`: Type annotate the RHS as necessary
    
    cc #19148
    
    r? @aturon

commit e7c1f57d6c8781cfb3e746eac5f13f760fcde2b4
Author: Steven Fackler &lt;sfackler@gmail.com&gt;
Date:   Sat Nov 29 23:07:43 2014 -0800

    Back io::stdin with a global singleton BufferedReader
    
    io::stdin returns a new `BufferedReader` each time it's called, which
    results in some very confusing behavior with disappearing output. It now
    returns a `StdinReader`, which wraps a global singleton
    `Arc&lt;Mutex&lt;BufferedReader&lt;StdReader&gt;&gt;`. `Reader` is implemented directly
    on `StdinReader`. However, `Buffer` is not, as the `fill_buf` method is
    fundamentaly un-thread safe. A `lock` method is defined on `StdinReader`
    which returns a smart pointer wrapping the underlying `BufferedReader`
    while guaranteeing mutual exclusion.
    
    Code that treats the return value of io::stdin as implementing `Buffer`
    will break. Add a call to `lock`:
    
    ```rust
    io::stdin().lines()
    // =&gt;
    io::stdin().lock().lines()
    ```
    
    Closes #14434
    
    [breaking-change]

commit b82624bf205e83555d7764d9f849fbfd30df0083
Author: Piotr Czarnecki &lt;pioczarn@gmail.com&gt;
Date:   Sat Nov 8 17:26:52 2014 +0100

    std: Change the behavior of `reserve` for HashMap.
    
    HashMap's `reserve` method now takes as an argument the *extra* space
    to reserve.
    
    [breaking-change]

commit 63553a10adc8b507edee1fce43f868d93628ce34
Author: P1start &lt;rewi-github@whanau.org&gt;
Date:   Sun Nov 30 21:33:04 2014 +1300

    Fix the ordering of `unsafe` and `extern` in methods
    
    This breaks code that looks like this:
    
        trait Foo {
            extern "C" unsafe fn foo();
        }
    
        impl Foo for Bar {
            extern "C" unsafe fn foo() { ... }
        }
    
    Change such code to look like this:
    
        trait Foo {
            unsafe extern "C" fn foo();
        }
    
        impl Foo for Bar {
            unsafe extern "C" fn foo() { ... }
        }
    
    Fixes #19398.
    
    [breaking-change]

commit dfaad04b7a14012ac282269eacfb51b4e97673c1
Merge: 8d8f41b 1919b12
Author: bors &lt;bors@rust-lang.org&gt;
Date:   Sun Nov 30 06:56:41 2014 +0000

    auto merge of #19365 : frewsxcv/rust/getopts-cleanup, r=alexcrichton
    
    * Remove public reexports, as a part of #19253
    * Rename getopts::Fail_ to getopts::Fail
     * Didn't see a reason for the suffixed '_'
    * Removed getopts::FailType
     * Looked like it was only beings used for tests; refactored the tests
       to stop requiring it
    * A few other non-breaking trivial refactoring changes
    
    [breaking-change]

commit 1919b12775ca45e8f5bb4b7540ebfa3d100f5bf6
Author: Corey Farwell &lt;coreyf@rwell.org&gt;
Date:   Thu Nov 27 14:39:50 2014 -0500

    getopts: cleanup, renames, remove reexports
    
    * Remove public reexports, as a part of #19253
    * Rename getopts::Fail_ to getopts::Fail
     * Didn't see a reason for the suffixed '_'
    * Removed getopts::FailType
     * Looked like it was only beings used for tests; refactored the tests
       to stop requiring it
    * A few other non-breaking trivial refactoring changes
    
    [breaking-change]

commit f4a775639ca846f29abeed16a7b4e8e1c8819626
Merge: 702127f 21d5d13
Author: Alex Crichton &lt;alex@alexcrichton.com&gt;
Date:   Wed Nov 26 09:44:43 2014 -0800

    rollup merge of #19298: nikomatsakis/unboxed-closure-parse-the-plus
    
    Implements RFC 438.
    
    Fixes #19092.
    
    This is a [breaking-change]: change types like `&amp;Foo+Send` or `&amp;'a mut Foo+'a` to `&amp;(Foo+Send)` and `&amp;'a mut (Foo+'a)`, respectively.
    
    r? @brson

commit 34b98b306ad23ab895f701de1d009ff026a1d2b1
Merge: 60299d7 36372b9
Author: Alex Crichton &lt;alex@alexcrichton.com&gt;
Date:   Wed Nov 26 09:44:30 2014 -0800

    rollup merge of #19287: alexcrichton/issue-19272
    
    At the same time remove the `pub use` of the variants in favor of accessing
    through the enum type itself. This is a breaking change as the `Found` and
    `NotFound` variants must now be imported through `BinarySearchResult` instead of
    just `std::slice`.
    
    [breaking-change]
    Closes #19271

commit 1a44875af985de43d514192d43ef260a24e83d26
Merge: 930f877 b299c2b
Author: bors &lt;bors@rust-lang.org&gt;
Date:   Wed Nov 26 17:42:07 2014 +0000

    auto merge of #19176 : aturon/rust/stab-iter, r=alexcrichton
    
    This is an initial pass at stabilizing the `iter` module. The module is
    fairly large, but is also pretty polished, so most of the stabilization
    leaves things as they are.
    
    Some changes:
    
    * Due to the new object safety rules, various traits needs to be split
      into object-safe traits and extension traits. This includes `Iterator`
      itself. While splitting up the traits adds some complexity, it will
      also increase flexbility: once we have automatic impls of `Trait` for
      trait objects over `Trait`, then things like the iterator adapters
      will all work with trait objects.
    
    * Iterator adapters that use up the entire iterator now take it by
      value, which makes the semantics more clear and helps catch bugs. Due
      to the splitting of Iterator, this does not affect trait objects. If
      the underlying iterator is still desired for some reason, `by_ref` can
      be used. (Note: this change had no fallout in the Rust distro except
      for the useless mut lint.)
    
    * In general, extension traits new and old are following an [in-progress
      convention](rust-lang/rfcs#445). As such, they
      are marked `unstable`.
    
    * As usual, anything involving closures is `unstable` pending unboxed
      closures.
    
    * A few of the more esoteric/underdeveloped iterator forms (like
      `RandomAccessIterator` and `MutableDoubleEndedIterator`, along with
      various unfolds) are left experimental for now.
    
    * The `order` submodule is left `experimental` because it will hopefully
      be replaced by generalized comparison traits.
    
    * "Leaf" iterators (like `Repeat` and `Counter`) are uniformly
      constructed by free fns at the module level. That's because the types
      are not otherwise of any significance (if we had `impl Trait`, you
      wouldn't want to define a type at all).
    
    Closes #17701
    
    Due to renamings and splitting of traits, this is a:
    
    [breaking-change]

commit ce238d752b1e04d4aea21c0fadf420a270ed6ff9
Author: Corey Farwell &lt;coreyf@rwell.org&gt;
Date:   Sat Nov 22 13:48:01 2014 -0500

    Unpublicize reexports, unprefix JSON type aliases
    
    The type aliases json::JsonString and json::JsonObject were originally
    prefixed with 'json' to prevent collisions with (at the time) the enums
    json::String and json::Object respectively. Now that enum namespacing
    has landed, this 'json' prefix is redundant and can be removed:
    
    json::JsonArray -&gt; json::Array
    json::JsonObject -&gt; json::Object
    
    In addition, this commit also unpublicizes all of the re-exports in this
    JSON module, as a part of #19253
    
    [breaking-change]

commit 8fb027e398ef756b7b02a270ef0304be92e70f4d
Merge: 61af402 3293ab1
Author: bors &lt;bors@rust-lang.org&gt;
Date:   Wed Nov 26 12:02:16 2014 +0000

    auto merge of #19252 : japaric/rust/cow, r=aturon
    
    - Add `IntoCow` trait, and put it in the prelude
    - Add `is_owned`/`is_borrowed` methods to `Cow`
    - Add `CowString`/`CowVec` type aliases (to `Cow&lt;'_, String, str&gt;`/`Cow&lt;'_, Vec, [T]&gt;` respectively)
    - `Cow` implements: `Show`, `Hash`, `[Partial]{Eq,Ord}`
    - `impl BorrowFrom&lt;Cow&lt;'a, T, B&gt;&gt; for B`
    
    [breaking-change]s:
    
    - `IntoMaybeOwned` has been removed from the prelude
    - libcollections: `SendStr` is now an alias to `CowString&lt;'static&gt;` (it was aliased to `MaybeOwned&lt;'static&gt;`)
    - libgraphviz:
      - `LabelText` variants now wrap `CowString` instead of `MaybeOwned`
      - `Nodes` and `Edges` are now type aliases to `CowVec` (they were aliased to `MaybeOwnedVec`)
    - libstd/path: `Display::as_maybe_owned` has been renamed to `Display::as_cow` and now returns a `CowString`
    - These functions now accept/return `Cow` instead of `MaybeOwned[Vector]`:
      - libregex: `Replacer::reg_replace`
      - libcollections: `str::from_utf8_lossy`
      - libgraphviz: `Id::new`, `Id::name`, `LabelText::pre_escaped_content`
      - libstd: `TaskBuilder::named`
    
    r? @aturon

commit a86f72d9a2adc6d65f2ba0990caca35c1a3f622d
Author: Aaron Turon &lt;aturon@mozilla.com&gt;
Date:   Thu Nov 6 09:32:32 2014 -0800

    libs: stabilize iter module
    
    This is an initial pass at stabilizing the `iter` module. The module is
    fairly large, but is also pretty polished, so most of the stabilization
    leaves things as they are.
    
    Some changes:
    
    * Due to the new object safety rules, various traits needs to be split
      into object-safe traits and extension traits. This includes `Iterator`
      itself. While splitting up the traits adds some complexity, it will
      also increase flexbility: once we have automatic impls of `Trait` for
      trait objects over `Trait`, then things like the iterator adapters
      will all work with trait objects.
    
    * Iterator adapters that use up the entire iterator now take it by
      value, which makes the semantics more clear and helps catch bugs. Due
      to the splitting of Iterator, this does not affect trait objects. If
      the underlying iterator is still desired for some reason, `by_ref` can
      be used. (Note: this change had no fallout in the Rust distro except
      for the useless mut lint.)
    
    * In general, extension traits new and old are following an [in-progress
      convention](https://github.com/rust-lang/rfcs/pull/445). As such, they
      are marked `unstable`.
    
    * As usual, anything involving closures is `unstable` pending unboxed
      closures.
    
    * A few of the more esoteric/underdeveloped iterator forms (like
      `RandomAccessIterator` and `MutableDoubleEndedIterator`, along with
      various unfolds) are left experimental for now.
    
    * The `order` submodule is left `experimental` because it will hopefully
      be replaced by generalized comparison traits.
    
    * "Leaf" iterators (like `Repeat` and `Counter`) are uniformly
      constructed by free fns at the module level. That's because the types
      are not otherwise of any significance (if we had `impl Trait`, you
      wouldn't want to define a type at all).
    
    Closes #17701
    
    Due to renamings and splitting of traits, this is a:
    
    [breaking-change]

commit 689ef2dabfa3b2b379c953e5fb68ce2c805c2231
Merge: 0e06f71 985acfd
Author: bors &lt;bors@rust-lang.org&gt;
Date:   Tue Nov 25 20:32:20 2014 +0000

    auto merge of #19255 : aturon/rust/merge-sync, r=alexcrichton,alexcrichton
    
    This patch merges the `libsync` crate into `libstd`, undoing part of the
    facade. This is in preparation for ultimately merging `librustrt`, as
    well as the upcoming rewrite of `sync`.
    
    Because this removes the `libsync` crate, it is a:
    
    [breaking-change]
    
    However, all uses of `libsync` should be able to reroute through
    `std::sync` and `std::comm` instead.
    
    r? @alexcrichton

commit f6cb58caeedf509cc80dd376bbb2541a0446046b
Merge: 0c1d853 f1f6c12
Author: bors &lt;bors@rust-lang.org&gt;
Date:   Tue Nov 25 09:21:45 2014 +0000

    auto merge of #19149 : alexcrichton/rust/issue-19091, r=aturon
    
    This change applies the conventions to unwrap listed in [RFC 430][rfc] to rename
    non-failing `unwrap` methods to `into_inner`. This is a breaking change, but all
    `unwrap` methods are retained as `#[deprecated]` for the near future. To update
    code rename `unwrap` method calls to `into_inner`.
    
    [rfc]: https://github.com/rust-lang/rfcs/pull/430
    [breaking-change]
    
    cc #19091

commit 36372b929e9d44c7421827b160505854ceeb9a83
Author: Alex Crichton &lt;alex@alexcrichton.com&gt;
Date:   Mon Nov 24 15:54:14 2014 -0800

    std: Export BinarySearchResult
    
    At the same time remove the `pub use` of the variants in favor of accessing
    through the enum type itself. This is a breaking change as the `Found` and
    `NotFound` variants must now be imported through `BinarySearchResult` instead of
    just `std::slice`.
    
    [breaking-change]
    Closes #19272

commit 3b9dfd6af04ca008a4c2ef13b7fd2e8433dc473f
Author: Ben S &lt;ogham@bsago.me&gt;
Date:   Mon Nov 24 19:04:54 2014 +0000

    Clean up FileType enum following enum namespacing
    
    All of the enum components had a redundant 'Type' specifier: TypeSymlink, TypeDirectory, TypeFile. This change removes them, replacing them with a namespace: FileType::Symlink, FileType::Directory, and FileType::RegularFile.
    
    RegularFile is used instead of just File, as File by itself could be mistakenly thought of as referring to the struct.
    
    [breaking-change]

commit 985acfdb67d550d0259fcdcfbeed0a86ec3da9d0
Author: Aaron Turon &lt;aturon@mozilla.com&gt;
Date:   Sun Nov 23 12:52:37 2014 -0800

    Merge libsync into libstd
    
    This patch merges the `libsync` crate into `libstd`, undoing part of the
    facade. This is in preparation for ultimately merging `librustrt`, as
    well as the upcoming rewrite of `sync`.
    
    Because this removes the `libsync` crate, it is a:
    
    [breaking-change]
    
    However, all uses of `libsync` should be able to reroute through
    `std::sync` and `std::comm` instead.

commit bad1062caaaefe0963d7b8513786c8283e74f1e7
Merge: f5b92b4 a9c1152
Author: bors &lt;bors@rust-lang.org&gt;
Date:   Mon Nov 24 09:56:34 2014 +0000

    auto merge of #19094 : alexcrichton/rust/rm-std-local-data, r=aturon
    
    This commit removes the `std::local_data` module in favor of a new `std::thread_local`
    module providing thread local storage. The module provides two variants of TLS:
    one which owns its contents and one which is based on scoped references. Each
    implementation has pros and cons listed in the documentation.
    
    Both flavors have accessors through a function called `with` which yield a
    reference to a closure provided. Both flavors also panic if a reference cannot
    be yielded and provide a function to test whether an access would panic or not.
    This is an implementation of [RFC 461][rfc] and full details can be found in
    that RFC.
    
    This is a breaking change due to the removal of the `std::local_data` module.
    All users can migrate to the new tls system like so:
    
        thread_local!(static FOO: Rc&lt;RefCell&lt;Option&lt;T&gt;&gt;&gt; = Rc::new(RefCell::new(None)))
    
    The old `local_data` module inherently contained the `Rc&lt;RefCell&lt;Option&lt;T&gt;&gt;&gt;` as
    an implementation detail which must now be explicitly stated by users.
    
    [rfc]: https://github.com/rust-lang/rfcs/pull/461
    [breaking-change]

commit a9c1152c4bf72132806cb76045b3464d59db07da
Author: Alex Crichton &lt;alex@alexcrichton.com&gt;
Date:   Fri Nov 14 14:20:57 2014 -0800

    std: Add a new top-level thread_local module
    
    This commit removes the `std::local_data` module in favor of a new
    `std::thread_local` module providing thread local storage. The module provides
    two variants of TLS: one which owns its contents and one which is based on
    scoped references. Each implementation has pros and cons listed in the
    documentation.
    
    Both flavors have accessors through a function called `with` which yield a
    reference to a closure provided. Both flavors also panic if a reference cannot
    be yielded and provide a function to test whether an access would panic or not.
    This is an implementation of [RFC 461][rfc] and full details can be found in
    that RFC.
    
    This is a breaking change due to the removal of the `std::local_data` module.
    All users can migrate to the new thread local system like so:
    
        thread_local!(static FOO: Rc&lt;RefCell&lt;Option&lt;T&gt;&gt;&gt; = Rc::new(RefCell::new(None)))
    
    The old `local_data` module inherently contained the `Rc&lt;RefCell&lt;Option&lt;T&gt;&gt;&gt;` as
    an implementation detail which must now be explicitly stated by users.
    
    [rfc]: https://github.com/rust-lang/rfcs/pull/461
    [breaking-change]

commit f1f6c1286f24f6f762a9b195ac678b55d20c9a9b
Author: Alex Crichton &lt;alex@alexcrichton.com&gt;
Date:   Thu Nov 20 09:23:43 2014 -0800

    Rename unwrap functions to into_inner
    
    This change applies the conventions to unwrap listed in [RFC 430][rfc] to rename
    non-failing `unwrap` methods to `into_inner`. This is a breaking change, but all
    `unwrap` methods are retained as `#[deprecated]` for the near future. To update
    code rename `unwrap` method calls to `into_inner`.
    
    [rfc]: https://github.com/rust-lang/rfcs/pull/430
    [breaking-change]
    
    Closes #13159
    cc #19091

commit 3594c588bb735117621f6a168116d9e1d086654a
Merge: 5ad1512 40e1f8f
Author: Jakub Bukaj &lt;jakub@jakub.cc&gt;
Date:   Sun Nov 23 14:11:56 2014 -0500

    rollup merge of #19211: aochagavia/tuple-index
    
    This breaks code like
    
    ```
    let t = (42i, 42i);
    ... t.0::&lt;int&gt; ...;
    ```
    
    Change this code to not contain an unused type parameter. For example:
    
    ```
    let t = (42i, 42i);
    ... t.0 ...;
    ```
    
    Closes https://github.com/rust-lang/rust/issues/19096
    
    [breaking-change]
    
    r? @aturon

commit b21b48062f114317025c986fe35af21b15c675d9
Merge: 77d1f0b 6733d8b
Author: Jakub Bukaj &lt;jakub@jakub.cc&gt;
Date:   Sun Nov 23 14:11:51 2014 -0500

    rollup merge of #19194: aturon/stab-ascii
    
    This is an initial API stabilization pass for `std::ascii`. Aside from
    some renaming to match conversion conventions, and deprecations in favor
    of using iterators directly, almost nothing is changed here. However,
    the static case conversion tables that were previously public are now private.
    
    The stabilization of the (rather large!) set of extension traits is left
    to a follow-up pass, because we hope to land some more general machinery
    that will provide the same functionality without custom traits.
    
    [breaking-change]

commit 9a857b4472142b6d0bf65e9185c4c2619e722fb0
Author: Adolfo Ochagava &lt;aochagavia92@gmail.com&gt;
Date:   Sat Nov 22 16:02:49 2014 +0100

    libsyntax: Forbid type parameters in tuple indices
    
    This breaks code like
    
    ```
    let t = (42i, 42i);
    ... t.0::&lt;int&gt; ...;
    ```
    
    Change this code to not contain an unused type parameter. For example:
    
    ```
    let t = (42i, 42i);
    ... t.0 ...;
    ```
    
    Closes https://github.com/rust-lang/rust/issues/19096
    
    [breaking-change]

commit 641e2a110de4bb1b2c2b596ef1168ae7865aa529
Merge: 529f8bc 8ca27a6
Author: bors &lt;bors@rust-lang.org&gt;
Date:   Sun Nov 23 05:46:52 2014 +0000

    auto merge of #19152 : alexcrichton/rust/issue-17863, r=aturon
    
    This commit is an implementation of [RFC 240][rfc] when applied to the standard
    library. It primarily deprecates the entirety of `string::raw`, `vec::raw`,
    `slice::raw`, and `str::raw` in favor of associated functions, methods, and
    other free functions. The detailed renaming is:
    
    * slice::raw::buf_as_slice =&gt; slice::from_raw_buf
    * slice::raw::mut_buf_as_slice =&gt; slice::from_raw_mut_buf
    * slice::shift_ptr =&gt; deprecated with no replacement
    * slice::pop_ptr =&gt; deprecated with no replacement
    * str::raw::from_utf8 =&gt; str::from_utf8_unchecked
    * str::raw::c_str_to_static_slice =&gt; str::from_c_str
    * str::raw::slice_bytes =&gt; deprecated for slice_unchecked (slight semantic diff)
    * str::raw::slice_unchecked =&gt; str.slice_unchecked
    * string::raw::from_parts =&gt; String::from_raw_parts
    * string::raw::from_buf_len =&gt; String::from_raw_buf_len
    * string::raw::from_buf =&gt; String::from_raw_buf
    * string::raw::from_utf8 =&gt; String::from_utf8_unchecked
    * vec::raw::from_buf =&gt; Vec::from_raw_buf
    
    All previous functions exist in their `#[deprecated]` form, and the deprecation
    messages indicate how to migrate to the newer variants.
    
    [rfc]: https://github.com/rust-lang/rfcs/blob/master/text/0240-unsafe-api-location.md
    [breaking-change]
    
    Closes #17863

commit 8ca27a633ed393438a12bbf074b4f2e6063baa6f
Author: Alex Crichton &lt;alex@alexcrichton.com&gt;
Date:   Thu Nov 20 10:11:15 2014 -0800

    std: Align `raw` modules with unsafe conventions
    
    This commit is an implementation of [RFC 240][rfc] when applied to the standard
    library. It primarily deprecates the entirety of `string::raw`, `vec::raw`,
    `slice::raw`, and `str::raw` in favor of associated functions, methods, and
    other free functions. The detailed renaming is:
    
    * slice::raw::buf_as_slice =&gt; slice::with_raw_buf
    * slice::raw::mut_buf_as_slice =&gt; slice::with_raw_mut_buf
    * slice::shift_ptr =&gt; deprecated with no replacement
    * slice::pop_ptr =&gt; deprecated with no replacement
    * str::raw::from_utf8 =&gt; str::from_utf8_unchecked
    * str::raw::c_str_to_static_slice =&gt; str::from_c_str
    * str::raw::slice_bytes =&gt; deprecated for slice_unchecked (slight semantic diff)
    * str::raw::slice_unchecked =&gt; str.slice_unchecked
    * string::raw::from_parts =&gt; String::from_raw_parts
    * string::raw::from_buf_len =&gt; String::from_raw_buf_len
    * string::raw::from_buf =&gt; String::from_raw_buf
    * string::raw::from_utf8 =&gt; String::from_utf8_unchecked
    * vec::raw::from_buf =&gt; Vec::from_raw_buf
    
    All previous functions exist in their `#[deprecated]` form, and the deprecation
    messages indicate how to migrate to the newer variants.
    
    [rfc]: https://github.com/rust-lang/rfcs/blob/master/text/0240-unsafe-api-location.md
    [breaking-change]
    
    Closes #17863

commit 7ce2d9c3fa3d36ae79b9790e3646e5e746e64cf4
Author: Aaron Turon &lt;aturon@mozilla.com&gt;
Date:   Fri Nov 21 12:00:05 2014 -0800

    libs: stabilize ascii module
    
    This is an initial API stabilization pass for `std::ascii`. Aside from
    some renaming to match conversion conventions, and deprecations in favor
    of using iterators directly, almost nothing is changed here. However,
    the static case conversion tables that were previously public are now private.
    
    The stabilization of the (rather large!) set of extension traits is left
    to a follow-up pass, because we hope to land some more general machinery
    that will provide the same functionality without custom traits.
    
    [breaking-change]

commit d6ee804b632ee03679d6de682841fc7785ef4fbb
Author: Brian Anderson &lt;banderson@mozilla.com&gt;
Date:   Mon Nov 3 10:26:22 2014 -0800

    unicode: Convert UnicodeChar methods to by-value
    
    Extension traits for primitive types should be by-value.
    
    [breaking-change]

commit aad246160451aacc2f7a707c028bdf44e77ad38d
Author: Brian Anderson &lt;banderson@mozilla.com&gt;
Date:   Fri Oct 31 16:20:41 2014 -0700

    core: Convert Char::escape_default, escape_unicode to iterators
    
    [breaking-change]

commit ca1820b1fce5aa803ccc757e79dd659f599d1516
Author: Brian Anderson &lt;banderson@mozilla.com&gt;
Date:   Tue Oct 14 13:08:54 2014 -0700

    core: Convert Char methods to by-val self
    
    Methods on primitmive Copy types generally should take `self`.
    
    [breaking-change]

commit c2aff692fa88235d356725f98184a5ea5b52eb88
Author: Brian Anderson &lt;banderson@mozilla.com&gt;
Date:   Wed Oct 8 17:15:27 2014 -0700

    unicode: Rename UnicodeChar::is_digit to is_numeric
    
    'Numeric' is the proper name of the unicode character class,
    and this frees up the word 'digit' for ascii use in libcore.
    
    Since I'm going to rename `Char::is_digit_radix` to
    `is_digit`, I am not leaving a deprecated method in place,
    because that would just cause name clashes, as both
    `Char` and `UnicodeChar` are in the prelude.
    
    [breaking-change]

commit c9f6d696420107f82304b992cf623b806995fe18
Merge: 9830051 32c3d02
Author: bors &lt;bors@rust-lang.org&gt;
Date:   Fri Nov 21 03:41:45 2014 +0000

    auto merge of #18967 : aturon/rust/remove-runtime, r=alexcrichton
    
    This PR completes the removal of the runtime system and green-threaded abstractions as part of implementing [RFC 230](https://github.com/rust-lang/rfcs/pull/230).
    
    Specifically:
    
    * It removes the `Runtime` trait, welding the scheduling infrastructure directly to native threads.
    
    * It removes `libgreen` and `libnative` entirely.
    
    * It rewrites `sync::mutex` as a trivial layer on top of native mutexes. Eventually, the two modules will be merged.
    
    * It hides the vast majority of `std::rt`.
    
    This completes the basic task of removing the runtime system (I/O and scheduling) and components that depend on it.
    
    After this lands, a follow-up PR will pull the `rustrt` crate back into `std`, turn `std::task` into `std::thread` (with API changes to go along with it), and completely cut out the remaining startup/teardown sequence. Other changes, including new [TLS](https://github.com/rust-lang/rfcs/pull/461) and synchronization are in the RFC or pre-RFC phase.
    
    Closes #17325
    Closes #18687
    
    [breaking-change]
    
    r? @alexcrichton

commit 6987ad22e46f55b12d8749be7522f4578d227c62
Author: Aaron Turon &lt;aturon@mozilla.com&gt;
Date:   Fri Nov 14 16:30:16 2014 -0800

    Make most of std::rt private
    
    Previously, the entire runtime API surface was publicly exposed, but
    that is neither necessary nor desirable. This commit hides most of the
    module, using librustrt directly as needed. The arrangement will need to
    be revisited when rustrt is pulled into std.
    
    [breaking-change]

commit 91a2c0d51241677d71b8c0abc80535e580fe3939
Author: Aaron Turon &lt;aturon@mozilla.com&gt;
Date:   Fri Nov 14 13:56:15 2014 -0800

    Remove libgreen
    
    With runtime removal complete, there is no longer any reason to provide
    libgreen.
    
    [breaking-change]

commit 3ee916e50bd86768cb2a9141f9b2c52d2601b412
Author: Aaron Turon &lt;aturon@mozilla.com&gt;
Date:   Fri Nov 14 13:55:57 2014 -0800

    Remove libnative
    
    With runtime removal complete, there's nothing left of libnative. This
    commit removes it.
    
    Fixes #18687
    
    [breaking-change]

commit ad022b1a1bcdb8d2e6d1f200f5824f16de2c2193
Author: Aaron Turon &lt;aturon@mozilla.com&gt;
Date:   Fri Nov 14 13:40:34 2014 -0800

    Remove Runtime trait
    
    This commit removes most of the remaining runtime infrastructure related
    to the green/native split. In particular, it removes the `Runtime` trait
    and instead inlines the native implementation.
    
    Closes #17325
    
    [breaking-change]

commit b825b3496aff1ed784f7a7ca935245208b95aabb
Merge: dd5ce5a c287afb
Author: bors &lt;bors@rust-lang.org&gt;
Date:   Thu Nov 20 10:01:42 2014 +0000

    auto merge of #18638 : aturon/rust/as_slice_dst, r=japaric
    
    This PR changes `AsSlice` to work on unsized types, and changes the
    `impl` for `&amp;[T]` to `[T]`. Aside from making the trait more general,
    this also helps some ongoing work with method resolution changes.
    
    This is a breaking change: code that uses generics bounded by `AsSlice`
    will have to change. In particular, such code previously often took
    arguments of type `V` where `V: AsSlice&lt;T&gt;` by value. These should now
    be taken by reference:
    
    ```rust
    fn foo&lt;Sized? V: AsSlice&lt;T&gt;&gt;(v: &amp;V) { .. }
    ```
    
    A few std lib functions have been changed accordingly.
    
    The PR also relaxes constraints on generics and traits within the
    `core::ops` module and for the `Equiv` trait.
    
    [breaking-change]
    
    r? @nikomatsakis
    cc @japaric

commit 3f3b2d6b7ef68d3a3817804fa4dba849a74e6878
Author: Huon Wilson &lt;dbau.pp+github@gmail.com&gt;
Date:   Tue Nov 18 23:03:58 2014 +1100

    Rename `col!` to `column!`.
    
    This macro is very rarely used, so there is no need (and it is better)
    for it to avoid the abbreviation.
    
    Closes rust-lang/rfcs#467.
    
    [breaking-change]
</pre></body></html>
