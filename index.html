<!DOCTYPE html><html><head>
<title>BitRust - Breaking Changes in rust-lang/rust</title>
</head><body><pre>
commit 34fa70fba5425cbbb96bce783e9fd5c23dd9b471
Author: Alex Crichton &lt;alex@alexcrichton.com&gt;
Date:   Fri Jan 16 12:20:03 2015 -0800

    std: Move the bitflags! macro to a gated crate
    
    In accordance with [collections reform part 2][rfc] this macro has been moved to
    an external [bitflags crate][crate] which is [available though
    crates.io][cratesio]. Inside the standard distribution the macro has been moved
    to a crate called `rustc_bitflags` for current users to continue using.
    
    [rfc]: https://github.com/rust-lang/rfcs/blob/master/text/0509-collections-reform-part-2.md
    [crate]: https://github.com/rust-lang/bitflags
    [cratesio]: http://crates.io/crates/bitflags
    
    The major user of `bitflags!` in terms of a public-facing possibly-stable API
    today is the `FilePermissions` structure inside of `std::io`. This user,
    however, will likely no longer use `bitflags!` after I/O reform has landed. To
    prevent breaking APIs today, this structure remains as-is.
    
    Current users of the `bitflags!` macro should add this to their `Cargo.toml`:
    
        bitflags = "0.1"
    
    and this to their crate root:
    
        #[macro_use] extern crate bitflags;
    
    Due to the removal of a public macro, this is a:
    
    [breaking-change]

commit 873ae555e9a42fd12b0a92134112ec000d749ab2
Author: Simonas Kazlauskas &lt;git@kazlauskas.me&gt;
Date:   Thu Jan 15 22:56:53 2015 +0200

    Revert stability for Bitv and BitvSet
    
    The collections were promoted to stable by mistake and do not match RFC 509.
    This reverts the stability back to unstable.
    
    [breaking-change] since previously stable API became unstable.
    
    Fixes #21193

commit cbeb77ec7a42b988703fa0b0c857f26d464fdc2f
Author: Alex Crichton &lt;alex@alexcrichton.com&gt;
Date:   Tue Jan 6 08:46:07 2015 -0800

    rustc: Fix a leak in dependency= paths
    
    With the addition of separate search paths to the compiler, it was intended that
    applications such as Cargo could require a `--extern` flag per `extern crate`
    directive in the source. The system can currently be subverted, however, due to
    the `existing_match()` logic in the crate loader.
    
    When loading crates we first attempt to match an `extern crate` directive
    against all previously loaded crates to avoid reading metadata twice. This "hit
    the cache if possible" step was erroneously leaking crates across the search
    path boundaries, however. For example:
    
        extern crate b;
        extern crate a;
    
    If `b` depends on `a`, then it will load crate `a` when the `extern crate b`
    directive is being processed. When the compiler reaches `extern crate a` it will
    use the previously loaded version no matter what. If the compiler was not
    invoked with `-L crate=path/to/a`, it will still succeed.
    
    This behavior is allowing `extern crate` declarations in Cargo without a
    corresponding declaration in the manifest of a dependency, which is considered
    a bug.
    
    This commit fixes this problem by keeping track of the origin search path for a
    crate. Crates loaded from the dependency search path are not candidates for
    crates which are loaded from the crate search path.
    
    As a result of this fix, this is a likely a breaking change for a number of
    Cargo packages. If the compiler starts informing that a crate can no longer be
    found, it likely means that the dependency was forgotten in your Cargo.toml.
    
    [breaking-change]

commit ee2bfae011e368e224d6d4f4c9fad13606ee99da
Merge: f3d71be cb85223
Author: bors &lt;bors@rust-lang.org&gt;
Date:   Fri Jan 16 13:10:59 2015 +0000

    auto merge of #20972 : FlaPer87/rust/oibit-send-and-friends, r=nikomatsakis
    
    This PR adds rules for negative implementations. It follows pretty much what the [RFC](https://github.com/rust-lang/rfcs/blob/master/text/0019-opt-in-builtin-traits.md) says with 1 main difference:
    
    Instead of positive implementations override negative implementations, this have been implemented in a way that a negative implementation of `Trait` for `T` will overlap with a positive implementation, causing a coherence error.
    
    @nikomatsakis r?
    
    cc #13231
    
    [breaking-change]

commit 0419b4ab1225595b022d8ed4e425526b4d850995
Merge: 7be39b0 de7b3cf
Author: Alex Crichton &lt;alex@alexcrichton.com&gt;
Date:   Thu Jan 15 14:12:00 2015 -0800

    rollup merge of #21167: FlaPer87/coherence-impls
    
    Fixes #21080
    
    r? @nikomatsakis
    
    [breaking-change]

commit 3d0d9bb6fbdf6ead9396f0874cf38f3ef7c9be5c
Merge: 3a44a19 8b6cda3
Author: bors &lt;bors@rust-lang.org&gt;
Date:   Mon Jan 12 22:56:20 2015 +0000

    auto merge of #20896 : sfackler/rust/atomic-rename, r=alexcrichton
    
    Change any use of AtomicInt to AtomicIsize and AtomicUint to AtomicUsize
    
    Closes #20893
    
    [breaking-change]

commit 8b6cda3ce681d4d95c3097d12ed754975b4a07f6
Author: Steven Fackler &lt;sfackler@gmail.com&gt;
Date:   Sat Jan 10 13:42:48 2015 -0800

    Rename AtomicInt and AtomicUint
    
    Change any use of AtomicInt to AtomicIsize and AtomicUint to AtomicUsize
    
    Closes #20893
    
    [breaking-change]

commit 2e4cef4e78253beb4c08ed35416fad076d978344
Merge: 2127e0d b4fae2f
Author: bors &lt;bors@rust-lang.org&gt;
Date:   Sun Jan 11 16:45:48 2015 +0000

    auto merge of #20910 : sfackler/rust/show-impls, r=alexcrichton
    
    A derived implementation would not be appropriate for the Buffered types
    since the buffer is both huge (64k by default) and full of uninitialized
    memory. Instead of printing the whole thing, we display how full it is.
    
    I also altered `MultiWriter` to make it generic over Writers instead of
    taking `Box&lt;Writer&gt;` trait objects. `Box&lt;Writer&gt;` implements `Writer` so
    existing use cases should continue to work, and this enables a more
    useful Show implementation in applicable cases.
    
    The change to `MultiWriter` may break code that uses it, but any fixes
    should be easy.
    
    [breaking-change]
    
    r? @alexcrichton

commit b4fae2fba99e713a6d6a8a59caaf1cfba847b50e
Author: Steven Fackler &lt;sfackler@gmail.com&gt;
Date:   Sat Jan 10 17:32:54 2015 -0800

    Implement Show for types in std::io::{buffered,util}
    
    A derived implementation would not be appropriate for the Buffered types
    since the buffer is both huge (64k by default) and full of uninitialized
    memory. Instead of printing the whole thing, we display how full it is.
    
    I also altered MultiWriter to make it generic over Writers instead of
    taking Box&lt;Writer&gt; trait objects. Box&lt;Writer&gt; implements Writer so
    existing use cases should continue to work, and this enables a more
    useful Show implementation in applicable cases.
    
    The change to MultiWriter may break code that uses it, but any fixes
    should be easy.
    
    [breaking-change]

commit daee409b60cdb17040122343e0a184049c62180b
Merge: e40f62d 0d0869a
Author: Alex Crichton &lt;alex@alexcrichton.com&gt;
Date:   Thu Jan 8 09:22:06 2015 -0800

    rollup merge of #20740: FlaPer87/remove-opt-out-copy
    
    [breaking-change] code using this feature will break.

commit 92cd8ea96ad2a1da51863b7f089baec41ed10ce9
Author: Huon Wilson &lt;dbau.pp+github@gmail.com&gt;
Date:   Thu Jan 8 11:39:45 2015 +1100

    Prohibit type parameter shadowing with a clunky hammer.
    
    This is a [breaking-change].
    
    Change
    
        impl&lt;T&gt; Foo&lt;T&gt; {
            fn bar&lt;T&gt;(...
    
    to (for example)
    
        impl&lt;T&gt; Foo&lt;T&gt; {
            fn bar&lt;U&gt;(...
    
    Per RFC 459.
    
    Closes #19390.

commit 6301c7878ebcaa45e77315db2a9afd8b5d1425c8
Merge: f3b67af dd3e89a
Author: Alex Crichton &lt;alex@alexcrichton.com&gt;
Date:   Wed Jan 7 17:17:23 2015 -0800

    rollup merge of #20680: nick29581/target-word
    
    Closes #20421
    
    [breaking-change]
    
    r? @brson

commit 8bf3ee7c5c44fa5aa0a1003e8fe61a0af1527927
Merge: b1c23f6 511f0b8
Author: Alex Crichton &lt;alex@alexcrichton.com&gt;
Date:   Wed Jan 7 17:17:19 2015 -0800

    rollup merge of #20654: alexcrichton/stabilize-hash
    
    This commit aims to prepare the `std::hash` module for alpha by formalizing its
    current interface whileholding off on adding `#[stable]` to the new APIs.  The
    current usage with the `HashMap` and `HashSet` types is also reconciled by
    separating out composable parts of the design. The primary goal of this slight
    redesign is to separate the concepts of a hasher's state from a hashing
    algorithm itself.
    
    The primary change of this commit is to separate the `Hasher` trait into a
    `Hasher` and a `HashState` trait. Conceptually the old `Hasher` trait was
    actually just a factory for various states, but hashing had very little control
    over how these states were used. Additionally the old `Hasher` trait was
    actually fairly unrelated to hashing.
    
    This commit redesigns the existing `Hasher` trait to match what the notion of a
    `Hasher` normally implies with the following definition:
    
        trait Hasher {
            type Output;
            fn reset(&amp;mut self);
            fn finish(&amp;self) -&gt; Output;
        }
    
    This `Hasher` trait emphasizes that hashing algorithms may produce outputs other
    than a `u64`, so the output type is made generic. Other than that, however, very
    little is assumed about a particular hasher. It is left up to implementors to
    provide specific methods or trait implementations to feed data into a hasher.
    
    The corresponding `Hash` trait becomes:
    
        trait Hash&lt;H: Hasher&gt; {
            fn hash(&amp;self, &amp;mut H);
        }
    
    The old default of `SipState` was removed from this trait as it's not something
    that we're willing to stabilize until the end of time, but the type parameter is
    always required to implement `Hasher`. Note that the type parameter `H` remains
    on the trait to enable multidispatch for specialization of hashing for
    particular hashers.
    
    Note that `Writer` is not mentioned in either of `Hash` or `Hasher`, it is
    simply used as part `derive` and the implementations for all primitive types.
    
    With these definitions, the old `Hasher` trait is realized as a new `HashState`
    trait in the `collections::hash_state` module as an unstable addition for
    now. The current definition looks like:
    
        trait HashState {
            type Hasher: Hasher;
            fn hasher(&amp;self) -&gt; Hasher;
        }
    
    The purpose of this trait is to emphasize that the one piece of functionality
    for implementors is that new instances of `Hasher` can be created.  This
    conceptually represents the two keys from which more instances of a
    `SipHasher` can be created, and a `HashState` is what's stored in a
    `HashMap`, not a `Hasher`.
    
    Implementors of custom hash algorithms should implement the `Hasher` trait, and
    only hash algorithms intended for use in hash maps need to implement or worry
    about the `HashState` trait.
    
    The entire module and `HashState` infrastructure remains `#[unstable]` due to it
    being recently redesigned, but some other stability decision made for the
    `std::hash` module are:
    
    * The `Writer` trait remains `#[experimental]` as it's intended to be replaced
      with an `io::Writer` (more details soon).
    * The top-level `hash` function is `#[unstable]` as it is intended to be generic
      over the hashing algorithm instead of hardwired to `SipHasher`
    * The inner `sip` module is now private as its one export, `SipHasher` is
      reexported in the `hash` module.
    
    And finally, a few changes were made to the default parameters on `HashMap`.
    
    * The `RandomSipHasher` default type parameter was renamed to `RandomState`.
      This renaming emphasizes that it is not a hasher, but rather just state to
      generate hashers. It also moves away from the name "sip" as it may not always
      be implemented as `SipHasher`. This type lives in the
      `std::collections::hash_map` module as `#[unstable]`
    
    * The associated `Hasher` type of `RandomState` is creatively called...
      `Hasher`! This concrete structure lives next to `RandomState` as an
      implemenation of the "default hashing algorithm" used for a `HashMap`. Under
      the hood this is currently implemented as `SipHasher`, but it draws an
      explicit interface for now and allows us to modify the implementation over
      time if necessary.
    
    There are many breaking changes outlined above, and as a result this commit is
    a:
    
    [breaking-change]

commit 4a31aaddb364f5ab8280242a1016bdd3d10dcaed
Author: Felix S. Klock II &lt;pnkfelix@pnkfx.org&gt;
Date:   Wed Jan 7 15:15:34 2015 +0100

    Added `box_syntax` feature gate; added to std and rustc crates for bootstrap.
    
    To avoid using the feauture, change uses of `box &lt;expr&gt;` to
    `Box::new(&lt;expr&gt;)` alternative, as noted by the feature gate message.
    
    (Note that box patterns have no analogous trivial replacement, at
    least not in general; you need to revise the code to do a partial
    match, deref, and then the rest of the match.)
    
    [breaking-change]

commit 63a9bd5e0adc03652e10506055564077aa00eeaa
Author: Nick Cameron &lt;ncameron@mozilla.com&gt;
Date:   Thu Jan 8 08:30:33 2015 +1300

    Fix precedence for ranges.
    
    Technically this is a
    
    [breaking-change]
    
    but it probably shouldn't affect your code.
    
    Closes #20256

commit 209c701bf9e95542aec69455bc12c7ca295109c4
Author: Alex Crichton &lt;alex@alexcrichton.com&gt;
Date:   Tue Jan 6 11:07:09 2015 -0800

    std: Stablize the macros module
    
    This commit performs a pass over the `std::macros` module, applying stability
    attributes where necessary. In particular, this audits macros for patterns such
    as:
    
    * Standard use of forward-to-format-args via `$($arg:tt)*` (or `+`)
    * Prevent macro-defined identifiers from leaking into expression arguments as
      hygiene is not perfectly implemented.
    * Wherever possible, `$crate` is used now.
    
    Specifically, the following actions were taken:
    
    * The `std::macros` module itself is no longer public.
    * The `panic!` macro is stable
    * The `assert!` macro is stable
    * The `assert_eq!` macro is stable
    * The `debug_assert!` macro is stable
    * The `debug_assert_eq!` macro is stable
    * The `unreachable!` macro is stable after removing the extra forms to bring the
      definition in line with the `unimplemented!` macro.
    * The `try!` macro is stable
    * The `vec!` macro is stable
    
    [breaking-change]

commit 511f0b8a3de5a166fc96aba5170782c9abf92101
Author: Alex Crichton &lt;alex@alexcrichton.com&gt;
Date:   Tue Dec 9 12:37:23 2014 -0800

    std: Stabilize the std::hash module
    
    This commit aims to prepare the `std::hash` module for alpha by formalizing its
    current interface whileholding off on adding `#[stable]` to the new APIs.  The
    current usage with the `HashMap` and `HashSet` types is also reconciled by
    separating out composable parts of the design. The primary goal of this slight
    redesign is to separate the concepts of a hasher's state from a hashing
    algorithm itself.
    
    The primary change of this commit is to separate the `Hasher` trait into a
    `Hasher` and a `HashState` trait. Conceptually the old `Hasher` trait was
    actually just a factory for various states, but hashing had very little control
    over how these states were used. Additionally the old `Hasher` trait was
    actually fairly unrelated to hashing.
    
    This commit redesigns the existing `Hasher` trait to match what the notion of a
    `Hasher` normally implies with the following definition:
    
        trait Hasher {
            type Output;
            fn reset(&amp;mut self);
            fn finish(&amp;self) -&gt; Output;
        }
    
    This `Hasher` trait emphasizes that hashing algorithms may produce outputs other
    than a `u64`, so the output type is made generic. Other than that, however, very
    little is assumed about a particular hasher. It is left up to implementors to
    provide specific methods or trait implementations to feed data into a hasher.
    
    The corresponding `Hash` trait becomes:
    
        trait Hash&lt;H: Hasher&gt; {
            fn hash(&amp;self, &amp;mut H);
        }
    
    The old default of `SipState` was removed from this trait as it's not something
    that we're willing to stabilize until the end of time, but the type parameter is
    always required to implement `Hasher`. Note that the type parameter `H` remains
    on the trait to enable multidispatch for specialization of hashing for
    particular hashers.
    
    Note that `Writer` is not mentioned in either of `Hash` or `Hasher`, it is
    simply used as part `derive` and the implementations for all primitive types.
    
    With these definitions, the old `Hasher` trait is realized as a new `HashState`
    trait in the `collections::hash_state` module as an unstable addition for
    now. The current definition looks like:
    
        trait HashState {
            type Hasher: Hasher;
            fn hasher(&amp;self) -&gt; Hasher;
        }
    
    The purpose of this trait is to emphasize that the one piece of functionality
    for implementors is that new instances of `Hasher` can be created.  This
    conceptually represents the two keys from which more instances of a
    `SipHasher` can be created, and a `HashState` is what's stored in a
    `HashMap`, not a `Hasher`.
    
    Implementors of custom hash algorithms should implement the `Hasher` trait, and
    only hash algorithms intended for use in hash maps need to implement or worry
    about the `HashState` trait.
    
    The entire module and `HashState` infrastructure remains `#[unstable]` due to it
    being recently redesigned, but some other stability decision made for the
    `std::hash` module are:
    
    * The `Writer` trait remains `#[experimental]` as it's intended to be replaced
      with an `io::Writer` (more details soon).
    * The top-level `hash` function is `#[unstable]` as it is intended to be generic
      over the hashing algorithm instead of hardwired to `SipHasher`
    * The inner `sip` module is now private as its one export, `SipHasher` is
      reexported in the `hash` module.
    
    And finally, a few changes were made to the default parameters on `HashMap`.
    
    * The `RandomSipHasher` default type parameter was renamed to `RandomState`.
      This renaming emphasizes that it is not a hasher, but rather just state to
      generate hashers. It also moves away from the name "sip" as it may not always
      be implemented as `SipHasher`. This type lives in the
      `std::collections::hash_map` module as `#[unstable]`
    
    * The associated `Hasher` type of `RandomState` is creatively called...
      `Hasher`! This concrete structure lives next to `RandomState` as an
      implemenation of the "default hashing algorithm" used for a `HashMap`. Under
      the hood this is currently implemented as `SipHasher`, but it draws an
      explicit interface for now and allows us to modify the implementation over
      time if necessary.
    
    There are many breaking changes outlined above, and as a result this commit is
    a:
    
    [breaking-change]

commit dd3e89aaf25c667fa8207f8800c4b60d70d76c1b
Author: Nick Cameron &lt;ncameron@mozilla.com&gt;
Date:   Wed Jan 7 17:26:55 2015 +1300

    Rename `target_word_size` to `target_pointer_width`
    
    Closes #20421
    
    [breaking-change]

commit 7deb9abd1b45f3e56ca6b13432866ae89886f21f
Author: Aaron Turon &lt;aturon@mozilla.com&gt;
Date:   Wed Jan 7 10:39:37 2015 -0800

    Add isize, usize modules, deprecate int, uint modules
    
    This PR introduces `isize` and `usize` modules to `core` and `std`, and
    deprecates the existing `int` and `uint` modules. The rustdoc primitive
    type links now point to these new modules.
    
    Due to deprecation this is a:
    
    [breaking-change]

commit 36f5d122b80682de473aeda2e20f14b6ceb86d74
Merge: 0631b46 caca9b2
Author: Alex Crichton &lt;alex@alexcrichton.com&gt;
Date:   Tue Jan 6 15:38:38 2015 -0800

    rollup merge of #20615: aturon/stab-2-thread
    
    This commit takes a first pass at stabilizing `std::thread`:
    
    * It removes the `detach` method in favor of two constructors -- `spawn`
      for detached threads, `scoped` for "scoped" (i.e., must-join)
      threads. This addresses some of the surprise/frustrating debug
      sessions with the previous API, in which `spawn` produced a guard that
      on destruction joined the thread (unless `detach` was called).
    
      The reason to have the division in part is that `Send` will soon not
      imply `'static`, which means that `scoped` thread creation can take a
      closure over *shared stack data* of the parent thread. On the other
      hand, this means that the parent must not pop the relevant stack
      frames while the child thread is running. The `JoinGuard` is used to
      prevent this from happening by joining on drop (if you have not
      already explicitly `join`ed.) The APIs around `scoped` are
      future-proofed for the `Send` changes by taking an additional lifetime
      parameter. With the current definition of `Send`, this is forced to be
      `'static`, but when `Send` changes these APIs will gain their full
      flexibility immediately.
    
      Threads that are `spawn`ed, on the other hand, are detached from the
      start and do not yield an RAII guard.
    
      The hope is that, by making `scoped` an explicit opt-in with a very
      suggestive name, it will be drastically less likely to be caught by a
      surprising deadlock due to an implicit join at the end of a scope.
    
    * The module itself is marked stable.
    
    * Existing methods other than `spawn` and `scoped` are marked stable.
    
    The migration path is:
    
    ```rust
    Thread::spawn(f).detached()
    ```
    
    becomes
    
    ```rust
    Thread::spawn(f)
    ```
    
    while
    
    ```rust
    let res = Thread::spawn(f);
    res.join()
    ```
    
    becomes
    
    ```rust
    let res = Thread::scoped(f);
    res.join()
    ```
    
    [breaking-change]

commit 44440e5c18a1dbcc9685866ffffe00c508929079
Author: Sean McArthur &lt;sean.monstar@gmail.com&gt;
Date:   Sat Dec 20 00:09:35 2014 -0800

    core: split into fmt::Show and fmt::String
    
    fmt::Show is for debugging, and can and should be implemented for
    all public types. This trait is used with `{:?}` syntax. There still
    exists #[derive(Show)].
    
    fmt::String is for types that faithfully be represented as a String.
    Because of this, there is no way to derive fmt::String, all
    implementations must be purposeful. It is used by the default format
    syntax, `{}`.
    
    This will break most instances of `{}`, since that now requires the type
    to impl fmt::String. In most cases, replacing `{}` with `{:?}` is the
    correct fix. Types that were being printed specifically for users should
    receive a fmt::String implementation to fix this.
    
    Part of #20013
    
    [breaking-change]

commit 2375a79152b8a6554c3e97a3f127fedd75f7495f
Author: Niko Matsakis &lt;niko@alum.mit.edu&gt;
Date:   Mon Jan 5 06:17:42 2015 -0500

    Implement impl reachability rules. This is a [breaking-change]. Type
    parameters on impls must now also appear in the trait ref, self type,
    or some associated type declared on the impl. This ensures that they
    are constrianed in some way and that the semantics of the trait system
    are well-defined (always a good thing).
    
    There are three major ways to fix this error:
    
    1. Convert the trait to use associated types; most often the type
       parameters are not constrained because they are in fact outputs of
       the impl.
    
    2. Move the type parameters to methods.
    
    3. Add an additional type parameter to the self type or trait so that
       the unused parameter can appear there.
    
    In some cases, it is not possible to fix the impl because the trait
    definition needs to be changed first (and that may be out of your
    control). In that case, for the time being, you can opt out of these
    rules by using `#[old_impl_check]` on the impl and adding a
    `#![feature(old_impl_check)]` to your crate declaration.

commit 503709708c72401dbe091ed5c7e0494efabe0669
Author: Nick Cameron &lt;ncameron@mozilla.com&gt;
Date:   Tue Jan 6 14:03:46 2015 +1300

    Change `std::kinds` to `std::markers`; flatten `std::kinds::marker`
    
    [breaking-change]

commit f67b81e8d4dc198ad10ad50a7624e43cc1e25802
Author: Aaron Turon &lt;aturon@mozilla.com&gt;
Date:   Mon Jan 5 15:45:18 2015 -0800

    Stabilize std::thread
    
    This commit takes a first pass at stabilizing `std::thread`:
    
    * It removes the `detach` method in favor of two constructors -- `spawn`
      for detached threads, `scoped` for "scoped" (i.e., must-join)
      threads. This addresses some of the surprise/frustrating debug
      sessions with the previous API, in which `spawn` produced a guard that
      on destruction joined the thread (unless `detach` was called).
    
      The reason to have the division in part is that `Send` will soon not
      imply `'static`, which means that `scoped` thread creation can take a
      closure over *shared stack data* of the parent thread. On the other
      hand, this means that the parent must not pop the relevant stack
      frames while the child thread is running. The `JoinGuard` is used to
      prevent this from happening by joining on drop (if you have not
      already explicitly `join`ed.) The APIs around `scoped` are
      future-proofed for the `Send` changes by taking an additional lifetime
      parameter. With the current definition of `Send`, this is forced to be
      `'static`, but when `Send` changes these APIs will gain their full
      flexibility immediately.
    
      Threads that are `spawn`ed, on the other hand, are detached from the
      start and do not yield an RAII guard.
    
      The hope is that, by making `scoped` an explicit opt-in with a very
      suggestive name, it will be drastically less likely to be caught by a
      surprising deadlock due to an implicit join at the end of a scope.
    
    * The module itself is marked stable.
    
    * Existing methods other than `spawn` and `scoped` are marked stable.
    
    The migration path is:
    
    ```rust
    Thread::spawn(f).detached()
    ```
    
    becomes
    
    ```rust
    Thread::spawn(f)
    ```
    
    while
    
    ```rust
    let res = Thread::spawn(f);
    res.join()
    ```
    
    becomes
    
    ```rust
    let res = Thread::scoped(f);
    res.join()
    ```
    
    [breaking-change]

commit 6680c9c5c797101fc5e0608cb2c3657517333148
Author: Corey Richardson &lt;corey@octayn.net&gt;
Date:   Fri Jan 2 16:41:24 2015 -0500

    syntax: implement 'macro input future proofing'
    
    See RFC 550 (https://github.com/rust-lang/rfcs/pull/550) for the motivation
    and details.
    
    If this breaks your code, add one of the listed tokens after the relevant
    non-terminal in your matcher.
    
    [breaking-change]

commit ae4762761c995494726e8c9f41b05e99e6c7c81b
Author: Huon Wilson &lt;dbau.pp+github@gmail.com&gt;
Date:   Mon Jan 5 21:14:50 2015 +1100

    Merge core::num::Float and std::num::FloatMath.
    
    `FloatMath` no longer exists and all functionality from both traits is
    available under `Float`. Change from
    
        use std::num::{Float, FloatMath};
    
    to
    
        use std::num::Float;
    
    [breaking-change]

commit cd4ed38404384bdb13500f1d2e782d32ece2b239
Author: Huon Wilson &lt;dbau.pp+github@gmail.com&gt;
Date:   Mon Jan 5 18:30:55 2015 +1100

    Deprecate the constant-returning functions in Float.
    
    These are replaced by the equivalent constants in `std::f32` and
    `std::f64` respectively.
    
    [breaking-change]

commit 25d5a3a19423fee01787de87a56d185dd4e0a4e7
Merge: 743d926 ec7a50d
Author: Alex Crichton &lt;alex@alexcrichton.com&gt;
Date:   Mon Jan 5 18:37:22 2015 -0800

    rollup merge of #20507: alexcrichton/issue-20444
    
    This commit is an implementation of [RFC 494][rfc] which removes the entire
    `std::c_vec` module and redesigns the `std::c_str` module as `std::ffi`.
    
    [rfc]: https://github.com/rust-lang/rfcs/blob/master/text/0494-c_str-and-c_vec-stability.md
    
    The interface of the new `CString` is outlined in the linked RFC, the primary
    changes being:
    
    * The `ToCStr` trait is gone, meaning the `with_c_str` and `to_c_str` methods
      are now gone. These two methods are replaced with a `CString::from_slice`
      method.
    * The `CString` type is now just a wrapper around `Vec&lt;u8&gt;` with a static
      guarantee that there is a trailing nul byte with no internal nul bytes. This
      means that `CString` now implements `Deref&lt;Target = [c_char]&gt;`, which is where
      it gains most of its methods from. A few helper methods are added to acquire a
      slice of `u8` instead of `c_char`, as well as including a slice with the
      trailing nul byte if necessary.
    * All usage of non-owned `CString` values is now done via two functions inside
      of `std::ffi`, called `c_str_to_bytes` and `c_str_to_bytes_with_nul`. These
      functions are now the one method used to convert a `*const c_char` to a Rust
      slice of `u8`.
    
    Many more details, including newly deprecated methods, can be found linked in
    the RFC. This is a:
    
    [breaking-change]
    Closes #20444

commit 88b4c8e0d347921673e61bf1770ba0acd4c7d824
Merge: 059566b 5caf847
Author: Alex Crichton &lt;alex@alexcrichton.com&gt;
Date:   Mon Jan 5 18:36:34 2015 -0800

    rollup merge of #20465: nikomatsakis/assoc-types-regions-20303
    
    Treat associated types the same as type parameters when it comes to region bounding. Fixes #20303.
    
    Strictly speaking, this is a [breaking-change] (if you are using
    associated types). You are no longer free to wantonly violate the type
    system rules by closing associated types into objects without any form
    of region bound. Instead you should add region bounds like `T::X :
    'a`, just as you would with a normal type parameter.
    
    r? @aturon

commit 48f50e1e98691d74427e23e82694f528b3fb4d56
Author: Nick Cameron &lt;ncameron@mozilla.com&gt;
Date:   Tue Jan 6 09:44:33 2015 +1300

    Obsolete `Sized? T`
    
    [breaking-change]
    
    Use `T: ?Sized`

commit c7dd3c4d69aee1c4ad8cc220c194b176bba2ab62
Merge: f11f3e7 eb2506c
Author: bors &lt;bors@rust-lang.org&gt;
Date:   Mon Jan 5 23:51:00 2015 +0000

    auto merge of #20578 : japaric/rust/no-more-bc, r=nmatsakis
    
    This PR removes boxed closures from the language, the closure type syntax (`let f: |int| -&gt; bool = /* ... */`) has been obsoleted. Move all your uses of closures to the new unboxed closure system (i.e. `Fn*` traits).
    
    [breaking-change] patterns
    
    - `lef f = || {}`
    
    This binding used to type check to a boxed closure. Now that boxed closures are gone, you need to annotate the "kind" of the unboxed closure, i.e. you need pick one of these: `|&amp;:| {}`, `|&amp;mut:| {}` or `|:| {}`.
    
    In the (near) future we'll have closure "kind" inference, so the compiler will infer which `Fn*` trait to use based on how the closure is used. Once this inference machinery is in place, we'll be able to remove the kind annotation from most closures.
    
    - `type Alias&lt;'a&gt; = |int|:'a -&gt; bool`
    
    Use a trait object: `type Alias&lt;'a&gt; = Box&lt;FnMut(int) -&gt; bool + 'a&gt;`. Use the `Fn*` trait that makes sense for your use case.
    
    - `fn foo(&amp;self, f: |uint| -&gt; bool)`
    
    In this case you can use either a trait object or an unboxed closure:
    
    ``` rust
    fn foo(&amp;self, f: F) where F: FnMut(uint) -&gt; bool;
    // or
    fn foo(&amp;self, f: Box&lt;FnMut(uint) -&gt; bool&gt;);
    ```
    
    - `struct Struct&lt;'a&gt; { f: |uint|:'a -&gt; bool }`
    
    Again, you can use either a trait object or an unboxed closure:
    
    ``` rust
    struct Struct&lt;F&gt; where F: FnMut(uint) -&gt; bool { f: F }
    // or
    struct Struct&lt;'a&gt; { f: Box&lt;FnMut(uint) -&gt; bool + 'a&gt; }
    ```
    
    - Using `|x, y| f(x, y)` for closure "borrows"
    
    This comes up in recursive functions, consider the following (contrived) example:
    
    ``` rust
    fn foo(x: uint, f: |uint| -&gt; bool) -&gt; bool {
        //foo(x / 2, f) &amp;&amp; f(x)  // can't use this because `f` gets moved away in the `foo` call
        foo(x / 2, |x| f(x)) &amp;&amp; f(x)  // instead "borrow" `f` in the `foo` call
    }
    ```
    
    If you attempt to do the same with unboxed closures you'll hit ""error: reached the recursion limit during monomorphization" (see #19596):
    
    ``` rust
    fn foo&lt;F&gt;(x: uint, mut f: F) -&gt; bool where F: FnMut(uint) -&gt; bool {
        foo(x / 2, |x| f(x)) &amp;&amp; f(x)
        //~^ error: reached the recursion limit during monomorphization
    }
    ```
    
    Instead you *should* be able to write this:
    
    ``` rust
    fn foo&lt;F&gt;(x: uint, mut f: F) -&gt; bool where F: FnMut(uint) -&gt; bool {
        foo(x / 2, &amp;mut f) &amp;&amp; f(x)
        //~^ error: the trait `FnMut` is not implemented for the type `&amp;mut F`
    }
    ```
    
    But as you see above `&amp;mut F` doesn't implement the `FnMut` trait. `&amp;mut F` *should* implement the `FnMut` and the above code *should* work, but due to a bug (see #18835) it doesn't (for now).
    
    You can work around the issue by rewriting the function to take `&amp;mut F` instead of `F`:
    
    ``` rust
    fn foo&lt;F&gt;(x: uint, f: &amp;mut F) -&gt; bool where F: FnMut(uint) -&gt; bool {
        foo(x / 2, f) &amp;&amp; (*f)(x)
    }
    ```
    
    This finally works! However writing `foo(0, &amp;mut |x| x == 0)` is unergonomic. So you can use a private helper function to avoid this:
    
    ``` rust
    // public API function
    pub fn foo&lt;F&gt;(x: uint, mut f: F) -&gt; bool where F: FnMut(uint) -&gt; bool {
        foo_(x, &amp;mut f)
    }
    
    // private helper function
    fn foo_&lt;F&gt;(x: uint, f: &amp;mut F) -&gt; bool where F: FnMut(uint) -&gt; bool {
        foo_(x / 2, f) &amp;&amp; (*f)(x)
    }
    ```
    
    Closes #14798
    
    ---
    
    There is more cleanup to do: like renaming functions/types from `unboxed_closure` to just `closure`, removing more dead code, simplify functions which now have unused arguments, update the documentation, etc. But that can be done in another PR.
    
    r? @nikomatsakis @aturon (You probably want to focus on the deleted/modified tests.)
    cc @eddyb

commit 6e68fd09edc7ed37fd76f703247b5410cd338bfe
Author: Niko Matsakis &lt;niko@alum.mit.edu&gt;
Date:   Sun Jan 4 20:35:06 2015 -0500

    Implement new orphan rule that requires that impls of remote traits meet the following two criteria:
    
    - the self type includes some local type; and,
    - type parameters in the self type must be constrained by a local type.
    
    A type parameter is called *constrained* if it appears in some type-parameter of a local type.
    
    Here are some examples that are accepted. In all of these examples, I
    assume that `Foo` is a trait defined in another crate. If `Foo` were
    defined in the local crate, then all the examples would be legal.
    
    - `impl Foo for LocalType`
    - `impl&lt;T&gt; Foo&lt;T&gt; for LocalType` -- T does not appear in Self, so it is OK
    - `impl&lt;T&gt; Foo&lt;T&gt; for LocalType&lt;T&gt;` -- T here is constrained by LocalType
    - `impl&lt;T&gt; Foo&lt;T&gt; for (LocalType&lt;T&gt;, T)` -- T here is constrained by LocalType
    
    Here are some illegal examples (again, these examples assume that
    `Foo` is not local to the current crate):
    
    - `impl Foo for int` -- the Self type is not local
    - `impl&lt;T&gt; Foo for T` -- T appears in Self unconstrained by a local type
    - `impl&lt;T&gt; Foo for (LocalType, T)` -- T appears in Self unconstrained by a local type
    
    This is a [breaking-change]. For the time being, you can opt out of
    the new rules by placing `#[old_orphan_check]` on the trait (and
    enabling the feature gate where the trait is defined). Longer term,
    you should restructure your traits to avoid the problem. Usually this
    means changing the order of parameters so that the "central" type
    parameter is in the `Self` position.
    
    As an example of that refactoring, consider the `BorrowFrom` trait:
    
    ```rust
    pub trait BorrowFrom&lt;Sized? Owned&gt; for Sized? {
        fn borrow_from(owned: &amp;Owned) -&gt; &amp;Self;
    }
    ```
    
    As defined, this trait is commonly implemented for custom pointer
    types, such as `Arc`. Those impls follow the pattern:
    
    ```rust
    impl&lt;T&gt; BorrowFrom&lt;Arc&lt;T&gt;&gt; for T {...}
    ```
    
    Unfortunately, this impl is illegal because the self type `T` is not
    local to the current crate. Therefore, we are going to change the order of the parameters,
    so that `BorrowFrom` becomes `Borrow`:
    
    ```rust
    pub trait Borrow&lt;Sized? Borrowed&gt; for Sized? {
        fn borrow_from(owned: &amp;Self) -&gt; &amp;Borrowed;
    }
    ```
    
    Now the `Arc` impl is written:
    
    ```rust
    impl&lt;T&gt; Borrow&lt;T&gt; for Arc&lt;T&gt; { ... }
    ```
    
    This impl is legal because the self type (`Arc&lt;T&gt;`) is local.

commit 64ec47c9d2a75c8150d153450e7e7b7db60208dc
Author: Aaron Turon &lt;aturon@mozilla.com&gt;
Date:   Sun Jan 4 08:43:27 2015 -0800

    Final alpha stabilization of core::iter
    
    This commit wraps up the adjustments to the iterator for recent language
    changes.
    
    * Moves `rposition` from `ExactSizeIterator` to `IteratorExt` using a
      `where` clause, thereby removing the `ExactSizeIterator:
      DoubleEndedIterator` constraint.
    
    * Merges `MutableDoubleEndedIterator` into `IteratorExt`, renaming
      `reverse_` to `reverse_in_place`.
    
    * Merges `IteratorOrdExt`, `IteratorCloneExt` and `CloneIteratorExt`
      into `IteratorExt` using `where` clauses.
    
    Marks as `#[stable]`:
    
    * the `iter` module itself
    * `FromIterator`, `Extend`
    * `Iterator`, `IteratorExt`
    * `map`
    * `filter`
    * `filter_map`
    * `skip_while`
    * `take_while`
    * `scan`
    * `flat_map`
    * `inspect`
    * `collect`
    * `fold`
    * `all`
    * `any`
    * `find`
    * `rposition`
    * `max`, `min`
    * Various adapter types related to the above methods
    
    Because of the trait merging, this is a:
    
    [breaking-change]

commit ec7a50d20dff416d9fec837a6492dfe244f5f3ab
Author: Alex Crichton &lt;alex@alexcrichton.com&gt;
Date:   Tue Nov 25 13:28:35 2014 -0800

    std: Redesign c_str and c_vec
    
    This commit is an implementation of [RFC 494][rfc] which removes the entire
    `std::c_vec` module and redesigns the `std::c_str` module as `std::ffi`.
    
    [rfc]: https://github.com/rust-lang/rfcs/blob/master/text/0494-c_str-and-c_vec-stability.md
    
    The interface of the new `CString` is outlined in the linked RFC, the primary
    changes being:
    
    * The `ToCStr` trait is gone, meaning the `with_c_str` and `to_c_str` methods
      are now gone. These two methods are replaced with a `CString::from_slice`
      method.
    * The `CString` type is now just a wrapper around `Vec&lt;u8&gt;` with a static
      guarantee that there is a trailing nul byte with no internal nul bytes. This
      means that `CString` now implements `Deref&lt;Target = [c_char]&gt;`, which is where
      it gains most of its methods from. A few helper methods are added to acquire a
      slice of `u8` instead of `c_char`, as well as including a slice with the
      trailing nul byte if necessary.
    * All usage of non-owned `CString` values is now done via two functions inside
      of `std::ffi`, called `c_str_to_bytes` and `c_str_to_bytes_with_nul`. These
      functions are now the one method used to convert a `*const c_char` to a Rust
      slice of `u8`.
    
    Many more details, including newly deprecated methods, can be found linked in
    the RFC. This is a:
    
    [breaking-change]
    Closes #20444

commit c8868942e845254abfd3623a709847d65e015a2f
Author: Niko Matsakis &lt;niko@alum.mit.edu&gt;
Date:   Sat Jan 3 04:40:33 2015 -0500

    Treat associated types the same as type parameters when it comes to region bounding. Fixes #20303.
    
    Strictly speaking, this is a [breaking-change] (if you are using
    associated types). You are no longer free to wantonly violate the type
    system rules by closing associated types into objects without any form
    of region bound. Instead you should add region bounds like `T::X :
    'a`, just as you would with a normal type parameter.

commit 03268bbf35d3ff2350d987fe7b60375839abdf2e
Merge: 8e83af6 0cb7a40
Author: bors &lt;bors@rust-lang.org&gt;
Date:   Mon Jan 5 14:51:03 2015 +0000

    auto merge of #20514 : alexcrichton/rust/serialize-associated-type, r=aturon
    
    This commit moves the libserialize crate (and will force the hand of the
    rustc-serialize crate) to not require the `old_orphan_check` feature gate as
    well as using associated types wherever possible. Concretely, the following
    changes were made:
    
    * The error type of `Encoder` and `Decoder` is now an associated type, meaning
      that these traits have no type parameters.
    
    * The `Encoder` and `Decoder` type parameters on the `Encodable` and `Decodable`
      traits have moved to the corresponding method of the trait. This movement
      alleviates the dependency on `old_orphan_check` but implies that
      implementations can no longer be specialized for the type of encoder/decoder
      being implemented.
    
    Due to the trait definitions changing, this is a:
    
    [breaking-change]

commit 0cb7a4062a3c69bb0c54f0c9136889a1006e4f62
Author: Alex Crichton &lt;alex@alexcrichton.com&gt;
Date:   Sat Jan 3 22:24:50 2015 -0800

    serialize: Use assoc types + less old_orphan_check
    
    This commit moves the libserialize crate (and will force the hand of the
    rustc-serialize crate) to not require the `old_orphan_check` feature gate as
    well as using associated types wherever possible. Concretely, the following
    changes were made:
    
    * The error type of `Encoder` and `Decoder` is now an associated type, meaning
      that these traits have no type parameters.
    
    * The `Encoder` and `Decoder` type parameters on the `Encodable` and `Decodable`
      traits have moved to the corresponding method of the trait. This movement
      alleviates the dependency on `old_orphan_check` but implies that
      implementations can no longer be specialized for the type of encoder/decoder
      being implemented.
    
    Due to the trait definitions changing, this is a:
    
    [breaking-change]

commit bf6c007760169e9c382d3700fd1cdd20037e4343
Author: Huon Wilson &lt;dbau.pp+github@gmail.com&gt;
Date:   Fri Dec 5 15:56:25 2014 -0800

    Change `&amp;` pat to only work with &amp;T, and `&amp;mut` with &amp;mut T.
    
    This implements RFC 179 by making the pattern `&amp;&lt;pat&gt;` require matching
    against a variable of type `&amp;T`, and introducing the pattern `&amp;mut
    &lt;pat&gt;` which only works with variables of type `&amp;mut T`.
    
    The pattern `&amp;mut x` currently parses as `&amp;(mut x)` i.e. a pattern match
    through a `&amp;T` or a `&amp;mut T` that binds the variable `x` to have type
    `T` and to be mutable. This should be rewritten as follows, for example,
    
        for &amp;mut x in slice.iter() {
    
    becomes
    
        for &amp;x in slice.iter() {
            let mut x = x;
    
    Due to this, this is a
    
    [breaking-change]
    
    Closes #20496.

commit 0302d379776fca82d3eb693046239dc66998f691
Author: Huon Wilson &lt;dbau.pp+github@gmail.com&gt;
Date:   Tue Dec 30 13:58:31 2014 +1100

    Merge `UnicodeChar` and `CharExt`.
    
    This "reexports" all the functionality of `core::char::CharExt` as
    methods on `unicode::u_char::UnicodeChar` (renamed to `CharExt`).
    
    Imports may need to be updated (one now just imports
    `unicode::CharExt`, or `std::char::CharExt` rather than two traits from
    either), so this is a
    
    [breaking-change]

commit 19120209d8e532514203d16a2cff0ad3b44de3bb
Author: Huon Wilson &lt;dbau.pp+github@gmail.com&gt;
Date:   Tue Dec 30 13:53:20 2014 +1100

    Rename `core::char::Char` to `CharExt` to match prelude guidelines.
    
    Imports may need to be updated so this is a
    
    [breaking-change]

commit c6c786671d692d7b13c2e5c68a53001327b4b125
Merge: 496dc4e ce8f748
Author: bors &lt;bors@rust-lang.org&gt;
Date:   Sun Jan 4 00:50:59 2015 +0000

    auto merge of #20490 : japaric/rust/assoc-types, r=aturon
    
    closes #20486
    closes #20474
    closes #20441
    
    [breaking-change]
    
    The `Index[Mut]` traits now have one less input parameter, as the return type of the indexing operation is an associated type. This breaks all existing implementations.
    
    ---
    
    binop traits (`Add`, `Sub`, etc) now have an associated type for their return type. Also, the RHS input parameter now defaults to `Self` (except for the `Shl` and `Shr` traits). For example, the `Add` trait now looks like this:
    
    ``` rust
    trait Add&lt;Rhs=Self&gt; {
        type Output;
    
        fn add(self, Rhs) -&gt; Self::Output;
    }
    ```
    
    The `Neg` and `Not` traits now also have an associated type for their return type.
    
    This breaks all existing implementations of these traits.
    
    ---
    Affected traits:
    
    - `Iterator { type Item }`
    - `IteratorExt` no input/output types, uses `&lt;Self as Iterator&gt;::Item` in its methods
    - `DoubleEndedIterator` no input/output types, uses `&lt;Self as Iterator&gt;::Item` in its methods
    - `DoubleEndedIteratorExt` no input/output types, uses `&lt;Self as Iterator&gt;::Item` in its methods
    - `RandomAccessIterator` no input/output types
    - `ExactSizeIterator` no input/output types, uses `&lt;Self as Iterator&gt;::Item` in its methods
    
    This breaks all the implementations of these traits.

commit f031285c3a76b86525695bbb5b46daa9e77df200
Author: Corey Farwell &lt;coreyf@rwell.org&gt;
Date:   Fri Jan 2 19:31:50 2015 -0800

    Remove graphviz::LabelText::* public reexport
    
    Part of #19253
    
    [breaking-change]

commit 9c3e6082e71618c088afd93f7a4a9a7708c9dcbd
Merge: a6b1097 d9769ec
Author: bors &lt;bors@rust-lang.org&gt;
Date:   Sat Jan 3 03:25:21 2015 +0000

    auto merge of #20154 : P1start/rust/qualified-assoc-type-generics, r=nikomatsakis
    
    This modifies `Parser::eat_lt` to always split up `&lt;&lt;`s, instead of doing so only when a lifetime name followed or the `force` parameter (now removed) was `true`. This is because `Foo&lt;&lt;TYPE` is now a valid start to a type, whereas previously only `Foo&lt;&lt;LIFETIME` was valid.
    
    This is a [breaking-change]. Change code that looks like this:
    
    ```rust
    let x = foo as bar &lt;&lt; 13;
    ```
    
    to use parentheses, like this:
    
    ```rust
    let x = (foo as bar) &lt;&lt; 13;
    ```
    
    Closes #17362.

commit 9ca8076cb77a7d7738162c80e1d240ef2ad0b73a
Merge: 073fd5b f9ce6f5
Author: Alex Crichton &lt;alex@alexcrichton.com&gt;
Date:   Fri Jan 2 09:22:37 2015 -0800

    rollup merge of #20386: frewsxcv/rm-reexports
    
    Part of #19253
    
    [breaking-change]

commit 56290a004493a5d2e211f056601533253497df60
Author: Alex Crichton &lt;alex@alexcrichton.com&gt;
Date:   Mon Dec 22 09:04:23 2014 -0800

    std: Stabilize the prelude module
    
    This commit is an implementation of [RFC 503][rfc] which is a stabilization
    story for the prelude. Most of the RFC was directly applied, removing reexports.
    Some reexports are kept around, however:
    
    * `range` remains until range syntax has landed to reduce churn.
    * `Path` and `GenericPath` remain until path reform lands. This is done to
      prevent many imports of `GenericPath` which will soon be removed.
    * All `io` traits remain until I/O reform lands so imports can be rewritten all
      at once to `std::io::prelude::*`.
    
    This is a breaking change because many prelude reexports have been removed, and
    the RFC can be consulted for the exact list of removed reexports, as well as to
    find the locations of where to import them.
    
    [rfc]: https://github.com/rust-lang/rfcs/blob/master/text/0503-prelude-stabilization.md
    [breaking-change]
    
    Closes #20068

commit 71b46b18a274edc7f7fb60b490e5ebbb9c911462
Merge: 1f887c8 8dbaa71
Author: bors &lt;bors@rust-lang.org&gt;
Date:   Fri Jan 2 15:51:25 2015 +0000

    auto merge of #20356 : Gankro/rust/stab, r=aturon
    
    This stabilizes most of libcollections, carefully avoiding sections of API which are being managed in other PRs. APIs which are not stable are marked explicitly unstable with a reason.
    
    Deprecates:
    
    * DList
      * rotate_forward
      * rotate_backward
      * prepend
      * insert_when
      * insert_ordered
      * merge
    
    * VecMap
      * update
      * update_with_key
    
    * Renames and newtypes the Bitv and BitvSet iterators to match conventions.
    
    * Removes the Copy impl from DList's Iter.
    
    as such this is a
    
    [breaking-change]

commit 7506fe52696c5b3b628f173d74dc4a13b5ccc1f3
Author: Nick Cameron &lt;ncameron@mozilla.com&gt;
Date:   Wed Dec 31 17:25:18 2014 +1300

    Accept `derive` instead of `deriving`
    
    [breaking-change]
    
    `deriving is still accepted, but gives a deprecation warning

commit 74d11d26f4042ce04c56edfd6caafa003383147d
Author: Nick Cameron &lt;ncameron@mozilla.com&gt;
Date:   Wed Dec 31 17:24:42 2014 +1300

    Accept `self` in place of `mod` in use items
    
    [breaking-change]
    
    `mod` is still accepted, but gives a deprecated warning

commit c61a0092bc236c4be4cb691fcd50ff50e91ab0d6
Author: Niko Matsakis &lt;niko@alum.mit.edu&gt;
Date:   Fri Dec 26 03:30:51 2014 -0500

    Fix orphan checking (cc #19470). (This is not a complete fix of #19470 because of the backwards compatibility feature gate.)
    
    This is a [breaking-change]. The new rules require that, for an impl of a trait defined
    in some other crate, two conditions must hold:
    
    1. Some type must be local.
    2. Every type parameter must appear "under" some local type.
    
    Here are some examples that are legal:
    
    ```rust
    struct MyStruct&lt;T&gt; { ... }
    
    // Here `T` appears "under' `MyStruct`.
    impl&lt;T&gt; Clone for MyStruct&lt;T&gt; { }
    
    // Here `T` appears "under' `MyStruct` as well. Note that it also appears
    // elsewhere.
    impl&lt;T&gt; Iterator&lt;T&gt; for MyStruct&lt;T&gt; { }
    ```
    
    Here is an illegal example:
    
    ```rust
    // Here `U` does not appear "under" `MyStruct` or any other local type.
    // We call `U` "uncovered".
    impl&lt;T,U&gt; Iterator&lt;U&gt; for MyStruct&lt;T&gt; { }
    ```
    
    There are a couple of ways to rewrite this last example so that it is
    legal:
    
    1. In some cases, the uncovered type parameter (here, `U`) should be converted
       into an associated type. This is however a non-local change that requires access
       to the original trait. Also, associated types are not fully baked.
    2. Add `U` as a type parameter of `MyStruct`:
       ```rust
       struct MyStruct&lt;T,U&gt; { ... }
       impl&lt;T,U&gt; Iterator&lt;U&gt; for MyStruct&lt;T,U&gt; { }
       ```
    3. Create a newtype wrapper for `U`
       ```rust
       impl&lt;T,U&gt; Iterator&lt;Wrapper&lt;U&gt;&gt; for MyStruct&lt;T,U&gt; { }
       ```
    
    Because associated types are not fully baked, which in the case of the
    `Hash` trait makes adhering to this rule impossible, you can
    temporarily disable this rule in your crate by using
    `#![feature(old_orphan_check)]`. Note that the `old_orphan_check`
    feature will be removed before 1.0 is released.

commit f2ccdfd8914b7b8f8f8f2053f9ecd98d54ef95a6
Author: Alex Crichton &lt;alex@alexcrichton.com&gt;
Date:   Thu Jan 1 22:24:06 2015 -0800

    std: Second pass stabilization for `boxed`
    
    This commit performs a second pass over the `std::boxed` module, taking the
    following actions:
    
    * `boxed` is now stable
    * `Box` is now stable
    * `BoxAny` is removed in favor of a direct `impl Box&lt;Any&gt;`
    * `Box::downcast` remains unstable while the name of the `downcast` family of
      methods is determined.
    
    This is a breaking change due to the removal of the `BoxAny` trait (note that
    the `downcast` method still exists), and existing consumers of `BoxAny` simply
    need to remove the import in their modules.
    
    [breaking-change]

commit e423fcf0e0166da55f88233e0be5eacba55bc0bc
Author: Alex Crichton &lt;alex@alexcrichton.com&gt;
Date:   Fri Dec 12 10:59:41 2014 -0800

    std: Enforce Unicode in fmt::Writer
    
    This commit is an implementation of [RFC 526][rfc] which is a change to alter
    the definition of the old `fmt::FormatWriter`. The new trait, renamed to
    `Writer`, now only exposes one method `write_str` in order to guarantee that all
    implementations of the formatting traits can only produce valid Unicode.
    
    [rfc]: https://github.com/rust-lang/rfcs/blob/master/text/0526-fmt-text-writer.md
    
    One of the primary improvements of this patch is the performance of the
    `.to_string()` method by avoiding an almost-always redundant UTF-8 check. This
    is a breaking change due to the renaming of the trait as well as the loss of the
    `write` method, but migration paths should be relatively easy:
    
    * All usage of `write` should move to `write_str`. If truly binary data was
      being written in an implementation of `Show`, then it will need to use a
      different trait or an altogether different code path.
    
    * All usage of `write!` should continue to work as-is with no modifications.
    
    * All usage of `Show` where implementations just delegate to another should
      continue to work as-is.
    
    [breaking-change]
    
    Closes #20352

commit f3a7ec7028c76b3a1c6051131328f372b068e33a
Author: Alex Crichton &lt;alex@alexcrichton.com&gt;
Date:   Mon Dec 29 15:03:01 2014 -0800

    std: Second pass stabilization of sync
    
    This pass performs a second pass of stabilization through the `std::sync`
    module, avoiding modules/types that are being handled in other PRs (e.g.
    mutexes, rwlocks, condvars, and channels).
    
    The following items are now stable
    
    * `sync::atomic`
    * `sync::atomic::ATOMIC_BOOL_INIT` (was `INIT_ATOMIC_BOOL`)
    * `sync::atomic::ATOMIC_INT_INIT` (was `INIT_ATOMIC_INT`)
    * `sync::atomic::ATOMIC_UINT_INIT` (was `INIT_ATOMIC_UINT`)
    * `sync::Once`
    * `sync::ONCE_INIT`
    * `sync::Once::call_once` (was `doit`)
      * C == `pthread_once(..)`
      * Boost == `call_once(..)`
      * Windows == `InitOnceExecuteOnce`
    * `sync::Barrier`
    * `sync::Barrier::new`
    * `sync::Barrier::wait` (now returns a `bool`)
    * `sync::Semaphore::new`
    * `sync::Semaphore::acquire`
    * `sync::Semaphore::release`
    
    The following items remain unstable
    
    * `sync::SemaphoreGuard`
    * `sync::Semaphore::access` - it's unclear how this relates to the poisoning
                                  story of mutexes.
    * `sync::TaskPool` - the semantics of a failing task and whether a thread is
                         re-attached to a thread pool are somewhat unclear, and the
                         utility of this type in `sync` is question with respect to
                         the jobs of other primitives. This type will likely become
                         stable or move out of the standard library over time.
    * `sync::Future` - futures as-is have yet to be deeply re-evaluated with the
                       recent core changes to Rust's synchronization story, and will
                       likely become stable in the future but are unstable until
                       that time comes.
    
    [breaking-change]

commit d45b5d2ed9b43b3ad573482fb8820a382f20289e
Author: Nick Cameron &lt;ncameron@mozilla.com&gt;
Date:   Tue Dec 30 19:55:06 2014 +1300

    Disallow [_, ..n] syntax for fixed length arrays and repeating array constructors
    
    Closes #19999
    
    [breaking-change]
    
    Use [_; n] instead.

commit 39d74026663597a8d4ad0ab04e6d117bf9fd6ad4
Merge: c594959 41da99d
Author: bors &lt;bors@rust-lang.org&gt;
Date:   Thu Jan 1 15:51:08 2015 +0000

    auto merge of #20190 : cmr/rust/gate-macro-args, r=alexcrichton
    
    Uses the same approach as https://github.com/rust-lang/rust/pull/17286 (and
    subsequent changes making it more correct), where the visitor will skip any
    pieces of the AST that are from "foreign code", where the spans don't line up,
    indicating that that piece of code is due to a macro expansion.
    
    If this breaks your code, read the error message to determine which feature
    gate you should add to your crate.
    
    Closes #18102
    
    [breaking-change]

commit 41da99dff417eadf8f296a93529d9810f79e1d1b
Author: Corey Richardson &lt;corey@octayn.net&gt;
Date:   Wed Dec 24 00:44:13 2014 -0500

    Feature gate macro arguments
    
    Uses the same approach as https://github.com/rust-lang/rust/pull/17286 (and
    subsequent changes making it more correct), where the visitor will skip any
    pieces of the AST that are from "foreign code", where the spans don't line up,
    indicating that that piece of code is due to a macro expansion.
    
    If this breaks your code, read the error message to determine which feature
    gate you should add to your crate, and bask in the knowledge that your code
    won't mysteriously break should you try to use the 1.0 release.
    
    Closes #18102
    
    [breaking-change]

commit 47b8479e73e40395f1b1b2d0c6281f28f80301e4
Merge: 7d4f487 10bbf69
Author: bors &lt;bors@rust-lang.org&gt;
Date:   Thu Jan 1 04:01:02 2015 +0000

    auto merge of #20363 : japaric/rust/moar-uc, r=nmatsakis
    
    The the last argument of the `ItemDecorator::expand` method has changed to `Box&lt;FnMut&gt;`. Syntax extensions will break.
    
    [breaking-change]
    
    ---
    
    This PR removes pretty much all the remaining uses of boxed closures from the libraries. There are still boxed closures under the `test` directory, but I think those should be removed or replaced with unboxed closures at the same time we remove boxed closures from the language.
    
    In a few places I had to do some contortions (see the first commit for an example) to work around issue #19596. I have marked those workarounds with FIXMEs. In the future when `&amp;mut F where F: FnMut` implements the `FnMut` trait, we should be able to remove those workarounds. I've take care to avoid placing the workaround functions in the public API.
    
    Since `let f = || {}` always gets type checked as a boxed closure, I have explictly annotated those closures (with e.g. `|&amp;:| {}`) to force the compiler to type check them as unboxed closures.
    
    Instead of removing the type aliases (like `GetCrateDataCb`), I could have replaced them with newtypes. But this seemed like overcomplicating things for little to no gain.
    
    I think we should be able to remove the boxed closures from the languge after this PR lands. (I'm being optimistic here)
    
    r? @alexcrichton or @aturon
    cc @nikomatsakis

commit f9ce6f5ba458d6a3d4e63b282bac43a18e90aeb0
Author: Corey Farwell &lt;coreyf@rwell.org&gt;
Date:   Wed Dec 31 19:10:43 2014 -0800

    Remove core::iter::MinMaxResult::* public reexport
    
    Part of #19253
    
    [breaking-change]

commit a6f5b980cc44621efeed847e8d359f3b90c29080
Author: Alex Crichton &lt;alex@alexcrichton.com&gt;
Date:   Wed Dec 31 15:10:45 2014 -0800

    rustc: Re-jigger -L and -l for MSYS compatibility
    
    As discovered in #20376, the MSYS shell will silently rewrite arguemnts that
    look like unix paths into their windows path counterparts for compatibility, but
    the recently added `:kind` syntax added to the `-L` flag does not allow for this
    form of rewriting. This means that the syntax can be difficult to use at an MSYS
    prompt, as well as causing tests to fail when run manuall right now.
    
    This commit takes the other option presented in the original issue to prefix the
    path with `kind=` instead of suffixing it with `:kind`. For consistence, the
    `-l` flag is also now migrating to `kind=name`.
    
    This is a breaking change due to the *removal* of behavior with `-L`. All code
    using `:kind` should now pass `kind=` for `-L` arguments. This is not currently,
    but will become, a breaking change for `-l` flags. The old `name:kind` syntax is
    still accepted, but all code should update to `kind=name`.
    
    [breaking-change]
    Closes #20376

commit 38f9805f11721d854a59818e0ad7b8a0b6282301
Merge: 04f4221 1d26fb9
Author: Alex Crichton &lt;alex@alexcrichton.com&gt;
Date:   Tue Dec 30 16:26:22 2014 -0800

    rollup merge of #20348: frewsxcv/rm-reexports
    
    Part of #19253
    
    [breaking-change]

commit b94bcbf56eab163517e8ffc93888284b8dbb6238
Author: Aaron Turon &lt;aturon@mozilla.com&gt;
Date:   Tue Dec 30 14:44:26 2014 -0800

    Stabilize cmp
    
    This patch marks `PartialEq`, `Eq`, `PartialOrd`, and `Ord` as
    `#[stable]`, as well as the majorify of manual implementaitons of these
    traits. The traits match the [reform
    RFC](https://github.com/rust-lang/rfcs/pull/439).
    
    Along the way, two changes are made:
    
    * The recently-added type parameters for `Ord` and `Eq` are
      removed. These were mistakenly added while adding them to `PartialOrd`
      and `PartialEq`, but they don't make sense given the laws that are
      required for (and use cases for) `Ord` and `Eq`.
    
    * More explicit laws are added for `PartialEq` and `PartialOrd`,
      connecting them to their associated mathematical concepts.
    
    In the future, many of the impls should be generalized; see
    since generalizing later is not a breaking change.
    
    [breaking-change]

commit e91d810b9b36d6bb163970cd0e8bbf4692f704bb
Author: Aaron Turon &lt;aturon@mozilla.com&gt;
Date:   Sun Nov 2 20:27:46 2014 -0800

    Libs: Unify concat and concat_vec
    
    We've long had traits `StrVector` and `VectorVector` providing
    `concat`/`connect` and `concat_vec`/`connect_vec` respectively. The
    reason for the distinction is that coherence rules did not used to be
    robust enough to allow impls on e.g. `Vec&lt;String&gt;` versus `Vec&lt;&amp;[T]&gt;`.
    
    This commit consolidates the traits into a single `SliceConcatExt` trait
    provided by `slice` and the preldue (where it replaces `StrVector`,
    which is removed.)
    
    [breaking-change]

commit 4f863a338e0a7c33f81a8ac138103f1a0e8b33c5
Author: Aaron Turon &lt;aturon@mozilla.com&gt;
Date:   Wed Dec 17 20:50:16 2014 -0800

    Second pass stabilization: slice
    
    This commit takes a second pass through the `slice` module to
    stabilize its API. The changes are as follows:
    
    **Stable**:
    
    * `as_mut_slice`
    * `as_ptr`, `as_mut_ptr`
    * `binary_search_by` (was: `binary_search`)
    * `binary_search` (was: `binary_search_elem`)
    * `chunks`, `chunks_mut`
    * `contains`
    * `ends_with`
    * `first`, `first_mut` (was: `head`)
    * `get_unchecked`, `get_unchecked_mut` (was: `unsafe_get`)
    * `get`
    * `is_empty`
    * `iter`, `iter_mut`
    * `len`
    * `reverse`
    * `sort_by`
    * `sort`
    * `split_at`, `split_at_mut`
    * `split_mut`, `splitn_mut`, `rsplitn_mut`
    * `split`, `splitn`, `rsplitn`
    * `starts_with`
    * `swap`
    * `to_vec`
    * `windows`
    
    **Deprecated**:
    
    * `head`, `head_mut` (renamed as above)
    * `unsafe_get`, `unsafe_mut` (renamed as above)
    * `binary_search_elem` (renamed as above)
    * `partitioned`, deprecated in favor of a new, more
      general iterator consumer called `partition`.
    * `BinarySearchResult`, deprecated in favor of `Result&lt;uint, uint&gt;`
    
    [breaking-change]

commit 9d919d2302b5df42e3bf8979560e0da21f4b2bad
Author: Aaron Turon &lt;aturon@mozilla.com&gt;
Date:   Tue Dec 16 23:44:43 2014 -0800

    Second pass stabilization: vec
    
    This commit takes a second pass through the `vec` module to
    stabilize its API. The changes are as follows:
    
    **Stable**:
    
    * `dedup`
    * `from_raw_parts`
    * `insert`
    * `into_iter`
    * `is_empty`
    * `remove`
    * `reserve_exact`
    * `reserve`
    * `retain`
    * `swap_remove`
    * `truncate`
    
    **Deprecated**:
    
    * `from_fn`, `from_elem`, `grow_fn` and `grow`, all deprecated in
      favor of iterators. See https://github.com/rust-lang/rfcs/pull/509
    
    * `partition`, `partitioned`, deprecated in favor of a new, more
      general iterator consumer called `partition`.
    
    * `unzip`, deprecated in favor of a new, more general iterator
      consumer called `unzip`.
    
    A few remaining methods are left at experimental status.
    
    [breaking-change]

commit 1d26fb9e07e664b312ca9d7b666f6d1dd52285ed
Author: Corey Farwell &lt;coreyf@rwell.org&gt;
Date:   Tue Dec 30 10:19:20 2014 -0800

    Remove core::atomic::Ordering::* public reexport
    
    Part of #19253
    
    [breaking-change]

commit 79db01a30d22950ad1597d495b76d2f58da859dc
Merge: 806cb35 b26daf3
Author: Alex Crichton &lt;alex@alexcrichton.com&gt;
Date:   Mon Dec 29 16:36:52 2014 -0800

    rollup merge of #20306: alexcrichton/second-pass-string
    
    This commit performs a second pass over the `std::string` module, performing the
    following actions:
    
    * The name `std::string` is now stable.
    * The `String::from_utf8` function is now stable after having been altered to
      return a new `FromUtf8Error` structure. The `FromUtf8Error` structure is now
      stable as well as its `into_bytes` and `utf8_error` methods.
    * The `String::from_utf8_lossy` function is now stable.
    * The `String::from_chars` method is now deprecated in favor of `.collect()`
    * The `String::from_raw_parts` method is now stable
    * The `String::from_str` function remains experimental
    * The `String::from_raw_buf` function remains experimental
    * The `String::from_raw_buf_len` function remains experimental
    * The `String::from_utf8_unchecked` function is now stable
    * The `String::from_char` function is now deprecated in favor of
      `repeat(c).take(n).collect()`
    * The `String::grow` function is now deprecated in favor of
      `.extend(repeat(c).take(n)`
    * The `String::capacity` method is now stable
    * The `String::reserve` method is now stable
    * The `String::reserve_exact` method is now stable
    * The `String::shrink_to_fit` method is now stable
    * The `String::pop` method is now stable
    * The `String::as_mut_vec` method is now stable
    * The `String::is_empty` method is now stable
    * The `IntoString` trait is now deprecated (there are no implementors)
    * The `String::truncate` method is now stable
    * The `String::insert` method is now stable
    * The `String::remove` method is now stable
    * The `String::push` method is now stable
    * The `String::push_str` method is now stable
    * The `String::from_utf16` function is now stable after its error type has now
      become an opaque structure to carry more semantic information in the future.
    
    A number of these changes are breaking changes, but the migrations should be
    fairly straightforward on a case-by-case basis (outlined above where possible).
    
    [breaking-change]

commit 748440c5b3bad8a837918400973e9d6cbb58fa7a
Merge: 9f6eb29 6256973
Author: Alex Crichton &lt;alex@alexcrichton.com&gt;
Date:   Mon Dec 29 16:36:06 2014 -0800

    rollup merge of #20215: csouth3/hashmap-rename
    
    Rename struct `Entries` to `Iter` in hash/table.rs and hash/map.rs, to match the naming convention of rust-lang/rfcs#344.
    
    This is a [breaking-change].

commit cc20d6009ebf46b7ec75020ebfe35ff0ef064d1b
Merge: 94d82c1 35e63e3
Author: Alex Crichton &lt;alex@alexcrichton.com&gt;
Date:   Mon Dec 29 16:35:50 2014 -0800

    rollup merge of #19661: alexcrichton/mutex-result
    
    All of the current std::sync primitives have poisoning enable which means that
    when a task fails inside of a write-access lock then all future attempts to
    acquire the lock will fail. This strategy ensures that stale data whose
    invariants are possibly not upheld are never viewed by other tasks to help
    propagate unexpected panics (bugs in a program) among tasks.
    
    Currently there is no way to test whether a mutex or rwlock is poisoned. One
    method would be to duplicate all the methods with a sister foo_catch function,
    for example. This pattern is, however, against our [error guidelines][errors].
    As a result, this commit exposes the fact that a task has failed internally
    through the return value of a `Result`.
    
    [errors]: https://github.com/rust-lang/rfcs/blob/master/text/0236-error-conventions.md#do-not-provide-both-result-and-fail-variants
    
    All methods now return a `LockResult&lt;T&gt;` or a `TryLockResult&lt;T&gt;` which
    communicates whether the lock was poisoned or not. In a `LockResult`, both the
    `Ok` and `Err` variants contains the `MutexGuard&lt;T&gt;` that is being returned in
    order to allow access to the data if poisoning is not desired. This also means
    that the lock is *always* held upon returning from `.lock()`.
    
    A new type, `PoisonError`, was added with one method `into_guard` which can
    consume the assertion that a lock is poisoned to gain access to the underlying
    data.
    
    This is a breaking change because the signatures of these methods have changed,
    often incompatible ways. One major difference is that the `wait` methods on a
    condition variable now consume the guard and return it in as a `LockResult` to
    indicate whether the lock was poisoned while waiting. Most code can be updated
    by calling `.unwrap()` on the return value of `.lock()`.
    
    [breaking-change]

commit 4e2afb0052618ca3d758fffd0cf50559be774391
Author: Nick Cameron &lt;ncameron@mozilla.com&gt;
Date:   Fri Dec 19 11:47:48 2014 +1300

    Remove ExprSlice by hacking the compiler
    
    [breaking-change]
    
    The `mut` in slices is now redundant. Mutability is 'inferred' from position. This means that if mutability is only obvious from the type, you will need to use explicit calls to the slicing methods.

commit b26daf3a67a4e283a5e2c49227b60a2321434de0
Author: Alex Crichton &lt;alex@alexcrichton.com&gt;
Date:   Sun Dec 28 10:29:56 2014 -0800

    std: Second pass stabilization for `string`
    
    This commit performs a second pass over the `std::string` module, performing the
    following actions:
    
    * The name `std::string` is now stable.
    * The `String::from_utf8` function is now stable after having been altered to
      return a new `FromUtf8Error` structure. The `FromUtf8Error` structure is now
      stable as well as its `into_bytes` and `utf8_error` methods.
    * The `String::from_utf8_lossy` function is now stable.
    * The `String::from_chars` method is now deprecated in favor of `.collect()`
    * The `String::from_raw_parts` method is now stable
    * The `String::from_str` function remains experimental
    * The `String::from_raw_buf` function remains experimental
    * The `String::from_raw_buf_len` function remains experimental
    * The `String::from_utf8_unchecked` function is now stable
    * The `String::from_char` function is now deprecated in favor of
      `repeat(c).take(n).collect()`
    * The `String::grow` function is now deprecated in favor of
      `.extend(repeat(c).take(n)`
    * The `String::capacity` method is now stable
    * The `String::reserve` method is now stable
    * The `String::reserve_exact` method is now stable
    * The `String::shrink_to_fit` method is now stable
    * The `String::pop` method is now stable
    * The `String::as_mut_vec` method is now stable
    * The `String::is_empty` method is now stable
    * The `IntoString` trait is now deprecated (there are no implementors)
    * The `String::truncate` method is now stable
    * The `String::insert` method is now stable
    * The `String::remove` method is now stable
    * The `String::push` method is now stable
    * The `String::push_str` method is now stable
    * The `String::from_utf16` function is now stable after its error type has now
      become an opaque structure to carry more semantic information in the future.
    
    A number of these changes are breaking changes, but the migrations should be
    fairly straightforward on a case-by-case basis (outlined above where possible).
    
    [breaking-change]

commit bc83a009f655dd3896be4a7cd33cac8032a605f2
Author: Alex Crichton &lt;alex@alexcrichton.com&gt;
Date:   Tue Dec 23 11:53:35 2014 -0800

    std: Second pass stabilization for `comm`
    
    This commit is a second pass stabilization for the `std::comm` module,
    performing the following actions:
    
    * The entire `std::comm` module was moved under `std::sync::mpsc`. This movement
      reflects that channels are just yet another synchronization primitive, and
      they don't necessarily deserve a special place outside of the other
      concurrency primitives that the standard library offers.
    * The `send` and `recv` methods have all been removed.
    * The `send_opt` and `recv_opt` methods have been renamed to `send` and `recv`.
      This means that all send/receive operations return a `Result` now indicating
      whether the operation was successful or not.
    * The error type of `send` is now a `SendError` to implement a custom error
      message and allow for `unwrap()`. The error type contains an `into_inner`
      method to extract the value.
    * The error type of `recv` is now `RecvError` for the same reasons as `send`.
    * The `TryRecvError` and `TrySendError` types have had public reexports removed
      of their variants and the variant names have been tweaked with enum
      namespacing rules.
    * The `Messages` iterator is renamed to `Iter`
    
    This functionality is now all `#[stable]`:
    
    * `Sender`
    * `SyncSender`
    * `Receiver`
    * `std::sync::mpsc`
    * `channel`
    * `sync_channel`
    * `Iter`
    * `Sender::send`
    * `Sender::clone`
    * `SyncSender::send`
    * `SyncSender::try_send`
    * `SyncSender::clone`
    * `Receiver::recv`
    * `Receiver::try_recv`
    * `Receiver::iter`
    * `SendError`
    * `RecvError`
    * `TrySendError::{mod, Full, Disconnected}`
    * `TryRecvError::{mod, Empty, Disconnected}`
    * `SendError::into_inner`
    * `TrySendError::into_inner`
    
    This is a breaking change due to the modification of where this module is
    located, as well as the changing of the semantics of `send` and `recv`. Most
    programs just need to rename imports of `std::comm` to `std::sync::mpsc` and
    add calls to `unwrap` after a send or a receive operation.
    
    [breaking-change]

commit 19f73b4ef6fb1d24f19738a8665889396fc1b0c8
Merge: 3dcc409 c1f3aca
Author: bors &lt;bors@rust-lang.org&gt;
Date:   Mon Dec 29 18:02:30 2014 +0000

    auto merge of #20058 : Kimundi/rust/str_pattern_pre, r=alexcrichton
    
    This stabilizes most methods on `&amp;str` working with patterns in a way that is forwards-compatible with a generic string pattern matching API:
    - Methods that are using the primary name for their operation are marked as `#[stable]`, as they can be upgraded to a full `Pattern` API later without existing code breaking. Example: `contains(&amp;str)`
    - Methods that are using a more specific name in order to not clash with the primary one are marked as `#[unstable]`, as they will likely be removed once their functionality is merged into the primary one. Example: `contains_char&lt;C: CharEq&gt;(C)`
    - The method docs got changed to consistently refer to the pattern types as a pattern.
    - Methods whose names do not match in the context of the more generic API got renamed. Example: `trim_chars -&gt; trim_matches`
    
    Additionally, all methods returning iterators got changed to return unique new types with changed names in accordance with the new naming guidelines.
    
    See also https://github.com/rust-lang/rfcs/pull/528
    
    Due to some deprecations and type changes, this is a
    
    [breaking-change]

commit 76e5ed655c762b812c3da4749a55f1bb1b52c787
Author: Alex Crichton &lt;alex@alexcrichton.com&gt;
Date:   Mon Dec 8 20:20:03 2014 -0800

    std: Return Result from RWLock/Mutex methods
    
    All of the current std::sync primitives have poisoning enable which means that
    when a task fails inside of a write-access lock then all future attempts to
    acquire the lock will fail. This strategy ensures that stale data whose
    invariants are possibly not upheld are never viewed by other tasks to help
    propagate unexpected panics (bugs in a program) among tasks.
    
    Currently there is no way to test whether a mutex or rwlock is poisoned. One
    method would be to duplicate all the methods with a sister foo_catch function,
    for example. This pattern is, however, against our [error guidelines][errors].
    As a result, this commit exposes the fact that a task has failed internally
    through the return value of a `Result`.
    
    [errors]: https://github.com/rust-lang/rfcs/blob/master/text/0236-error-conventions.md#do-not-provide-both-result-and-fail-variants
    
    All methods now return a `LockResult&lt;T&gt;` or a `TryLockResult&lt;T&gt;` which
    communicates whether the lock was poisoned or not. In a `LockResult`, both the
    `Ok` and `Err` variants contains the `MutexGuard&lt;T&gt;` that is being returned in
    order to allow access to the data if poisoning is not desired. This also means
    that the lock is *always* held upon returning from `.lock()`.
    
    A new type, `PoisonError`, was added with one method `into_guard` which can
    consume the assertion that a lock is poisoned to gain access to the underlying
    data.
    
    This is a breaking change because the signatures of these methods have changed,
    often incompatible ways. One major difference is that the `wait` methods on a
    condition variable now consume the guard and return it in as a `LockResult` to
    indicate whether the lock was poisoned while waiting. Most code can be updated
    by calling `.unwrap()` on the return value of `.lock()`.
    
    [breaking-change]

commit c32d03f4172580e3f33e4844ed3c01234dca2d53
Author: Alex Crichton &lt;alex@alexcrichton.com&gt;
Date:   Mon Dec 22 09:04:23 2014 -0800

    std: Stabilize the prelude module
    
    This commit is an implementation of [RFC 503][rfc] which is a stabilization
    story for the prelude. Most of the RFC was directly applied, removing reexports.
    Some reexports are kept around, however:
    
    * `range` remains until range syntax has landed to reduce churn.
    * `Path` and `GenericPath` remain until path reform lands. This is done to
      prevent many imports of `GenericPath` which will soon be removed.
    * All `io` traits remain until I/O reform lands so imports can be rewritten all
      at once to `std::io::prelude::*`.
    
    This is a breaking change because many prelude reexports have been removed, and
    the RFC can be consulted for the exact list of removed reexports, as well as to
    find the locations of where to import them.
    
    [rfc]: https://github.com/rust-lang/rfcs/blob/master/text/0503-prelude-stabilization.md
    [breaking-change]
    
    Closes #20068

commit f53314cd70dd194ea40c55a5d8ceae7b94409aea
Author: Nick Cameron &lt;ncameron@mozilla.com&gt;
Date:   Mon Dec 29 09:33:25 2014 +1300

    Remove the glob/shadowing exception bug
    
    [breaking-change]
    
    This and the other commit in this PR change the rules for shadowing and globs to be
    stricter. There were previously bugs where some glob imports would not be checked
    for shadowing. Those are now fixed and you may have to adjust your imports to use
    fewer globs.

commit 1e89bbcb67020892bc0af5af218c35f0fd453fa4
Author: Simonas Kazlauskas &lt;git@kazlauskas.me&gt;
Date:   Sun Dec 28 02:20:47 2014 +0200

    Rename TaskRng to ThreadRng
    
    Since runtime is removed, rust has no tasks anymore and everything is moving
    from being task-* to thread-*. Let’s rename TaskRng as well!
    
    * Rename TaskRng to ThreadRng
    * Rename task_rng to thread_rng
    
    [breaking-change]

commit 3e6b29f8ad1ddfcb134d743a66ee5f467e16c350
Merge: 070ab63 647e54d
Author: bors &lt;bors@rust-lang.org&gt;
Date:   Sun Dec 28 03:11:48 2014 +0000

    auto merge of #20136 : eddyb/rust/format-args, r=alexcrichton
    
    We have the technology: no longer do you need to write closures to use `format_args!`.
    This is a `[breaking-change]`, as it forces you to clean up old hacks - if you had code like this:
    ```rust
    format_args!(fmt::format, "{} {} {}", a, b, c)
    format_args!(|args| { w.write_fmt(args) }, "{} {} {}", x, y, z)
    ```
    change it to this:
    ```rust
    fmt::format(format_args!("{} {} {}", a, b, c))
    w.write_fmt(format_args!("{} {} {}", x, y, z))
    ```
    To allow them to be called with `format_args!(...)` directly, several functions were modified to
    take `fmt::Arguments` by value instead of by reference. Also, `fmt::Arguments` derives `Copy`
    now in order to preserve all usecases that were previously possible.

commit 070ab63807dc80fa6a6c5ee80531284761ab42de
Merge: 0201334 12e6071
Author: bors &lt;bors@rust-lang.org&gt;
Date:   Sat Dec 27 21:51:43 2014 +0000

    auto merge of #19916 : SimonSapin/rust/ascii-reform, r=sfackler
    
    Implements [RFC 486](https://github.com/rust-lang/rfcs/pull/486). Fixes #19908.
    
    * Rename `to_ascii_{lower,upper}` to `to_ascii_{lower,upper}case`, per #14401
    * Remove the `Ascii` type and associated traits: `AsciiCast`, `OwnedAsciiCast`, `AsciiStr`, `IntoBytes`, and `IntoString`.
    * As a replacement, add `.is_ascii()` to `AsciiExt`, and implement `AsciiExt` for `u8` and `char`.
    
    [breaking-change]

commit df0c6d93852c51b6936d4b72b6b4be5f1932fb8a
Author: Nick Cameron &lt;ncameron@mozilla.com&gt;
Date:   Sun Nov 23 22:29:41 2014 +1300

    save-analysis: emit names of items that a glob import actually imports.
    
    There is also some work here to make resolve a bit more stable - it no longer overwrites a specific import with a glob import.
    
    [breaking-change]
    
    Import shadowing of single/list imports by globs is now forbidden. An interesting case is where a glob import imports a re-export (`pub use`) of a single import. This still counts as a single import for the purposes of shadowing .You can usually fix any bustage by re-ordering such imports. A single import may still shadow (override) a glob import or the prelude.

commit 3a6ccdc263d9a169c2d317a6f78664e1f18d3b15
Author: Simon Sapin &lt;simon.sapin@exyr.org&gt;
Date:   Sun Dec 7 01:55:34 2014 +0000

    Remove Ascii, AsciiCast, OwnedAsciiCast, AsciiStr, IntoBytes, IntoString.
    
    As a replacement, add is_ascii() to AsciiExt, and implement AsciiExt for u8 and char.
    
    [breaking-change]

commit d9769ec3834b62318da892925dc24c8883bb1635
Author: P1start &lt;rewi-github@whanau.org&gt;
Date:   Tue Dec 23 13:13:49 2014 +1300

    Parse fully-qualified associated types in generics without whitespace
    
    This breaks code that looks like this:
    
        let x = foo as bar &lt;&lt; 13;
    
    Change such code to look like this:
    
        let x = (foo as bar) &lt;&lt; 13;
    
    Closes #17362.
    
    [breaking-change]

commit 625697354db8a13450f6d56c7a384c202a79c9db
Author: Chase Southwood &lt;chase.southwood@gmail.com&gt;
Date:   Wed Dec 24 20:19:48 2014 -0600

    Rename remaining hashmap and hashtable iterators to match naming
    conventions.
    
    This is a [breaking-change].

commit 7e11b22713aebd28ceaaa2ecef937c9b9d247c2f
Merge: 14597f9 85c1a4b
Author: bors &lt;bors@rust-lang.org&gt;
Date:   Wed Dec 24 20:47:12 2014 +0000

    auto merge of #20117 : lfairy/rust/rename-include-bin, r=alexcrichton
    
    According to [RFC 344][], methods that return `&amp;[u8]` should have names ending in `bytes`. Though `include_bin!` is a macro not a method, it seems reasonable to follow the convention anyway.
    
    We keep the old name around for now, but trigger a deprecation warning when it is used.
    
    [RFC 344]: https://github.com/rust-lang/rfcs/blob/master/text/0344-conventions-galore.md
    
    [breaking-change]

commit 1e5811ef9271644db0d0ddaae351976b0d4abdd2
Author: Simon Sapin &lt;simon.sapin@exyr.org&gt;
Date:   Fri Dec 5 09:57:42 2014 -0800

    Rename to_ascii_{lower,upper} to to_ascii_{lower,upper}case, per #14401
    
    [breaking-change]

commit 96a3c7c6a051ab2f5fc01fe9e686f7fffcc87c61
Merge: d10642e 16f01cc
Author: bors &lt;bors@rust-lang.org&gt;
Date:   Tue Dec 23 22:21:10 2014 +0000

    auto merge of #19758 : tbu-/rust/pr_fp_name, r=alexcrichton
    
    This is a [breaking-change].

commit 16f01cc13f6a092873096c44eed546561b88d245
Author: Tobias Bucher &lt;tobiasbucher5991@gmail.com&gt;
Date:   Mon Dec 22 22:50:57 2014 +0100

    Rename and namespace `FPCategory`
    
    Rename `FPCategory` to `FpCategory` and `Fp* to `*` in order to adhere to the
    naming convention
    
    This is a [breaking-change].
    
    Existing code like this:
    ```
    use std::num::{FPCategory, FPNaN};
    ```
    should be adjusted to this:
    ```
    use std::num::FpCategory as Fp
    ```
    
    In the following code you can use the constants `Fp::Nan`, `Fp::Normal`, etc.

commit 85c1a4b1ba09dae786b3554e0ab596814efabe0e
Author: Chris Wong &lt;lambda.fairy@gmail.com&gt;
Date:   Mon Dec 22 10:57:09 2014 +1300

    Rename include_bin! to include_bytes!
    
    According to [RFC 344][], methods that return `&amp;[u8]` should have names
    ending in `bytes`. Though `include_bin!` is a macro not a method, it
    seems reasonable to follow the convention anyway.
    
    We keep the old name around for now, but trigger a deprecation warning
    when it is used.
    
    [RFC 344]: https://github.com/rust-lang/rfcs/blob/master/text/0344-conventions-galore.md
    
    [breaking-change]

commit fac17defcb8d0642c25bf8f791e1dc5b4e110be8
Merge: ca441df 02feaf2
Author: Alex Crichton &lt;alex@alexcrichton.com&gt;
Date:   Mon Dec 22 12:48:16 2014 -0800

    rollup merge of #20140: frewsxcv/rm-reexports
    
    Part of #19253
    
    I would have removed this public reexport in #19842, but #19812 hadn't merged (and snapshotted) at the time
    
    In #19407, I changed the codebase to stop utilizing this reexport
    
    [breaking-change]

commit 4baeacef5a539fa29b88c951d6eca996d6101148
Merge: 7311b63 ee9de3b
Author: Alex Crichton &lt;alex@alexcrichton.com&gt;
Date:   Mon Dec 22 12:47:31 2014 -0800

    rollup merge of #20075: skade/remove-notrust
    
    Internally refactor all mentions of `notrust` to the
    positive statement `rust`.
    
    [breaking-change] Change remaining `notrust` markers to
    the thing they actually represent, e.g. `sh` or `plain`.
    
    This supersedes #19693 .

commit 7311b6347de4205b71e8a221140a527e789fd353
Merge: b04bc5c abf492d
Author: Alex Crichton &lt;alex@alexcrichton.com&gt;
Date:   Mon Dec 22 12:47:11 2014 -0800

    rollup merge of #20053: csouth3/misc-stab
    
    This pull request:
    
    *Renames `BinaryHeap::top` to `BinaryHeap::peek`
    *Stabilizes `front/back/front_mut/back_mut` in `DList` and `RingBuf`
    *Stabilizes `swap` in `RingBuf`
    
    in accordance with rust-lang/rfcs#509.
    
    Note that this PR does not address `Bitv::{get,set}` or HashMap's iterators, nor does it move `std::vec` to `std::collections::vec`, all of which still need to be done.
    
    Because of the method renaming, this is a [breaking-change].

commit b04bc5cc49a398df712092a68ab9ad83019498ad
Merge: 9b99436 a76a802
Author: Alex Crichton &lt;alex@alexcrichton.com&gt;
Date:   Mon Dec 22 12:46:31 2014 -0800

    rollup merge of #20033: alexcrichton/deprecate-serialise
    
    This commit completes the deprecation story for the in-tree serialization
    library. The compiler will now emit a warning whenever it encounters
    `deriving(Encodable)` or `deriving(Decodable)`, and the library itself is now
    marked `#[unstable]` for when feature staging is enabled.
    
    All users of serialization can migrate to the `rustc-serialize` crate on
    crates.io which provides the exact same interface as the libserialize library
    in-tree. The new deriving modes are named `RustcEncodable` and `RustcDecodable`
    and require `extern crate "rustc-serialize" as rustc_serialize` at the crate
    root in order to expand correctly.
    
    To migrate all crates, add the following to your `Cargo.toml`:
    
        [dependencies]
        rustc-serialize = "0.1.1"
    
    And then add the following to your crate root:
    
        extern crate "rustc-serialize" as rustc_serialize;
    
    Finally, rename `Encodable` and `Decodable` deriving modes to `RustcEncodable`
    and `RustcDecodable`.
    
    [breaking-change]

commit 2f55a9db0de8b2a2d72c7139eae38272d4d8cf41
Merge: 34d6800 20d7a5f
Author: Alex Crichton &lt;alex@alexcrichton.com&gt;
Date:   Mon Dec 22 12:45:52 2014 -0800

    rollup merge of #19216: Gankro/bitv
    
    Part of #18424
    
    This commit changes the semantics of `reserve` and `capacity` for Bitv and BitvSet to match conventions. It also introduces the notion of `reserve_index` and `reserve_index_exact` for collections with maximum-index-based capacity semantics.
    
    Deprecates free function constructors in favour of functions on Bitv itself.
    
    Changes `Bitv::pop` to return an Option rather than panicking.
    
    Deprecates and renames several methods in favour of conventions.
    
    Marks several blessed methods as unstable.
    
    This commit also substantially refactors Bitv and BitvSet's implementations. The new implementation is simpler, cleaner, better documented, and more robust against overflows. It also reduces coupling between Bitv and BitvSet. Tests have been seperated into seperate submodules.
    
    Fixes #16958
    
    [breaking-change]

commit 02feaf2a804e4e810d5a3adbedbcbe3905692286
Author: Corey Farwell &lt;coreyf@rwell.org&gt;
Date:   Mon Dec 22 11:09:55 2014 -0800

    Remove cmp::Ordering::* public reexport
    
    Part of #19253
    
    I would have removed this public reexport in #19842, but #19812 hadn't merged (and snapshotted) at the time
    
    In #19407, I changed the codebase to stop utilizing this reexport
    
    [breaking-change]

commit 22050e3ed44d9b4d79edced506b470a425e0d302
Author: Florian Wilkens &lt;floya@live.de&gt;
Date:   Sat Dec 20 15:28:20 2014 +0100

    Added missing renames:
    
    libcollections:
        AbsEntries -&gt; AbsIter, Entries -&gt; Iter, MoveEntries -&gt; IntoIter, MutEntries -&gt; IterMut
        DifferenceItems -&gt; Difference, SymDifferenceItems -&gt; SymmetricDifference, IntersectionItems -&gt; Intersection, UnionItems -&gt; Union
    
    libstd/hash/{table, map}:
        Entries -&gt; Iter, MoveItems -&gt; IntoIter, MutEntries -&gt; IterMut
    
    Also a [breaking-change].

commit f8cfd2480b69a1cc266fc91d0b60c825a9dc18a7
Author: Florian Wilkens &lt;floya@live.de&gt;
Date:   Fri Dec 19 21:52:10 2014 +0100

    Renaming of the Iter types as in RFC #344
    
    libcore: slice::Items -&gt; slice::Iter, slice::MutItems -&gt; slice::IterMut
    libcollections: *::Items -&gt; *::Iter, *::MoveItems -&gt; *::IntoIter, *::MutItems -&gt; *::IterMut
    
    This is of course a [breaking-change].

commit a76a80276852f05f30adaa4d2a8a2729b5fc0bfa
Author: Alex Crichton &lt;alex@alexcrichton.com&gt;
Date:   Thu Dec 18 22:52:48 2014 -0800

    serialize: Fully deprecate the library
    
    This commit completes the deprecation story for the in-tree serialization
    library. The compiler will now emit a warning whenever it encounters
    `deriving(Encodable)` or `deriving(Decodable)`, and the library itself is now
    marked `#[unstable]` for when feature staging is enabled.
    
    All users of serialization can migrate to the `rustc-serialize` crate on
    crates.io which provides the exact same interface as the libserialize library
    in-tree. The new deriving modes are named `RustcEncodable` and `RustcDecodable`
    and require `extern crate "rustc-serialize" as rustc_serialize` at the crate
    root in order to expand correctly.
    
    To migrate all crates, add the following to your `Cargo.toml`:
    
        [dependencies]
        rustc-serialize = "0.1.1"
    
    And then add the following to your crate root:
    
        extern crate "rustc-serialize" as rustc_serialize;
    
    Finally, rename `Encodable` and `Decodable` deriving modes to `RustcEncodable`
    and `RustcDecodable`.
    
    [breaking-change]

commit abf492d44f0a3b705be8c0920bfb4771f039b843
Author: Chase Southwood &lt;chase.southwood@gmail.com&gt;
Date:   Fri Dec 19 17:53:40 2014 -0600

    Misc Stabilization for collections
    
    This commit:
    
    *Renames `BinaryHeap::top` to `BinaryHeap::peek`
    *Stabilizes `front/back/front_mut/back_mut` in `DList` and `RingBuf`
    *Stabilizes `swap` in `RingBuf`
    
    Because of the method renaming, this is a [breaking-change].

commit 25f8051f2ebdc9444e0f75e91dc0cbb45d194181
Merge: bc99ced 98af642
Author: Alex Crichton &lt;alex@alexcrichton.com&gt;
Date:   Sun Dec 21 00:03:59 2014 -0800

    rollup merge of #19842: frewsxcv/rm-reexports
    
    Remove most of the public reexports mentioned in #19253
    
    These are all leftovers from the enum namespacing transition
    
    In particular:
    
    * src/libstd/num/strconv.rs
     * ExponentFormat
     * SignificantDigits
     * SignFormat
    * src/libstd/path/windows.rs
     * PathPrefix
    * src/libstd/sys/windows/timer.rs
     * Req
    * src/libcollections/str.rs
     * MaybeOwned
    * src/libstd/collections/hash/map.rs
     * Entry
    * src/libstd/collections/hash/table.rs
     * BucketState
    * src/libstd/dynamic_lib.rs
     * Rtld
    * src/libstd/os.rs
     * MemoryMapKind
     * MapOption
     * MapError
    * src/libstd/sys/common/net.rs
     * SocketStatus
     * InAddr
    * src/libstd/sys/unix/timer.rs
     * Req
    
    [breaking-change]

commit 98af642f5c8f60ae141a5d3ff92e8cc4e4317342
Author: Corey Farwell &lt;coreyf@rwell.org&gt;
Date:   Sat Dec 13 11:15:18 2014 -0500

    Remove a ton of public reexports
    
    Remove most of the public reexports mentioned in #19253
    
    These are all leftovers from the enum namespacing transition
    
    In particular:
    
    * src/libstd/num/strconv.rs
     * ExponentFormat
     * SignificantDigits
     * SignFormat
    * src/libstd/path/windows.rs
     * PathPrefix
    * src/libstd/sys/windows/timer.rs
     * Req
    * src/libcollections/str.rs
     * MaybeOwned
    * src/libstd/collections/hash/map.rs
     * Entry
    * src/libstd/collections/hash/table.rs
     * BucketState
    * src/libstd/dynamic_lib.rs
     * Rtld
    * src/libstd/io/net/ip.rs
     * IpAddr
    * src/libstd/os.rs
     * MemoryMapKind
     * MapOption
     * MapError
    * src/libstd/sys/common/net.rs
     * SocketStatus
     * InAddr
    * src/libstd/sys/unix/timer.rs
     * Req
    
    [breaking-change]

commit 9c5101542d2a4983ade627bc593e16c0bb5f23ba
Author: Alexis Beingessner &lt;a.beingessner@gmail.com&gt;
Date:   Fri Nov 21 20:47:40 2014 -0500

    Conventions and cleanup for Bitv and BitvSet
    
    Part of #18424
    
    This commit changes the semantics of `reserve` and `capacity` for Bitv and BitvSet to match conventions. It also introduces the notion of `reserve_index` and `reserve_index_exact` for collections with maximum-index-based capacity semantics.
    
    Deprecates free function constructors in favour of functions on Bitv itself.
    
    Changes `Bitv::pop` to return an Option rather than panicking.
    
    Deprecates and renames several methods in favour of conventions.
    
    Marks several blessed methods as unstable.
    
    This commit also substantially refactors Bitv and BitvSet's implementations. The new implementation is simpler, cleaner, better documented, and more robust against overflows. It also reduces coupling between Bitv and BitvSet. Tests have been seperated into seperate submodules.
    
    Fixes #16958
    
    [breaking-change]

commit cf350ea5eb562fcfb67775ad4d847e441a8006a4
Author: bluss &lt;bluss&gt;
Date:   Fri Dec 19 21:54:50 2014 +0100

    hashset: Clean up and rename the HashSet iterators
    
    This removes the type SetAlgebraItems and replaces it with the
    structs Intersection and Difference.
    
    Rename the existing HashSet iterators according to RFC #344:
    
    * SetItems -&gt; Iter
    * SetMoveItems -&gt; IntoIter
    * Remaining set combination iterators renamed to Union and SymmetricDifference
    
    [breaking-change]
</pre></body></html>
